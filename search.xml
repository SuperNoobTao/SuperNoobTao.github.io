<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Eureka+Ribbon+Feign阶段性总结</title>
    <url>/2020/01/23/%5BEureka+Ribbon+Feign%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%5D/</url>
    <content><![CDATA[<h1 id="Eureka-Ribbon-Feign阶段性总结"><a href="#Eureka-Ribbon-Feign阶段性总结" class="headerlink" title="[Eureka+Ribbon+Feign阶段性总结]"></a>[Eureka+Ribbon+Feign阶段性总结]</h1><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三个组件的调用关系：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200113101813661-1058067907.png" alt="Feign_Ribbion_Eureka互相调用过程 1.jpg"></p>
<a id="more"></a>

<p>图片看不清的话可以直接看分享出来的processon地址：</p>
<p><a href="https://www.processon.com/view/link/5e1577a5e4b061a80c6ca89f" target="_blank" rel="noopener">https://www.processon.com/view/link/5e1577a5e4b061a80c6ca89f</a></p>
<p>转载自 ：<a href="https://www.cnblogs.com/wang-meng/p/12147889.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang-meng/p/12147889.html</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign 源码三：Feign结合Ribbon实现负载均衡的原理分析</title>
    <url>/2020/01/22/%5BFeign%20%E6%BA%90%E7%A0%81%E4%B8%89%EF%BC%9AFeign%E7%BB%93%E5%90%88Ribbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%5D/</url>
    <content><![CDATA[<h1 id="Feign-源码三：Feign结合Ribbon实现负载均衡的原理分析"><a href="#Feign-源码三：Feign结合Ribbon实现负载均衡的原理分析" class="headerlink" title="[Feign 源码三：Feign结合Ribbon实现负载均衡的原理分析]"></a>[Feign 源码三：Feign结合Ribbon实现负载均衡的原理分析]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲我们已经知道了Feign的工作原理其实是在项目启动的时候，通过JDK动态代理为每个FeignClinent生成一个动态代理。</p>
<p>动态代理的数据结构是：ReflectiveFeign.FeignInvocationHandler。其中包含<code>target</code>(里面是serviceName等信息)和<code>dispatcher</code>(map数据结构，key是请求的方法名，方法参数等，value是<code>SynchronousMethodHandler</code>)。</p>
<a id="more"></a>

<p>如下图所示：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083259578-1927295338.png" alt="image.png"></p>
<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>这一讲主要是Feign与Ribbon结合实现负载均衡的原理分析。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Feign结合Ribbon实现负载均衡原理"><a href="#Feign结合Ribbon实现负载均衡原理" class="headerlink" title="Feign结合Ribbon实现负载均衡原理"></a>Feign结合Ribbon实现负载均衡原理</h4><p>通过前面的分析，我们可以直接来看下<code>SynchronousMethodHandler</code>中的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class SynchronousMethodHandler implements MethodHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object[] argv) throws Throwable &#123;</span><br><span class="line">        // 生成请求类似于：GET /sayHello/wangmeng HTTP/1.1</span><br><span class="line">        RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">        Retryer retryer = this.retryer.clone();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return executeAndDecode(template);</span><br><span class="line">            &#125; catch (RetryableException e) &#123;</span><br><span class="line">                retryer.continueOrPropagate(e);</span><br><span class="line">                if (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                    logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object executeAndDecode(RequestTemplate template) throws Throwable &#123;</span><br><span class="line">        // 构建request对象：GET http://serviceA/sayHello/wangmeng HTTP/1.1</span><br><span class="line">        Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">        if (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">            logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response;</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这个client就是之前构建的LoadBalancerFeignClient，options是超时时间</span><br><span class="line">            response = client.execute(request, options);</span><br><span class="line">            // ensure the request is set. TODO: remove in Feign 10</span><br><span class="line">            response.toBuilder().request(request).build();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">            &#125;</span><br><span class="line">            throw errorExecuting(request, e);</span><br><span class="line">        &#125;</span><br><span class="line">        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">        // 下面逻辑都是构建返回值response</span><br><span class="line">        boolean shouldClose = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                response =</span><br><span class="line">                        logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);</span><br><span class="line">                // ensure the request is set. TODO: remove in Feign 10</span><br><span class="line">                response.toBuilder().request(request).build();</span><br><span class="line">            &#125;</span><br><span class="line">            if (Response.class == metadata.returnType()) &#123;</span><br><span class="line">                if (response.body() == null) &#123;</span><br><span class="line">                    return response;</span><br><span class="line">                &#125;</span><br><span class="line">                if (response.body().length() == null ||</span><br><span class="line">                        response.body().length() &gt; MAX_RESPONSE_BUFFER_SIZE) &#123;</span><br><span class="line">                    shouldClose = false;</span><br><span class="line">                    return response;</span><br><span class="line">                &#125;</span><br><span class="line">                // Ensure the response body is disconnected</span><br><span class="line">                byte[] bodyData = Util.toByteArray(response.body().asInputStream());</span><br><span class="line">                return response.toBuilder().body(bodyData).build();</span><br><span class="line">            &#125;</span><br><span class="line">            if (response.status() &gt;= 200 &amp;&amp; response.status() &lt; 300) &#123;</span><br><span class="line">                if (void.class == metadata.returnType()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return decode(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (decode404 &amp;&amp; response.status() == 404 &amp;&amp; void.class != metadata.returnType()) &#123;</span><br><span class="line">                return decode(response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">                logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);</span><br><span class="line">            &#125;</span><br><span class="line">            throw errorReading(request, response, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (shouldClose) &#123;</span><br><span class="line">                ensureClosed(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是构建request数据，然后通过request和options去通过<code>LoadBalancerFeignClient.execute()</code>方法去获得返回值。我们可以接着看client端的调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerFeignClient implements Client &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response execute(Request request, Request.Options options) throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // asUri: http://serviceA/sayHello/wangmeng</span><br><span class="line">            URI asUri = URI.create(request.url());</span><br><span class="line"></span><br><span class="line">            // clientName:serviceA</span><br><span class="line">            String clientName = asUri.getHost();</span><br><span class="line"></span><br><span class="line">            // uriWithoutHost: http://sayHello/wangmeng</span><br><span class="line">            URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line"></span><br><span class="line">            // 这里ribbonRequest：GET http:///sayHello/wangmeng HTTP/1.1  </span><br><span class="line">            FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest(</span><br><span class="line">                    this.delegate, request, uriWithoutHost);</span><br><span class="line"></span><br><span class="line">            // 这里面config只有两个超时时间，一个是connectTimeout：5000，一个是readTimeout：5000</span><br><span class="line">            IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line"></span><br><span class="line">            // 真正执行负载均衡的地方</span><br><span class="line">            return lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">                    requestConfig).toResponse();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClientException e) &#123;</span><br><span class="line">            IOException io = findIOException(e);</span><br><span class="line">            if (io != null) &#123;</span><br><span class="line">                throw io;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看下<code>lbClient()</code>和<code>executeWithLoadBalancer()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerFeignClient implements Client &#123;</span><br><span class="line"></span><br><span class="line">    private FeignLoadBalancer lbClient(String clientName) &#123;</span><br><span class="line">        return this.lbClientFactory.create(clientName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CachingSpringLoadBalancerFactory &#123;</span><br><span class="line">    public FeignLoadBalancer create(String clientName) &#123;</span><br><span class="line">        if (this.cache.containsKey(clientName)) &#123;</span><br><span class="line">            return this.cache.get(clientName);</span><br><span class="line">        &#125;</span><br><span class="line">        IClientConfig config = this.factory.getClientConfig(clientName);</span><br><span class="line">        // 获取Ribbon ILoadBalancer信息</span><br><span class="line">        ILoadBalancer lb = this.factory.getLoadBalancer(clientName);</span><br><span class="line">        ServerIntrospector serverIntrospector = this.factory.getInstance(clientName, ServerIntrospector.class);</span><br><span class="line">        FeignLoadBalancer client = enableRetry ? new RetryableFeignLoadBalancer(lb, config, serverIntrospector,</span><br><span class="line">            loadBalancedRetryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory) : new FeignLoadBalancer(lb, config, serverIntrospector);</span><br><span class="line">        this.cache.put(clientName, client);</span><br><span class="line">        return client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是获取了<code>ILoadBalancer</code>数据，里面包含了Ribbon获取的serviceA所有服务节点信息。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083303104-2075322481.png" alt="image.png"></p>
<p>这里已经获取到<code>ILoadBalancer</code>，里面包含serviceA服务器所有节点请求host信息。接下来就是从中负载均衡选择一个节点信息host出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractLoadBalancerAwareClient&lt;S extends ClientRequest, T extends IResponse&gt; extends LoadBalancerContext implements IClient&lt;S, T&gt;, IClientConfigAware &#123;</span><br><span class="line"></span><br><span class="line">    public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException &#123;</span><br><span class="line">        LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            return command.submit(</span><br><span class="line">                new ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                        URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                        S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));</span><br><span class="line">                        &#125; </span><br><span class="line">                        catch (Exception e) &#123;</span><br><span class="line">                            return Observable.error(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .toBlocking()</span><br><span class="line">                .single();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            if (t instanceof ClientException) &#123;</span><br><span class="line">                throw (ClientException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new ClientException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LoadBalancerCommand&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    public Observable&lt;T&gt; submit(final ServerOperation&lt;T&gt; operation) &#123;</span><br><span class="line">        final ExecutionInfoContext context = new ExecutionInfoContext();</span><br><span class="line">        </span><br><span class="line">        if (listenerInvoker != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                listenerInvoker.onExecutionStart();</span><br><span class="line">            &#125; catch (AbortExecutionException e) &#123;</span><br><span class="line">                return Observable.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">        final int maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">        // Use the load balancer</span><br><span class="line">        Observable&lt;T&gt; o = </span><br><span class="line">                (server == null ? selectServer() : Observable.just(server))</span><br><span class="line">                .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        // 省略代码...</span><br><span class="line"></span><br><span class="line">    // selectServer是真正执行负载均衡的逻辑</span><br><span class="line">    private Observable&lt;Server&gt; selectServer() &#123;</span><br><span class="line">        return Observable.create(new OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Subscriber&lt;? super Server&gt; next) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // loadBalancerURI是http:///sayHello/wangmeng， loadBalancerKey为null</span><br><span class="line">                    Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                    next.onNext(server);</span><br><span class="line">                    next.onCompleted();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    next.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LoadBalancerContext implements IClientConfigAware &#123;</span><br><span class="line"></span><br><span class="line">    public Server getServerFromLoadBalancer(@Nullable URI original, @Nullable Object loadBalancerKey) throws ClientException &#123;</span><br><span class="line">        String host = null;</span><br><span class="line">        int port = -1;</span><br><span class="line">        if (original != null) &#123;</span><br><span class="line">            host = original.getHost();</span><br><span class="line">        &#125;</span><br><span class="line">        if (original != null) &#123;</span><br><span class="line">            Pair&lt;String, Integer&gt; schemeAndPort = deriveSchemeAndPortFromPartialUri(original);        </span><br><span class="line">            port = schemeAndPort.second();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取到ILoadBalancer，这里面有IRule的信息及服务节点所有信息</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        if (host == null) &#123;</span><br><span class="line">            // Partial URI or no URI Case</span><br><span class="line">            // well we have to just get the right instances from lb - or we fall back</span><br><span class="line">            if (lb != null)&#123;</span><br><span class="line">                // 这里就执行真正的chooseServer的逻辑了。默认的rule为ZoneAvoidanceZule</span><br><span class="line">                Server svc = lb.chooseServer(loadBalancerKey);</span><br><span class="line">                if (svc == null)&#123;</span><br><span class="line">                    throw new ClientException(ClientException.ErrorType.GENERAL,</span><br><span class="line">                            &quot;Load balancer does not have available server for client: &quot;</span><br><span class="line">                                    + clientName);</span><br><span class="line">                &#125;</span><br><span class="line">                host = svc.getHost();</span><br><span class="line">                if (host == null)&#123;</span><br><span class="line">                    throw new ClientException(ClientException.ErrorType.GENERAL,</span><br><span class="line">                            &quot;Invalid Server for :&quot; + svc);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.debug(&quot;&#123;&#125; using LB returned Server: &#123;&#125; for request &#123;&#125;&quot;, new Object[]&#123;clientName, svc, original&#125;);</span><br><span class="line">                return svc;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 省略代码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码已经很清晰了，这里就是真正的通过ribbon的 <code>rule.chooseServer()</code>负载均衡地选择了一个服务节点调用，debug如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083304636-736012805.png" alt="image.png"></p>
<p>到了这里feign与ribbon的分析也就结束了，返回请求url信息，然后得到response结果：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083306444-1849024119.png" alt="image.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面已经分析了Feign与Ribbon的整合，最终还是落到Ribbon中的ILoadBalancer中，使用最后使用IRule去选择对应的server数据。</p>
<p>下一讲 会画一个很大的图，包含Feign、Ribbon、Eureka关联的图，里面会画出每个组件的细节及依赖关系。也算是学习至今的一个总复习了。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign 源码二：Feign动态代理构造过程</title>
    <url>/2020/01/22/%5BFeign%20%E6%BA%90%E7%A0%81%E4%BA%8C%EF%BC%9AFeign%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%5D/</url>
    <content><![CDATA[<h1 id="Feign-源码二：Feign动态代理构造过程"><a href="#Feign-源码二：Feign动态代理构造过程" class="headerlink" title="[Feign 源码二：Feign动态代理构造过程]"></a>[Feign 源码二：Feign动态代理构造过程]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲主要看了@EnableFeignClients中的registerBeanDefinitions()方法，这里面主要是<br> 将EnableFeignClients注解对应的配置属性注入，将FeignClient注解对应的属性注入。</p>
<p>最后是生成FeignClient对应的bean，注入到Spring 的IOC容器。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p><strong>目录如下：</strong></p>
<ol>
<li>registerFeignClient()回顾</li>
<li>FeignClientFactoryBean.getObject()解析</li>
<li>Feign.builder()及client()构建逻辑</li>
<li>创建Feign动态代理实现细节</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="registerFeignClient-回顾"><a href="#registerFeignClient-回顾" class="headerlink" title="registerFeignClient()回顾"></a>registerFeignClient()回顾</h4><p>回顾下之前的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    String className = annotationMetadata.getClassName();</span><br><span class="line">    BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    validate(attributes);</span><br><span class="line">    definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">    definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">    String name = getName(attributes);</span><br><span class="line">    definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">    definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">    definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">    definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">    definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">    String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">    AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be null</span></span><br><span class="line"></span><br><span class="line">    beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">    String qualifier = getQualifier(attributes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">        alias = qualifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">            <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>registerFeignClient()</code>方法中构造了一个BeanDefinitionBuilder对象，BeanDefinitionBuilder的主要作用就是构建一个AbstractBeanDefinition，AbstractBeanDefinition类最终被构建成一个BeanDefinitionHolder 然后注册到Spring中。</p>
<p>beanDefinition类为FeignClientFactoryBean，故在Spring获取类的时候实际返回的是FeignClientFactoryBean类。</p>
<p><code>FeignClientFactoryBean</code>作为一个实现了FactoryBean的工厂类，那么每次在Spring Context 创建实体类的时候会调用它的<code>getObject()</code>方法。</p>
<h3 id="FeignClientFactoryBean-getObject-解析"><a href="#FeignClientFactoryBean-getObject-解析" class="headerlink" title="FeignClientFactoryBean.getObject()解析"></a>FeignClientFactoryBean.getObject()解析</h3><p>这里直接分析<code>FeignClientFactoryBean.getObject()</code>方法，这里包含着Feign动态代理的原理。</p>
<p>先看下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getObject() throws Exception &#123;</span><br><span class="line">    // 可以类比于ribbon中的SpringClientFactory，每个服务都对应一个独立的spring容器</span><br><span class="line">    FeignContext context = applicationContext.getBean(FeignContext.class);</span><br><span class="line">    // builder中包含contract、logLevel、encoder、decoder、options等信息</span><br><span class="line">    Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">    // 如果@FeignClient注解上没有指定url，说明是要用ribbon的负载均衡</span><br><span class="line">    if (!StringUtils.hasText(this.url)) &#123;</span><br><span class="line">        String url;</span><br><span class="line">        if (!this.name.startsWith(&quot;http&quot;)) &#123;</span><br><span class="line">            url = &quot;http://&quot; + this.name;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            url = this.name;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这里构建的url类似于：http://serviceA</span><br><span class="line">        url += cleanPath();</span><br><span class="line">        return loadBalance(builder, context, new HardCodedTarget&lt;&gt;(this.type,</span><br><span class="line">                this.name, url));</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasText(this.url) &amp;&amp; !this.url.startsWith(&quot;http&quot;)) &#123;</span><br><span class="line">        this.url = &quot;http://&quot; + this.url;</span><br><span class="line">    &#125;</span><br><span class="line">    String url = this.url + cleanPath();</span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    if (client != null) &#123;</span><br><span class="line">        if (client instanceof LoadBalancerFeignClient) &#123;</span><br><span class="line">            // not lod balancing because we have a url,</span><br><span class="line">            // but ribbon is on the classpath, so unwrap</span><br><span class="line">            client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.client(client);</span><br><span class="line">    &#125;</span><br><span class="line">    Targeter targeter = get(context, Targeter.class);</span><br><span class="line">    return targeter.target(this, builder, context, new HardCodedTarget&lt;&gt;(</span><br><span class="line">            this.type, this.name, url));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getInstance(String name, Class&lt;T&gt; type) &#123;</span><br><span class="line">    // getContext是从SpringClientContext中获取，之前讲ribbon源码时讲过</span><br><span class="line">    // 一个serviceName都会有自己的一个SpringClientContext上下文信息</span><br><span class="line">    AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">    if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">            type).length &gt; 0) &#123;</span><br><span class="line">        // 这里是获取到LoadBalancerFeignClient</span><br><span class="line">        return context.getBean(type);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是<code>FeignContext</code> ，我们可以类比下ribbon中的<code>SpringClientFactory</code>, 每个服务的调用，都有一个独立的ILoadBalancer、IRule、IPing等等，每个服务都对应一个独立的spring容器，从那个独立的容器中，可以取出这个服务关联的属于自己的LoadBalancer之类的东西。</p>
<p>如果我们调用一个服务的话，比如ServiceA，那么这个服务就会关联一个spring容器，FeignContext就代表一个独立的容器，关联着自己独立的一些组件，例如Logger组件、Decoder组件、Encoder组件等等。</p>
<p>我们可以看下<code>FeignAutoConfiguration</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(Feign.class)</span><br><span class="line">@EnableConfigurationProperties(&#123;FeignClientProperties.class, FeignHttpClientProperties.class&#125;)</span><br><span class="line">public class FeignAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public FeignContext feignContext() &#123;</span><br><span class="line">        FeignContext context = new FeignContext();</span><br><span class="line">        // configurations是一个Map结构</span><br><span class="line">        context.setConfigurations(this.configurations);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FeignContext extends NamedContextFactory&lt;FeignClientSpecification&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public FeignContext() &#123;</span><br><span class="line">        // FeignClientsConfiguration中会加载Encoder、Decoder、Logger等组件</span><br><span class="line">        super(FeignClientsConfiguration.class, &quot;feign&quot;, &quot;feign.client.name&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以知道FeignContext的结构，里面其实就是封装了一个服务实例（ServiceA）对应的各种组件，其中<code>FeignClientsConfiguration</code>是加载默认的组件信息配置类。</p>
<p>接下来还是回到<code>FeignClientFactoryBean.getObject()</code>中，接着看<code>feign()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Feign.Builder feign(FeignContext context) &#123;</span><br><span class="line">    // 从context中获取到默认Logger组件：Slf4jLogger</span><br><span class="line">    FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);</span><br><span class="line">    Logger logger = loggerFactory.create(this.type);</span><br><span class="line"></span><br><span class="line">    // 从context中找type：Feign.Builder.class 对应的组件信息</span><br><span class="line">    // 然后往builder中放入各种组件信息</span><br><span class="line">    Feign.Builder builder = get(context, Feign.Builder.class)</span><br><span class="line">            // required values</span><br><span class="line">            .logger(logger)</span><br><span class="line">            .encoder(get(context, Encoder.class))</span><br><span class="line">            .decoder(get(context, Decoder.class))</span><br><span class="line">            .contract(get(context, Contract.class));</span><br><span class="line">    // @formatter:on</span><br><span class="line"></span><br><span class="line">    configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line">    return builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected &lt;T&gt; T get(FeignContext context, Class&lt;T&gt; type) &#123;</span><br><span class="line">    // context中转载的有Logger组件信息，这里默认的是Slf4jLogger</span><br><span class="line">    T instance = context.getInstance(this.name, type);</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;No bean found of type &quot; + type + &quot; for &quot;</span><br><span class="line">                + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是构造一个Feign.builder()对象，里面还是封装了各种组件信息。其中Feign.builder在<code>FeignClientsConfiguration</code>被初始化，一般使用的是<code>HystrixFeign.builder()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignClientsConfiguration &#123;</span><br><span class="line">    // 一般环境都会配置feign.hystrix.enabled = true，这里直接看HystrixFeign.builder();</span><br><span class="line">    @Configuration</span><br><span class="line">    @ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span><br><span class="line">    protected static class HystrixFeignConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        @Scope(&quot;prototype&quot;)</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        @ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;, matchIfMissing = false)</span><br><span class="line">        public Feign.Builder feignHystrixBuilder() &#123;</span><br><span class="line">            return HystrixFeign.builder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看<code>configureFeign()</code> 方法，这个方法是读取application.properties中的配置信息。这里有个很有趣的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);</span><br><span class="line">configureUsingProperties(properties.getConfig().get(this.name), builder);</span><br></pre></td></tr></table></figure>

<p>如果我们配置feign，先指定一个全局配置，在指定针对于某个服务的配置，那么某个服务配置的优先级会覆盖全局的配置。</p>
<p>一张图总结下Feign.builder()构建的过程：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200111143408683-173345783.png" alt="02_Feign动态代理构建过程_1_-Feign.builder__构建.jpg"></p>
<h4 id="Feign-builder-及client-构建逻辑"><a href="#Feign-builder-及client-构建逻辑" class="headerlink" title="Feign.builder()及client()构建逻辑"></a>Feign.builder()及client()构建逻辑</h4><p>还是接着上面<code>getObject()</code> 方法去分析，上面分析完了<code>Feign.builder()</code>的构建，下面接着看看剩下的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadBalance(builder, context, new HardCodedTarget&lt;&gt;(this.type,this.name, url));</span><br></pre></td></tr></table></figure>

<p>这里形式构造了一个<code>HardCodeTarget</code>对象，这个对象包含了接口类型（com.barrywang.service.feign.ServiceAFeignClient）、服务名称（ServiceA）、url地址（<a href="http://ServiceA），跟Feign.Builder、FeignContext，一起，传入了loadBalance()方法里去。" target="_blank" rel="noopener">http://ServiceA），跟Feign.Builder、FeignContext，一起，传入了loadBalance()方法里去。</a></p>
<p>接着查看<code>loadBalance()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,</span><br><span class="line">            HardCodedTarget&lt;T&gt; target) &#123;</span><br><span class="line">    // 这里还是从context中获取feignClient数据</span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    if (client != null) &#123;</span><br><span class="line">        builder.client(client);</span><br><span class="line">        Targeter targeter = get(context, Targeter.class);</span><br><span class="line">        return targeter.target(this, builder, context, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new IllegalStateException(</span><br><span class="line">            &quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected &lt;T&gt; T getOptional(FeignContext context, Class&lt;T&gt; type) &#123;</span><br><span class="line">    return context.getInstance(this.name, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是从context中获取<code>Client.class</code>对应的数据，我们继续查看<code>FeignAutoConfiguration</code> 类，但是并没有发现Feign.client相关的数据，查看<code>FeignAutoConfiguration</code>的依赖，可以找到<code>FeignRibbonClientAutoConfiguration</code> ，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">@EnableConfigurationProperties(&#123; FeignHttpClientProperties.class &#125;)</span><br><span class="line">// 这里会import三个FeignLoadBalance配置</span><br><span class="line">@Import(&#123; HttpClientFeignLoadBalancedConfiguration.class,</span><br><span class="line">        OkHttpFeignLoadBalancedConfiguration.class,</span><br><span class="line">        DefaultFeignLoadBalancedConfiguration.class &#125;)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span><br><span class="line">    public CachingSpringLoadBalancerFactory cachingLBClientFactory(</span><br><span class="line">            SpringClientFactory factory) &#123;</span><br><span class="line">        return new CachingSpringLoadBalancerFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    @ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;)</span><br><span class="line">    public CachingSpringLoadBalancerFactory retryabeCachingLBClientFactory(</span><br><span class="line">        SpringClientFactory factory,</span><br><span class="line">        LoadBalancedRetryPolicyFactory retryPolicyFactory,</span><br><span class="line">        LoadBalancedBackOffPolicyFactory loadBalancedBackOffPolicyFactory,</span><br><span class="line">        LoadBalancedRetryListenerFactory loadBalancedRetryListenerFactory) &#123;</span><br><span class="line">        return new CachingSpringLoadBalancerFactory(factory, retryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Options是超时相关的配置</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public Request.Options feignRequestOptions() &#123;</span><br><span class="line">        return LoadBalancerFeignClient.DEFAULT_OPTIONS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">class DefaultFeignLoadBalancedConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">                              SpringClientFactory clientFactory) &#123;</span><br><span class="line">        return new LoadBalancerFeignClient(new Client.Default(null, null),</span><br><span class="line">                cachingFactory, clientFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里就知道了，这里Feign.client默认应该就是<code>LoadBalancerFeignClient</code>了。</p>
<p>到这继续用一张图总结下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200111143411939-293645963.png" alt="03_Feign动态代理构建过程_2_-Feign.client__构建.jpg"></p>
<h4 id="创建Feign动态代理实现细节"><a href="#创建Feign动态代理实现细节" class="headerlink" title="创建Feign动态代理实现细节"></a>创建Feign动态代理实现细节</h4><p>接着上面代码，默认Feign.client()为<code>LoadBalancerFeignClient</code>, 然后将client加入到builder中。接着继续跟进<code>targer</code>相关：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,</span><br><span class="line">        HardCodedTarget&lt;T&gt; target) &#123;</span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    if (client != null) &#123;</span><br><span class="line">        builder.client(client);</span><br><span class="line">        // 这里又是通过Targer然后再context中获取默认配置</span><br><span class="line">        Targeter targeter = get(context, Targeter.class);</span><br><span class="line">        return targeter.target(this, builder, context, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new IllegalStateException(</span><br><span class="line">            &quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected &lt;T&gt; T get(FeignContext context, Class&lt;T&gt; type) &#123;</span><br><span class="line">    T instance = context.getInstance(this.name, type);</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;No bean found of type &quot; + type + &quot; for &quot;</span><br><span class="line">                + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里又是通过<code>Targeter.class</code>从context中获取对应默认Targter。我们继续通过<code>FeignAutoConfiguration</code>中进行查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(Feign.class)</span><br><span class="line">@EnableConfigurationProperties(&#123;FeignClientProperties.class, FeignHttpClientProperties.class&#125;)</span><br><span class="line">public class FeignAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private List&lt;FeignClientSpecification&gt; configurations = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FeignContext feignContext() &#123;</span><br><span class="line">        FeignContext context = new FeignContext();</span><br><span class="line">        context.setConfigurations(this.configurations);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果配置了feign.hystrix.HystrixFeign 则创建HystrixTargeter</span><br><span class="line">    @Configuration</span><br><span class="line">    @ConditionalOnClass(name = &quot;feign.hystrix.HystrixFeign&quot;)</span><br><span class="line">    protected static class HystrixFeignTargeterConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        public Targeter feignTargeter() &#123;</span><br><span class="line">            return new HystrixTargeter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有配置feign.hystrix.HystrixFeign 则创建DefaultTargeter</span><br><span class="line">    @Configuration</span><br><span class="line">    @ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;)</span><br><span class="line">    protected static class DefaultFeignTargeterConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        public Targeter feignTargeter() &#123;</span><br><span class="line">            return new DefaultTargeter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，feign是和hystrix整合的，<code>feign.hystrix.HystrixFeign</code>会有配置，所以这里默认Targeter使用的是<code>HystrixTargeter</code>, 在<code>loadBalance()</code>方法中执行的targeter.target()方法就是执行<code>HystrixTargeter.target()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HystrixTargeter implements Targeter &#123;</span><br><span class="line">    public &lt;T&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,</span><br><span class="line">                        Target.HardCodedTarget&lt;T&gt; target) &#123;</span><br><span class="line">    // 判断Feign.builder()类型</span><br><span class="line">    if (!(feign instanceof feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">        return feign.target(target);</span><br><span class="line">    &#125;</span><br><span class="line">    feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;</span><br><span class="line">    SetterFactory setterFactory = getOptional(factory.getName(), context,</span><br><span class="line">        SetterFactory.class);</span><br><span class="line">    if (setterFactory != null) &#123;</span><br><span class="line">        builder.setterFactory(setterFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; fallback = factory.getFallback();</span><br><span class="line">    if (fallback != void.class) &#123;</span><br><span class="line">        return targetWithFallback(factory.getName(), context, target, builder, fallback);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; fallbackFactory = factory.getFallbackFactory();</span><br><span class="line">    if (fallbackFactory != void.class) &#123;</span><br><span class="line">        return targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最终都会执行feign.target()方法</span><br><span class="line">    return feign.target(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract class Feign &#123;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Returns a new instance of an HTTP API, defined by annotations in the &#123;@link Feign Contract&#125;,</span><br><span class="line">   * for the specified &#123;@code target&#125;. You should cache this result.</span><br><span class="line">   */</span><br><span class="line">  public abstract &lt;T&gt; T newInstance(Target&lt;T&gt; target);</span><br><span class="line"></span><br><span class="line">  public static class Builder &#123;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T target(Target&lt;T&gt; target) &#123;</span><br><span class="line">      return build().newInstance(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Feign build() &#123;</span><br><span class="line">      // 构建一个SynchronousMethodHandler工厂</span><br><span class="line">      SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">          new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                               logLevel, decode404);</span><br><span class="line"></span><br><span class="line">      // 构建</span><br><span class="line">      ParseHandlersByName handlersByName =</span><br><span class="line">          new ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                                  errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">      return new ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是build方法，构造了一个<code>ReflectieFein</code>对象，接着看它里面的<code>newInstance()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T newInstance(Target&lt;T&gt; target) &#123;</span><br><span class="line">    // nameToHandler是@FeignClient中的方法名对应的MethodHandler对象</span><br><span class="line">    Map&lt;String, InvocationHandlerFactory.MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">    Map&lt;Method, InvocationHandlerFactory.MethodHandler&gt; methodToHandler = new LinkedHashMap&lt;Method, InvocationHandlerFactory.MethodHandler&gt;();</span><br><span class="line">    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = new LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">    for (Method method : target.type().getMethods()) &#123;</span><br><span class="line">        if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125; else if (Util.isDefault(method)) &#123;</span><br><span class="line">            DefaultMethodHandler handler = new DefaultMethodHandler(method);</span><br><span class="line">            defaultMethodHandlers.add(handler);</span><br><span class="line">            methodToHandler.put(method, handler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 将具体的method作为map的key值</span><br><span class="line">            methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // JDK动态代理 返回类似于：ReflectiveFeign$FeignInvocationHandler@7642</span><br><span class="line">    // methodToHandler中包含Feign.builder()、Feign.client()等信息</span><br><span class="line">    InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">    T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">    for (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">        defaultMethodHandler.bindTo(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用了JDK动态代理，实际上返回的Feign动态代理的对象类似于：<code>ReflectiveFeign$FeignInvocationHandler@7642</code>。</p>
<p>这也和我们第一讲中的debug截图一致了，到了这里feign动态代理对象的生成原理都已经很清楚了。</p>
<p>最后debug一下，看下最终生成的动态代理对象：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200111143414886-1806884325.png" alt="image.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后用一张图总结Feign动态代理生成的规则：</p>
<ol>
<li>生成Feign.builder(),里面包含Encoder、Decoder、Logger等组件，还有application.properties中相关的feign client配置信息</li>
<li>生成Feign.client()，默认为LoadBalancerFeignClient</li>
<li>生成默认Targter对象：HystrixTargter</li>
<li>builder、client、targter 通过JDK动态代理生成feign动态代理对象</li>
</ol>
<p>一张图总结：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200111143419411-331369408.png" alt="04_Feign动态代理构建过程_3_-基于JDK动态代理生成原理.jpg"></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign 源码一：源码初探，通过Demo Debug Feign源码</title>
    <url>/2020/01/21/%5BFeign%20%E6%BA%90%E7%A0%81%E4%B8%80%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2%EF%BC%8C%E9%80%9A%E8%BF%87Demo%20Debug%20Feign%E6%BA%90%E7%A0%81%5D/</url>
    <content><![CDATA[<h1 id="Feign-源码一：源码初探，通过Demo-Debug-Feign源码"><a href="#Feign-源码一：源码初探，通过Demo-Debug-Feign源码" class="headerlink" title="[Feign 源码一：源码初探，通过Demo Debug Feign源码]"></a>[Feign 源码一：源码初探，通过Demo Debug Feign源码]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲深入的讲解了Ribbon的初始化过程及Ribbon与Eureka的整合代码，与Eureka整合的类就是<code>DiscoveryEnableNIWSServerList</code>，同时在<code>DynamicServerListLoadBalancer</code>中会调用<code>PollingServerListUpdater</code> 进行定时更新Eureka注册表信息到<code>BaseLoadBalancer</code>中，默认30s调度一次。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>这一讲主要是讲Fegin Demo以及通过入口注解@EnableFeignCliets和@FeignClient来进行源码初探。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>Feign代码Demo</li>
<li>Feign调用原理</li>
<li>@EnableEurekaClient和@FeignClient注解扫描</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Feign代码Demo"><a href="#Feign代码Demo" class="headerlink" title="Feign代码Demo"></a>Feign代码Demo</h4><p>Fegin的Demo还是延续之前讲解的Eureka的代码。地址为：<br><a href="https://github.com/barrywangmeng/spring-cloud-learn" target="_blank" rel="noopener">https://github.com/barrywangmeng/spring-cloud-learn</a></p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200110103634690-293700167.png" alt="调用图片"><br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200110103635840-22709238.png" alt="image.png"></p>
<p>如上图所示，ServiceB调用ServiceA的服务，定义了一个@FeignClient标注的ServiceAFeignClient接口，里面定义了ServiceA中Controller提供的接口信息。</p>
<h3 id="Feign调用原理"><a href="#Feign调用原理" class="headerlink" title="Feign调用原理"></a>Feign调用原理</h3><p>接着我们可以启动所有服务，调用ServiceBController，然后在serviceAFeignClient处打上断点看一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200110103636390-1362332959.png" alt="image.png"></p>
<p>我们发现这里serviceAFeignClient显示的是：<code>ReflectiveFeign$FeignInvocationHandler@7642</code> ，这里其实是使用了动态代理，因为<code>ServiceAFeignClient</code> 是一个接口，所以这里可以猜测到底层使用的是JDK动态代理。</p>
<p>接着可以简单地梳理下Feign请求简单原理图：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200110103637002-1539671852.png" alt="00_Feign请求原理图.jpg"></p>
<h4 id="EnableEurekaClient和-FeignClient注解扫描"><a href="#EnableEurekaClient和-FeignClient注解扫描" class="headerlink" title="@EnableEurekaClient和@FeignClient注解扫描"></a>@EnableEurekaClient和@FeignClient注解扫描</h4><p>先看下@EnableFeignClients注解代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableFeignClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等价于basePackages属性，更简洁的方式</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//指定多个包名进行扫描</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定多个类或接口的class,扫描时会在这些指定的类和接口所属的包进行扫描</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//为所有的Feign Client设置默认配置类</span></span><br><span class="line">    Class&lt;?&gt;[] defaultConfiguration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//指定用@FeignClient注释的类列表。如果该项配置不为空，则不会进行类路径扫描</span></span><br><span class="line">    Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看下@FeignClient注解代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FeignClient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定Feign Client的名称，如果项目使用了 Ribbon，name属性会作为微服务的名称，用于服务发现</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//用serviceId做服务发现已经被废弃，所以不推荐使用该配置</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">String <span class="title">serviceId</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//指定Feign Client的serviceId，如果项目使用了 Ribbon，将使用serviceId用于服务发现,但上面可以看到serviceId做服务发现已经被废弃，所以也不推荐使用该配置</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//为Feign Client 新增注解@Qualifier</span></span><br><span class="line">    <span class="function">String <span class="title">qualifier</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//请求地址的绝对URL，或者解析的主机名</span></span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//调用该feign client发生了常见的404错误时，是否调用decoder进行解码异常信息返回,否则抛出FeignException</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">decode404</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">     <span class="comment">//Feign Client设置默认配置类</span></span><br><span class="line">    Class&lt;?&gt;[] configuration() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑,fallback 指定的类必须实现@FeignClient标记的接口。实现的法方法即对应接口的容错处理逻辑</span></span><br><span class="line">    Class&lt;?&gt; fallback() <span class="keyword">default</span> <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="comment">//工厂类，用于生成fallback 类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码</span></span><br><span class="line">    Class&lt;?&gt; fallbackFactory() <span class="keyword">default</span> <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="comment">//定义当前FeignClient的所有方法映射加统一前缀</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//是否将此Feign代理标记为一个Primary Bean，默认为ture</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primary</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看下@EnableFeignClients中注入的<br> @Import(FeignClientsRegistrar.class) 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// patterned after Spring Integration IntegrationComponentScanRegistrar</span></span><br><span class="line">    <span class="comment">// and RibbonClientsConfigurationRegistgrar</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeignClientsRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在这个重载的方法里面做了两件事情：</span></span><br><span class="line">   <span class="comment">//1.将EnableFeignClients注解对应的配置属性注入</span></span><br><span class="line">   <span class="comment">//2.将FeignClient注解对应的属性注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注入EnableFeignClients注解对应的配置属性</span></span><br><span class="line">        registerDefaultConfiguration(metadata, registry);</span><br><span class="line">       <span class="comment">//注入FeignClient注解对应的属性</span></span><br><span class="line">        registerFeignClients(metadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拿到 EnableFeignClients注解 defaultConfiguration 字段的值</span></span><br><span class="line"><span class="comment">   * 然后进行注入</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDefaultConfiguration</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">                .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">            String name;</span><br><span class="line">            <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">                name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">            &#125;</span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                    defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取ClassPath扫描器</span></span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">        <span class="comment">// 为扫描器设置资源加载器</span></span><br><span class="line">        scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; basePackages;</span><br><span class="line">        <span class="comment">// 1. 从@EnableFeignClients注解中获取到配置的各个属性值</span></span><br><span class="line">        <span class="comment">// 这里可以获取到配置的：basePackages=com.barrywang.service.feign</span></span><br><span class="line">        Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">                .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">// 2. 注解类型过滤器，只过滤@FeignClient   </span></span><br><span class="line">        AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">                FeignClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 3. 从1. 中的属性值中获取clients属性的值        </span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">                : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">        <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 扫描器设置过滤器且获取需要扫描的基础包集合</span></span><br><span class="line">            scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">            basePackages = getBasePackages(metadata);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// clients属性值不为null，则将其clazz路径转为包路径</span></span><br><span class="line">            <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">                basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">                clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">            AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">                    String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line">                    <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            scanner.addIncludeFilter(</span><br><span class="line">                    <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 扫描基础包，且满足过滤条件下的接口封装成BeanDefinition</span></span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            <span class="comment">// 找到basePackage下定义的@FeignClient接口列表</span></span><br><span class="line">            Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">                    .findCandidateComponents(basePackage);</span><br><span class="line">            <span class="comment">// 遍历扫描到的bean定义        </span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// 并校验扫描到的bean定义类是一个接口</span></span><br><span class="line">                    AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                            <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取@FeignClient注解上的各个属性值</span></span><br><span class="line">                    Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                            .getAnnotationAttributes(</span><br><span class="line">                                    FeignClient<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line"></span><br><span class="line">                    String name = getClientName(attributes);</span><br><span class="line">                    <span class="comment">// 可以看到这里也注册了一个FeignClient的配置bean</span></span><br><span class="line">                    <span class="comment">// 这个方法是创建了一个FeignClientFactoryBean的工厂类，里面保存@FeignClient注解的所有属性值</span></span><br><span class="line">                    registerClientConfiguration(registry, name,</span><br><span class="line">                            attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line">                    <span class="comment">// 注册bean定义到spring中</span></span><br><span class="line">                    registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册bean</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">       AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取类名称，也就是本例中的FeignService接口</span></span><br><span class="line">        String className = annotationMetadata.getClassName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.BeanDefinitionBuilder的主要作用就是构建一个AbstractBeanDefinition</span></span><br><span class="line">        <span class="comment">// AbstractBeanDefinition类最终被构建成一个BeanDefinitionHolder</span></span><br><span class="line">        <span class="comment">// 然后注册到Spring中</span></span><br><span class="line">        <span class="comment">// 注意：beanDefinition类为FeignClientFactoryBean，故在Spring获取类的时候实际返回的是</span></span><br><span class="line">        <span class="comment">// FeignClientFactoryBean类</span></span><br><span class="line">        BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">            .genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        validate(attributes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.添加FeignClientFactoryBean的属性，</span></span><br><span class="line">        <span class="comment">// 这些属性也都是我们在@FeignClient中定义的属性</span></span><br><span class="line">        definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">        definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">        String name = getName(attributes);</span><br><span class="line">        definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">        definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">        definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">        definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">        definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置别名 name就是我们在@FeignClient中定义的name属性</span></span><br><span class="line">        String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be null</span></span><br><span class="line"></span><br><span class="line">        beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">        String qualifier = getQualifier(attributes);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">            alias = qualifier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.定义BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className, <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        AnnotationAttributes annotation = AnnotationAttributes.fromMap(attributes);</span><br><span class="line">        <span class="comment">// This blows up if an aliased property is overspecified</span></span><br><span class="line">        <span class="comment">// FIXME annotation.getAliasedString("name", FeignClient.class, null);</span></span><br><span class="line">        Assert.isTrue(</span><br><span class="line">            !annotation.getClass(<span class="string">"fallback"</span>).isInterface(),</span><br><span class="line">            <span class="string">"Fallback class must implement the interface annotated by @FeignClient"</span></span><br><span class="line">        );</span><br><span class="line">        Assert.isTrue(</span><br><span class="line">            !annotation.getClass(<span class="string">"fallbackFactory"</span>).isInterface(),</span><br><span class="line">            <span class="string">"Fallback factory must produce instances of fallback classes that implement the interface annotated by @FeignClient"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, Object name,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object configuration)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个使用FeignClientSpecification构建的BeanDefinitionBuilder的类</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(FeignClientSpecification<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        builder.addConstructorArgValue(name);</span><br><span class="line">        builder.addConstructorArgValue(configuration);</span><br><span class="line">        registry.registerBeanDefinition(</span><br><span class="line">                name + <span class="string">"."</span> + FeignClientSpecification<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>(),</span></span><br><span class="line"><span class="class">                <span class="title">builder</span>.<span class="title">getBeanDefinition</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   ......</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里做了两件事情：</p>
<ol>
<li>将EnableFeignClients注解对应的配置属性注入；</li>
<li>将FeignClient注解对应的属性注入。</li>
</ol>
<p>生成FeignClient对应的bean，注入到Spring 的IOC容器。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在我们查看处理@EnableFeignClients和@FeignClient注解的地方，最后调用<code>registerFeignClient()</code> 会构造一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们后续会重点查看<code>FeignClientFactoryBean</code> 这个类。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon源码五：Ribbon源码解读汇总篇</title>
    <url>/2020/01/20/%5BRibbon%E6%BA%90%E7%A0%81%E4%BA%94%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%B1%87%E6%80%BB%E7%AF%87~%5D/</url>
    <content><![CDATA[<h1 id="Ribbon源码五：Ribbon源码解读汇总篇"><a href="#Ribbon源码五：Ribbon源码解读汇总篇" class="headerlink" title="[Ribbon源码五：Ribbon源码解读汇总篇~]"></a>[Ribbon源码五：Ribbon源码解读汇总篇~]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h4><p>Ribbon比较小巧，这里是直接 读的spring cloud 内嵌封装的版本，里面的各种configuration确实有点绕，不过看看第三讲Ribbon初始化的过程总结图就会清晰很多。</p>
<p>紧接着会继续整理学习Feign源码相关的，敬请期待。</p>
<a id="more"></a>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结分为两个部分，一个是Riboon执行整体流程图，还一个是Ribbon初始化流程图。</p>
<p>Ribbon整体流程图：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200109141619258-1289351388.png" alt="08_Ribbon整体流程图.jpg"></p>
<p>Ribbon初始化流程图：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200109141622230-1896405065.png" alt="02_Ribbon初始化流程图.jpg"></p>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p>常用配置</p>
<ol>
<li><p>禁用 Eureka<br> 当我们在 RestTemplate 上添加 @LoadBalanced 注解后，就可以用服务名称来调用接口了，当有多个服务的时候，还能做负载均衡。</p>
<p>这是因为 Eureka 中的服务信息已经被拉取到了客户端本地，如果我们不想和 Eureka 集成，可以通过下面的配置方法将其禁用。<br> <code>xml  #禁用 Eureka  ribbon.eureka.enabled=false</code></p>
<p>当我们禁用了 Eureka 之后，就不能使用服务名称去调用接口了，必须指定服务地址。</p>
</li>
<li><p>配置接口地址列表<br> 上面我们讲了可以禁用 Eureka，禁用之后就需要手动配置调用的服务地址了，配置如下：<br> <code>xml  #禁用 Eureka 后手动配置服务地址  ribbon-config-demo.ribbon.listOfServers=localhost:8081,localhost:8083</code></p>
<p>这个配置是针对具体服务的，前缀就是服务名称，配置完之后就可以和之前一样使用服务名称来调用接口了。</p>
</li>
<li><p>配置负载均衡策略<br> Ribbon 默认的策略是轮询，从我们前面讲解的例子输出的结果就可以看出来，Ribbon 中提供了很多的策略，这个在后面会进行讲解。我们通过配置可以指定服务使用哪种策略来进行负载操作。</p>
</li>
<li><p>超时时间<br> Ribbon 中有两种和时间相关的设置，分别是请求连接的超时时间和请求处理的超时时间，设置规则如下：<br> <code>xml  # 请求连接的超时时间  ribbon.ConnectTimeout=2000  # 请求处理的超时时间  ribbon.ReadTimeout=5000</code></p>
<p>也可以为每个Ribbon客户端设置不同的超时时间, 通过服务名称进行指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml  ribbon-config-demo.ribbon.ConnectTimeout=2000  ribbon-config-demo.ribbon.ReadTimeout=5000</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发参数<br> <code>xml  #最大连接数  ribbon.MaxTotalConnections=500  #每个host最大连接数  ribbon.MaxConnectionsPerHost=500</code></p>
</li>
<li><p>重试和负载均衡相关配置<br> ```xml<br> # 对当前实例的重试次数<br> ribbon.maxAutoRetries=1<br> # 切换实例的重试次数<br> ribbon.maxAutoRetriesNextServer=3<br> # 对所有操作请求都进行重试<br> ribbon.okToRetryOnAllOperations=true<br> # 对Http响应码进行重试<br> ribbon.retryableStatusCodes=500,404,502</p>
<p># 负载Rule选择<br> ribbon-config-demo.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.BestAvailableRule<br> ```</p>
</li>
</ol>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon 源码四：进一步探究Ribbon的IRule和IPing</title>
    <url>/2020/01/19/%5BRibbon%20%E6%BA%90%E7%A0%81%E5%9B%9B%EF%BC%9A%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8E%A2%E7%A9%B6Ribbon%E7%9A%84IRule%E5%92%8CIPing%5D/</url>
    <content><![CDATA[<h1 id="Ribbon-源码四：进一步探究Ribbon的IRule和IPing"><a href="#Ribbon-源码四：进一步探究Ribbon的IRule和IPing" class="headerlink" title="[Ribbon 源码四：进一步探究Ribbon的IRule和IPing]"></a>[Ribbon 源码四：进一步探究Ribbon的IRule和IPing]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲深入的讲解了Ribbon的初始化过程及Ribbon与Eureka的整合代码，与Eureka整合的类就是<code>DiscoveryEnableNIWSServerList</code>，同时在<code>DynamicServerListLoadBalancer</code>中会调用<code>PollingServerListUpdater</code> 进行定时更新Eureka注册表信息到<code>BaseLoadBalancer</code>中，默认30s调度一次。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>我们知道Ribbon主要是由3个组件组成的：</p>
<ol>
<li>ILoadBalancer</li>
<li>IRule</li>
<li>IPing</li>
</ol>
<p>其中<code>ILoadBalancer</code>前面我们已经分析过了，接下来我们一起看看<code>IRule</code>和<code>IPing</code>中的具体实现。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>负载均衡默认Server选择逻辑</li>
<li>Ribbon实际执行http请求逻辑</li>
<li>Ribbon中ping机制原理</li>
<li>Ribbon中其他IRule负载算法初探</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="负载均衡默认Server选择逻辑"><a href="#负载均衡默认Server选择逻辑" class="headerlink" title="负载均衡默认Server选择逻辑"></a>负载均衡默认Server选择逻辑</h4><p>还记得我们上一讲说过，在Ribbon初始化过程中，默认的<code>IRule</code>为<code>ZoneAvoidanceRule</code>，这里我们可以通过debug看看，从<code>RibbonLoadBalancerClient.getServer()</code> 一路往下跟，这里直接看debug结果：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133933694-1375783725.png" alt="image.png"></p>
<p>然后我们继续跟<code>ZoneAvoidanceRule.choose()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class PredicateBasedRule extends ClientConfigEnabledRoundRobinRule &#123;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">     * Method that provides an instance of &#123;@link AbstractServerPredicate&#125; to be used by this class.</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public abstract AbstractServerPredicate getPredicate();</span><br><span class="line">        </span><br><span class="line">    /**</span><br><span class="line">     * Get a server by calling &#123;@link AbstractServerPredicate#chooseRandomlyAfterFiltering(java.util.List, Object)&#125;.</span><br><span class="line">     * The performance for this method is O(n) where n is number of servers to be filtered.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">        if (server.isPresent()) &#123;</span><br><span class="line">            return server.get();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是调用的<code>ZoneAvoidanceRule</code>的父类中的<code>choose()</code>方法，首先是拿到对应的<code>ILoadBalancer</code>,然后拿到对应的serverList数据，接着调用<code>chooseRoundRobinAfterFiltering()</code>方法，继续往后跟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractServerPredicate implements Predicate&lt;PredicateKey&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Optional&lt;Server&gt; chooseRoundRobinAfterFiltering(List&lt;Server&gt; servers, Object loadBalancerKey) &#123;</span><br><span class="line">        List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">        if (eligible.size() == 0) &#123;</span><br><span class="line">            return Optional.absent();</span><br><span class="line">        &#125;</span><br><span class="line">        return Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int incrementAndGetModulo(int modulo) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = nextIndex.get();</span><br><span class="line">            int next = (current + 1) % modulo;</span><br><span class="line">            if (nextIndex.compareAndSet(current, next) &amp;&amp; current &lt; modulo)</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里可以看到<code>incrementAndGetModulo()</code>方法就是处理serverList轮询的算法，这个和<code>RoudRobinRule</code>中采用的是一样的算法，这个算法大家可以品一品，我这里也会画个图来说明下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133935714-603689733.png" alt="06_Ribbon轮询算法图解.jpg"></p>
<p>看了图=中的例子估计大家都会明白了，这个算法就是依次轮询。这个算法写的很精简。</p>
<h4 id="Ribbon实际执行http请求逻辑"><a href="#Ribbon实际执行http请求逻辑" class="headerlink" title="Ribbon实际执行http请求逻辑"></a>Ribbon实际执行http请求逻辑</h4><p>我们上面知道，我们按照轮询的方式从serverList取到一个server后，那么怎么把之前原有的类似于：<code>http://ServerA/sayHello/wangmeng</code>中的ServerA给替换成请求的ip数据呢？</p>
<p>接着我们继续看<code>RibbonLoadBalancerClient.execute()</code>方法，这个里面<code>request.apply()</code>会做一个serverName的替换逻辑。</p>
<p>最后可以一步步跟到<code>RibbonLoadBalancerClient.reconstructURI()</code>，这个方法是把请求自带的getURI方法给替换了，我们最后查看<code>context.reconstructURIWithServer()</code> 方法，debug结果如图，这个里面会一步步把对应的请求url给拼接起来：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133940333-1790437062.png" alt="image.png"></p>
<h4 id="Ribbon中ping机制原理"><a href="#Ribbon中ping机制原理" class="headerlink" title="Ribbon中ping机制原理"></a>Ribbon中ping机制原理</h4><p>我们知道 Ribbon还有一个重要的组件就是ping机制，通过上一讲Ribbon的初始化我们知道，默认的IPing实现类为：<code>NIWSDiscoveryPing</code>，我们可以查看其中的<code>isAlive()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NIWSDiscoveryPing extends AbstractLoadBalancerPing &#123;</span><br><span class="line">            </span><br><span class="line">        BaseLoadBalancer lb = null; </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        public NIWSDiscoveryPing() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public BaseLoadBalancer getLb() &#123;</span><br><span class="line">            return lb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Non IPing interface method - only set this if you care about the &quot;newServers Feature&quot;</span><br><span class="line">         * @param lb</span><br><span class="line">         */</span><br><span class="line">        public void setLb(BaseLoadBalancer lb) &#123;</span><br><span class="line">            this.lb = lb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isAlive(Server server) &#123;</span><br><span class="line">            boolean isAlive = true;</span><br><span class="line">            if (server!=null &amp;&amp; server instanceof DiscoveryEnabledServer)&#123;</span><br><span class="line">                DiscoveryEnabledServer dServer = (DiscoveryEnabledServer)server;                </span><br><span class="line">                InstanceInfo instanceInfo = dServer.getInstanceInfo();</span><br><span class="line">                if (instanceInfo!=null)&#123;                    </span><br><span class="line">                    InstanceStatus status = instanceInfo.getStatus();</span><br><span class="line">                    if (status!=null)&#123;</span><br><span class="line">                        isAlive = status.equals(InstanceStatus.UP);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return isAlive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void initWithNiwsConfig(</span><br><span class="line">                IClientConfig clientConfig) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是获取到<code>DiscoveryEnabledServer</code>对应的注册信息是否为<code>UP</code>状态。那么 既然有个ping的方法，肯定会有方法进行调度的。</p>
<p>我们可以查看<code>isAlive()</code>调用即可以找到调度的地方。<br> 在<code>BaseLoadBalancer</code>构造函数中会调用<code>setupPingTask()</code>方法，进行调度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int pingIntervalSeconds = 10;</span><br><span class="line"></span><br><span class="line">void setupPingTask() &#123;</span><br><span class="line">    if (canSkipPing()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (lbTimer != null) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = new ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name,</span><br><span class="line">            true);</span><br><span class="line">    lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>pingIntervalSeconds</code>在<code>BaseLoadBalancer</code>中定义的是10s，但是在<code>initWithConfig()</code>方法中，通过传入的时间覆盖了原本的10s，这里实际的默认时间是30s。如下代码：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133943619-1942268787.png" alt="image.png"></p>
<p>我们也可以通过debug来看看：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133949075-879722129.png" alt="image.png"></p>
<p>可能大家好奇为什么要单独截图来说这个事，其实是因为网上好多博客讲解都是错的，都写的是ping默认调度时间为10s，想必他们都是没有真正debug过吧。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133951750-84881497.png" alt="image.png"></p>
<p>还是那句话，源码出真知。</p>
<h4 id="Ribbon中其他IRule负载算法初探"><a href="#Ribbon中其他IRule负载算法初探" class="headerlink" title="Ribbon中其他IRule负载算法初探"></a>Ribbon中其他IRule负载算法初探</h4><ol>
<li><p>RoundRobinRule：系统内置的默认负载均衡规范，直接round robin轮询，从一堆server list中，不断的轮询选择出来一个server，每个server平摊到的这个请求，基本上是平均的</p>
<p>这个算法，说白了是轮询，就是一台接着一台去请求，是按照顺序来的</p>
</li>
<li><p>AvailabilityFilteringRule：这个rule就是会考察服务器的可用性</p>
<p>如果3次连接失败，就会等待30秒后再次访问；如果不断失败，那么等待时间会不断变长<br> 如果某个服务器的并发请求太高了，那么会绕过去，不再访问</p>
<p>这里先用round robin算法，轮询依次选择一台server，如果判断这个server是存活的可用的，如果这台server是不可以访问的，那么就用round robin算法再次选择下一台server，依次循环往复，10次。</p>
</li>
<li><p>WeightedResponseTimeRule：带着权重的，每个服务器可以有权重，权重越高优先访问，如果某个服务器响应时间比较长，那么权重就会降低，减少访问</p>
</li>
<li><p>ZoneAvoidanceRule：根据机房和服务器来进行负载均衡，说白了，就是机房的意思，看了源码就是知道了，这个就是所谓的spring cloud ribbon环境中的默认的Rule</p>
</li>
<li><p>BestAvailableRule：忽略那些请求失败的服务器，然后尽量找并发比较低的服务器来请求</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到了这里 Ribbon相关的就结束了，对于Ribbon注册表拉取及更新逻辑这里也梳理下，这里如果Ribbon保存的注册表信息有宕机的情况，这里最多4分钟才能感知到，所以spring cloud还有一个服务熔断的机制，这个后面也会讲到。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200108133953308-926302776.png" alt="07_Ribbon默认IRule可能存在的问题.jpg"></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon 源码三：Ribbon与Eureka整合原理分析</title>
    <url>/2020/01/17/%5BRibbon%20%E6%BA%90%E7%A0%81%E4%B8%89%EF%BC%9ARibbon%E4%B8%8EEureka%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%5D/</url>
    <content><![CDATA[<h1 id="Ribbon-源码三：Ribbon与Eureka整合原理分析"><a href="#Ribbon-源码三：Ribbon与Eureka整合原理分析" class="headerlink" title="[Ribbon 源码三：Ribbon与Eureka整合原理分析]"></a>[Ribbon 源码三：Ribbon与Eureka整合原理分析]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一篇讲了Ribbon的初始化过程，从<code>LoadBalancerAutoConfiguration</code> 到<code>RibbonAutoConfiguration</code> 再到<code>RibbonClientConfiguration</code>，我们找到了<code>ILoadBalancer</code>默认初始化的对象等。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>这一讲我们会进一步往下探究Ribbon和Eureka是如何结合的。</p>
<p>通过上一讲<code>ILoadBalancer</code> 我们已经可以拿到一个服务所有的服务节点信息了，这里面是怎么把服务的名称转化为对应的具体host请求信息的呢？</p>
<p>通过这一讲 我们来一探究竟</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>EurekaClientAutoConfiguration.getLoadBalancer()回顾</li>
<li>再次梳理Ribbon初始化过程</li>
<li>ServerList实现类初始化过程</li>
<li>getUpdatedListOfServers()获取注册表列表分析</li>
<li>ribbon如何更新自己保存的注册表信息？</li>
</ol>
<h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><h4 id="EurekaClientAutoConfiguration-getLoadBalancer-回顾"><a href="#EurekaClientAutoConfiguration-getLoadBalancer-回顾" class="headerlink" title="EurekaClientAutoConfiguration.getLoadBalancer()回顾"></a>EurekaClientAutoConfiguration.getLoadBalancer()回顾</h4><p>上一讲我们已经深入的讲解过<code>getLoadBalancer()</code> 方法的实现，每个serviceName都对应一个自己的SpringContext上下文信息，然后通过<code>ILoadBalancer.class</code>从上下文信息中获取默认的LoadBalancer：<code>ZoneAwareLoadBalancer</code>， 我们看下这个类的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ZoneAwareLoadBalancer(IClientConfig clientConfig, IRule rule,</span><br><span class="line">                             IPing ping, ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span><br><span class="line">                             ServerListUpdater serverListUpdater) &#123;</span><br><span class="line">    super(clientConfig, rule, ping, serverList, filter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟父类<code>DynamicServerListLoadBalancer</code>的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DynamicServerListLoadBalancer&lt;T extends Server&gt; extends BaseLoadBalancer &#123;</span><br><span class="line">    volatile ServerList&lt;T&gt; serverListImpl;</span><br><span class="line"></span><br><span class="line">    volatile ServerListFilter&lt;T&gt; filter;</span><br><span class="line"></span><br><span class="line">    public DynamicServerListLoadBalancer(IClientConfig clientConfig, IRule rule, IPing ping,</span><br><span class="line">                                         ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span><br><span class="line">                                         ServerListUpdater serverListUpdater) &#123;</span><br><span class="line">        super(clientConfig, rule, ping);</span><br><span class="line">        this.serverListImpl = serverList;</span><br><span class="line">        this.filter = filter;</span><br><span class="line">        this.serverListUpdater = serverListUpdater;</span><br><span class="line">        if (filter instanceof AbstractServerListFilter) &#123;</span><br><span class="line">            ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">        &#125;</span><br><span class="line">        restOfInit(clientConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void restOfInit(IClientConfig clientConfig) &#123;</span><br><span class="line">        boolean primeConnection = this.isEnablePrimingConnections();</span><br><span class="line">        // turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span><br><span class="line">        this.setEnablePrimingConnections(false);</span><br><span class="line">        enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">        updateListOfServers();</span><br><span class="line">        if (primeConnection &amp;&amp; this.getPrimeConnections() != null) &#123;</span><br><span class="line">            this.getPrimeConnections()</span><br><span class="line">                    .primeConnections(getReachableServers());</span><br><span class="line">        &#125;</span><br><span class="line">        this.setEnablePrimingConnections(primeConnection);</span><br><span class="line">        LOGGER.info(&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;, clientConfig.getClientName(), this.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @VisibleForTesting</span><br><span class="line">    public void updateListOfServers() &#123;</span><br><span class="line">        List&lt;T&gt; servers = new ArrayList&lt;T&gt;();</span><br><span class="line">        if (serverListImpl != null) &#123;</span><br><span class="line">            servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">            LOGGER.debug(&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                    getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">            if (filter != null) &#123;</span><br><span class="line">                servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">                LOGGER.debug(&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                        getIdentifier(), servers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateAllServerList(servers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法中有个<code>restOfInit()</code>方法，进去后又会有<code>updateListOfServers()</code> 方法，看方法名就知道这个肯定是和server注册表相关的，继续往后看，<code>servers = serverListImpl.getUpdatedListOfServers();</code>，这里直接调用<code>getUpdatedListOfServers()</code>就获取到了所有的注册表信息。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200107094239845-1846816966.jpg" alt="0.jpeg"></p>
<p>可以看到<code>ServerList</code>有四个实现类，这个到底是该调用哪个实现类的<code>getUpdatedListOfServers()</code>方法呢？接着往下看。</p>
<h4 id="再次梳理Ribbon初始化过程"><a href="#再次梳理Ribbon初始化过程" class="headerlink" title="再次梳理Ribbon初始化过程"></a>再次梳理Ribbon初始化过程</h4><p>第二讲我们已经见过Ribbon的初始化过程，并画了图整理，这里针对于之前的图再更新一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200107094241710-1394321382.png" alt="img"></p>
<p>这里主要是增加了<code>RibbonEurekaAutoConfiguration</code>和<code>EurekaRibbonClientConfiguration</code>两个配置类的初始化。</p>
<h4 id="ServerList实现类初始化过程"><a href="#ServerList实现类初始化过程" class="headerlink" title="ServerList实现类初始化过程"></a>ServerList实现类初始化过程</h4><p>上面已经梳理过 <code>Ribbon</code>初始化的过程，其中在<code>EurekaRibbonClientConfiguration</code> 会初始化<code>RibbonServerList</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">    public class EurekaRibbonClientConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public ServerList&lt;?&gt; ribbonServerList(IClientConfig config, Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line">        if (this.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line">            return this.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">        &#125;</span><br><span class="line">        DiscoveryEnabledNIWSServerList discoveryServerList = new DiscoveryEnabledNIWSServerList(</span><br><span class="line">                config, eurekaClientProvider);</span><br><span class="line">        DomainExtractingServerList serverList = new DomainExtractingServerList(</span><br><span class="line">                discoveryServerList, config, this.approximateZoneFromHostname);</span><br><span class="line">        return serverList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实际的<code>ServerList</code>实际就是<code>DiscoveryEnabledNIWSServerList</code>，我们看下这个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiscoveryEnabledNIWSServerList extends AbstractServerList&lt;DiscoveryEnabledServer&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class AbstractServerList&lt;T extends Server&gt; implements ServerList&lt;T&gt;, IClientConfigAware &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以看出来<code>ServerList</code> 实际就是在这里进行初始化的，上面那个<code>serverListImpl.getUpdatedListOfServers();</code>即为调用<code>DiscoveryEnabledNIWSServerList.getUpdatedListOfServers()</code> 方法了，继续往下看。</p>
<h4 id="getUpdatedListOfServers-获取注册表分析"><a href="#getUpdatedListOfServers-获取注册表分析" class="headerlink" title="getUpdatedListOfServers()获取注册表分析"></a>getUpdatedListOfServers()获取注册表分析</h4><p>直接看<code>DiscoveryEnabledNIWSServerList.getUpdatedListOfServers()</code>源代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;DiscoveryEnabledServer&gt; getUpdatedListOfServers()&#123;</span><br><span class="line">    return obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private List&lt;DiscoveryEnabledServer&gt; obtainServersViaDiscovery() &#123;</span><br><span class="line">    List&lt;DiscoveryEnabledServer&gt; serverList = new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">    if (eurekaClientProvider == null || eurekaClientProvider.get() == null) &#123;</span><br><span class="line">        logger.warn(&quot;EurekaClient has not been initialized yet, returning an empty list&quot;);</span><br><span class="line">        return new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EurekaClient eurekaClient = eurekaClientProvider.get();</span><br><span class="line">    if (vipAddresses!=null)&#123;</span><br><span class="line">        for (String vipAddress : vipAddresses.split(&quot;,&quot;)) &#123;</span><br><span class="line">            // if targetRegion is null, it will be interpreted as the same region of client</span><br><span class="line">            List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">            for (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                if (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line"></span><br><span class="line">                    if(shouldUseOverridePort)&#123;</span><br><span class="line">                        if(logger.isDebugEnabled())&#123;</span><br><span class="line">                            logger.debug(&quot;Overriding port on client name: &quot; + clientName + &quot; to &quot; + overridePort);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // copy is necessary since the InstanceInfo builder just uses the original reference,</span><br><span class="line">                        // and we don&apos;t want to corrupt the global eureka copy of the object which may be</span><br><span class="line">                        // used by other clients in our system</span><br><span class="line">                        InstanceInfo copy = new InstanceInfo(ii);</span><br><span class="line"></span><br><span class="line">                        if(isSecure)&#123;</span><br><span class="line">                            ii = new InstanceInfo.Builder(copy).setSecurePort(overridePort).build();</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            ii = new InstanceInfo.Builder(copy).setPort(overridePort).build();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DiscoveryEnabledServer des = new DiscoveryEnabledServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                    des.setZone(DiscoveryClient.getZone(ii));</span><br><span class="line">                    serverList.add(des);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (serverList.size()&gt;0 &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                break; // if the current vipAddress has servers, we dont use subsequent vipAddress based servers</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里代码就已经很明显了，我们来解读下这段代码：</p>
<ol>
<li>通过eurekaClientProvider获取对应EurekaClient</li>
<li>通过vipAdress(实际就是serviceName)获取对应注册表集合信息</li>
<li>将注册信息组装成<code>DiscoveryEnabledServer</code>列表</li>
</ol>
<p>再回到<code>DynamicServerListLoadBalancer.updateListOfServers()</code> 中，这里获取到对应的DiscoveryEnabledServer list后调用<code>updateAllServerList()</code>方法，一路跟踪这里最终会调用<code>BaseLoadBalancer.setServersList()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BaseLoadBalancer extends AbstractLoadBalancer implements</span><br><span class="line">        PrimeConnections.PrimeConnectionListener, IClientConfigAware &#123;</span><br><span class="line"></span><br><span class="line">    @Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL)</span><br><span class="line">    protected volatile List&lt;Server&gt; allServerList = Collections</span><br><span class="line">            .synchronizedList(new ArrayList&lt;Server&gt;());</span><br><span class="line">            </span><br><span class="line">    public void setServersList(List lsrv) &#123;</span><br><span class="line">        Lock writeLock = allServerLock.writeLock();</span><br><span class="line">        logger.debug(&quot;LoadBalancer [&#123;&#125;]: clearing server list (SET op)&quot;, name);</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Server&gt; newServers = new ArrayList&lt;Server&gt;();</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;Server&gt; allServers = new ArrayList&lt;Server&gt;();</span><br><span class="line">            for (Object server : lsrv) &#123;</span><br><span class="line">                if (server == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (server instanceof String) &#123;</span><br><span class="line">                    server = new Server((String) server);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (server instanceof Server) &#123;</span><br><span class="line">                    logger.debug(&quot;LoadBalancer [&#123;&#125;]:  addServer [&#123;&#125;]&quot;, name, ((Server) server).getId());</span><br><span class="line">                    allServers.add((Server) server);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                            &quot;Type String or Server expected, instead found:&quot;</span><br><span class="line">                                    + server.getClass());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            boolean listChanged = false;</span><br><span class="line">            if (!allServerList.equals(allServers)) &#123;</span><br><span class="line">                listChanged = true;</span><br><span class="line">                if (changeListeners != null &amp;&amp; changeListeners.size() &gt; 0) &#123;</span><br><span class="line">                   List&lt;Server&gt; oldList = ImmutableList.copyOf(allServerList);</span><br><span class="line">                   List&lt;Server&gt; newList = ImmutableList.copyOf(allServers);                   </span><br><span class="line">                   for (ServerListChangeListener l: changeListeners) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           l.serverListChanged(oldList, newList);</span><br><span class="line">                       &#125; catch (Exception e) &#123;</span><br><span class="line">                           logger.error(&quot;LoadBalancer [&#123;&#125;]: Error invoking server list change listener&quot;, name, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isEnablePrimingConnections()) &#123;</span><br><span class="line">                for (Server server : allServers) &#123;</span><br><span class="line">                    if (!allServerList.contains(server)) &#123;</span><br><span class="line">                        server.setReadyToServe(false);</span><br><span class="line">                        newServers.add((Server) server);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (primeConnections != null) &#123;</span><br><span class="line">                    primeConnections.primeConnectionsAsync(newServers, this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // This will reset readyToServe flag to true on all servers</span><br><span class="line">            // regardless whether</span><br><span class="line">            // previous priming connections are success or not</span><br><span class="line">            allServerList = allServers;</span><br><span class="line">            if (canSkipPing()) &#123;</span><br><span class="line">                for (Server s : allServerList) &#123;</span><br><span class="line">                    s.setAlive(true);</span><br><span class="line">                &#125;</span><br><span class="line">                upServerList = allServerList;</span><br><span class="line">            &#125; else if (listChanged) &#123;</span><br><span class="line">                forceQuickPing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程最后用一张图总结为：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200107094242501-1185588703.png" alt="img"></p>
<h4 id="ribbon如何更新自己保存的注册表信息？"><a href="#ribbon如何更新自己保存的注册表信息？" class="headerlink" title="ribbon如何更新自己保存的注册表信息？"></a>ribbon如何更新自己保存的注册表信息？</h4><p>上面已经讲了 Ribbon是如何通过serviceName拉取到注册表的，我们知道EurekaClient默认是30s拉取一次注册表信息的，因为Ribbon要关联注册表信息，那么Ribbon该如何更新自己存储的注册表信息呢？</p>
<p>继续回到<code>DynamicSeverListLoadBalancer.restOfInit()</code>方法中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DynamicServerListLoadBalancer&lt;T extends Server&gt; extends BaseLoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    protected volatile ServerListUpdater serverListUpdater;</span><br><span class="line"></span><br><span class="line">    void restOfInit(IClientConfig clientConfig) &#123;</span><br><span class="line">        boolean primeConnection = this.isEnablePrimingConnections();</span><br><span class="line">        // turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span><br><span class="line">        this.setEnablePrimingConnections(false);</span><br><span class="line">        enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">        updateListOfServers();</span><br><span class="line">        if (primeConnection &amp;&amp; this.getPrimeConnections() != null) &#123;</span><br><span class="line">            this.getPrimeConnections()</span><br><span class="line">                    .primeConnections(getReachableServers());</span><br><span class="line">        &#125;</span><br><span class="line">        this.setEnablePrimingConnections(primeConnection);</span><br><span class="line">        LOGGER.info(&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;, clientConfig.getClientName(), this.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enableAndInitLearnNewServersFeature() &#123;</span><br><span class="line">        LOGGER.info(&quot;Using serverListUpdater &#123;&#125;&quot;, serverListUpdater.getClass().getSimpleName());</span><br><span class="line">        serverListUpdater.start(updateAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点查看<code>enableAndInitLearnNewServersFeature()</code>方法，从名字我们就可以看出来这意思为激活和初始化学习新服务的功能，这里实际上就启动<code>serverListUpdater</code>中的一个线程。</p>
<p>在最上面Ribbon初始化的过程中我们知道，在<code>RibbonClientConfiguration</code>中默认初始化的<code>ServerListUpdater</code>为 <code>PollingServreListUpdater</code>，我们继续跟这个类的start方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void start(final UpdateAction updateAction) &#123;</span><br><span class="line">    if (isActive.compareAndSet(false, true)) &#123;</span><br><span class="line">        final Runnable wrapperRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (!isActive.get()) &#123;</span><br><span class="line">                    if (scheduledFuture != null) &#123;</span><br><span class="line">                        scheduledFuture.cancel(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    updateAction.doUpdate();</span><br><span class="line">                    lastUpdated = System.currentTimeMillis();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.warn(&quot;Failed one update cycle&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        scheduledFuture = getRefreshExecutor().scheduleWithFixedDelay(</span><br><span class="line">                wrapperRunnable,</span><br><span class="line">                initialDelayMs,</span><br><span class="line">                refreshIntervalMs,</span><br><span class="line">                TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        logger.info(&quot;Already active, no-op&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只要是执行<code>updateAction.doUpdate();</code>,然后后面启动了一个调度任务，默认30s执行一次。</p>
<p>继续往后跟<code>doUpdate()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DynamicServerListLoadBalancer&lt;T extends Server&gt; extends BaseLoadBalancer &#123;</span><br><span class="line">    protected final ServerListUpdater.UpdateAction updateAction = new ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void doUpdate() &#123;</span><br><span class="line">            updateListOfServers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用了之前通过serviceName获取对应注册服务列表的方法了。</p>
<p>总结到一张图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200107094242964-1147020595.png" alt="注册表服务"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要是重新梳理了Ribbon的初始化过程，主要是几个Configure初始化的过程，然后是Ribbon与Eureka的整合，这里也涉及到了注册表的更新逻辑。</p>
<p>看到这里真是被Spring的各种AutoConfigure绕晕了，哈哈，但是最后分析完 还是觉得挺清晰的，对于复杂的业务画张流程图还挺容易理解的。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon 源码二：Ribbon初始化流程及ILoadBalancer</title>
    <url>/2020/01/16/%5BRibbon%20%E6%BA%90%E7%A0%81%E4%BA%8C%EF%BC%9A%E9%80%9A%E8%BF%87Debug%E6%89%BE%E5%87%BARibbon%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%8F%8AILoadBalancer%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%5D/</url>
    <content><![CDATA[<h1 id="Ribbon-源码二：通过Debug找出Ribbon初始化流程及ILoadBalancer原理分析"><a href="#Ribbon-源码二：通过Debug找出Ribbon初始化流程及ILoadBalancer原理分析" class="headerlink" title="[Ribbon 源码二：通过Debug找出Ribbon初始化流程及ILoadBalancer原理分析]"></a>[Ribbon 源码二：通过Debug找出Ribbon初始化流程及ILoadBalancer原理分析]</h1><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲讲了Ribbon的基础知识，通过一个简单的demo看了下Ribbon的负载均衡，我们在RestTemplate上加了@LoadBalanced注解后，就能够自动的负载均衡了。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>这一讲主要是继续深入<code>RibbonLoadBalancerClient</code>和Ribbon+Eureka整合的方式。</p>
<p>上文我们已经知道调用<code>RestTemplate</code>时，会在其上面加上一个<code>LoadBalancerInterceptor</code>拦截器，其中会先执行<code>LoadBalancerClient.execute()</code>方法。</p>
<p>这里我们会有一个疑问，默认的<code>LoadBalancerInterceptor</code>和<code>LoadBalancerClient</code>都是什么呢？他们分别在哪里进行初始化的呢？</p>
<p>带着这些疑问我们来往前递推下Ribbon初始化过程，相信看完下面的分析后，这些问题也就迎刃而解了。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>从XXXAutoConfig来追溯Ribbon初始化过程</li>
<li>ZoneAwareLoadBalancer原理分析</li>
</ol>
<h4 id="从XXXAutoConfig来追溯Ribbon初始化过程"><a href="#从XXXAutoConfig来追溯Ribbon初始化过程" class="headerlink" title="从XXXAutoConfig来追溯Ribbon初始化过程"></a>从XXXAutoConfig来追溯Ribbon初始化过程</h4><p>在第一篇文章我们已经分析了，和<code>LoadBalanced</code>类同目录下有一个<code>LoadBalancerAutoConfiguration</code>类，这个是我们最先找到的<strong>负载均衡</strong>自动配置类。</p>
<h5 id="LoadBalancerAutoConfiguration作用"><a href="#LoadBalancerAutoConfiguration作用" class="headerlink" title="LoadBalancerAutoConfiguration作用"></a>LoadBalancerAutoConfiguration作用</h5><p>这个配置类主要是为调用的<code>RestTemplate</code>调用时添加<code>LoadBalancerInterceptor</code>过滤器，里面还有其他一些重试的配置，这个后面再看。</p>
<p>查看此类的依赖，可以追踪到：<code>RibbonAutoConfiguration</code>, 如图所示：</p>
<p><a href="https://pic.downk.cc/item/5e0f0cfe76085c32898dd24a.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200106100452510-906620037.jpg" alt="img"></a></p>
<h5 id="RibbonAutoConfiguration作用"><a href="#RibbonAutoConfiguration作用" class="headerlink" title="RibbonAutoConfiguration作用"></a>RibbonAutoConfiguration作用</h5><ol>
<li>初始化SpringClientFactory</li>
<li>初始化LoadBalancerClient: RibbonLoadBalancerClient</li>
</ol>
<p>其中在<code>SpringClientFactory</code>构造函数中有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SpringClientFactory extends NamedContextFactory&lt;RibbonClientSpecification&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public SpringClientFactory() &#123;</span><br><span class="line">        super(RibbonClientConfiguration.class, NAMESPACE, &quot;ribbon.client.name&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里实际上会初始化<code>RibbonClientConfiguration</code>配置类，接着往下看。</p>
<h5 id="RibbonClientConfiguration作用"><a href="#RibbonClientConfiguration作用" class="headerlink" title="RibbonClientConfiguration作用"></a>RibbonClientConfiguration作用</h5><ol>
<li>初始化ribbonRule: <strong>ZoneAvoidanceRule</strong></li>
<li>初始化ribbonPing：<strong>DummyPing</strong></li>
<li>初始化ribbonServerList：<strong>ConfigurationBasedServerList</strong></li>
<li>初始化ServerListUpdater：<strong>new PollingServerListUpdater(config)</strong></li>
<li>初始化ILoadBalancer：<strong>ZoneAwareLoadBalancer</strong></li>
<li>初始化ribbonServerListFilter：<strong>ZonePreferenceServerListFilter</strong></li>
<li>初始化ribbonLoadBalancerContext：<strong>RibbonLoadBalancerContext</strong></li>
<li>初始化serverIntrospector：<strong>DefaultServerIntrospector</strong></li>
</ol>
<p>最后总结为下面一张图所示：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200106100453720-879797546.png" alt="22.png"></p>
<h4 id="ZoneAwareLoadBalancer原理分析"><a href="#ZoneAwareLoadBalancer原理分析" class="headerlink" title="ZoneAwareLoadBalancer原理分析"></a>ZoneAwareLoadBalancer原理分析</h4><p>我们上面已经知道了Ribbon的大致流程，这里我们可以看到默认的<code>ILoadBalancer</code> 为<code>ZoneAwareLoadBalancer</code>，还是回到之前<code>RibbonLoadBalancerClient.execute()</code> 方法中去，看下这里方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException &#123;</span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer);</span><br><span class="line">    if (server == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;No instances available for &quot; + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">            serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    return execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里第一行代码会获取一个<code>ILoadBalancer</code> 我们其实已经知道了，这里默认的<code>ILoadBalancer</code> 为<code>ZoneAwareLoadBalancer</code>。</p>
<p>我们接着看下 <code>RibbonLoadBalancerClient</code> 中的<code>getLoadBalancer()</code> 方法具体是怎么获取这个默认的LoadBalancer的。</p>
<p>这里面使用的是<code>SpringClientFactory.getLoadBalancer()</code> 方法，然后一直往里面跟, 最后调用到 <code>NameContextFactory.java</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class NamedContextFactory&lt;C extends NamedContextFactory.Specification&gt;</span><br><span class="line">        implements DisposableBean, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getInstance(String name, Class&lt;T&gt; type) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">        if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,</span><br><span class="line">                type).length &gt; 0) &#123;</span><br><span class="line">            return context.getBean(type);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected AnnotationConfigApplicationContext getContext(String name) &#123;</span><br><span class="line">        if (!this.contexts.containsKey(name)) &#123;</span><br><span class="line">            synchronized (this.contexts) &#123;</span><br><span class="line">                if (!this.contexts.containsKey(name)) &#123;</span><br><span class="line">                    this.contexts.put(name, createContext(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.contexts.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对每个服务名称，你要调用的每个服务，对应的服务名称，都有一个对应的spring的ApplicationContext容器，ServiceA对应着一个自己的独立的spring的ApplicationContext容器</p>
<p>比如说要获取这个ServiceA服务的LoadBalancer，那么就从ServiceCA服务对应的自己的ApplicationContext容器中去获取自己的LoadBalancer即可</p>
<p>如果是另外一个ServiceC服务，那么又是另外的一个spring APplicationContext，然后从里面获取到的LoadBalancer都是自己的容器里的LoadBalancer</p>
<p>可以通过debug 查看到下图返回的LoadBanlancer信息。这里就不在多赘述。</p>
<p><a href="https://pic.downk.cc/item/5e0f0cfe76085c32898dd24a.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200106100452510-906620037.jpg" alt="img"></a></p>
<p><a href="https://pic.downk.cc/item/5e0f175976085c32898ecf2e.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200106100455787-963069050.jpg" alt="img"></a></p>
<p>上面最后图片可以看到，实例化出来的instance是<code>ZoneAwareLoadBalancer</code> ， 这个类继承自<code>DynamicServerListLoadBalancer</code>，顺带看下类结构：</p>
<p><a href="https://pic.downk.cc/item/5e0f1d9b76085c32898f5c27.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200106100456442-1721326471.jpg" alt="img"></a></p>
<p>到了这里就算是分析完了，再深究<code>ZoneAwareLoadBalancer</code> 就到了和Eureka整合相关的了，这一部分放到下一讲继续讲解了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用一张图做最后的总结：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200106100457063-580433286.png" alt="img"></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon 源码一：Ribbon概念理解及Demo调试</title>
    <url>/2020/01/15/%5BRibbon%20%E6%BA%90%E7%A0%81%E4%B8%80%EF%BC%9ARibbon%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%E5%8F%8ADemo%E8%B0%83%E8%AF%95%5D/</url>
    <content><![CDATA[<h1 id="Ribbon-源码一：Ribbon概念理解及Demo调试"><a href="#Ribbon-源码一：Ribbon概念理解及Demo调试" class="headerlink" title="[Ribbon 源码一：Ribbon概念理解及Demo调试]"></a>[Ribbon 源码一：Ribbon概念理解及Demo调试]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>前面文章已经梳理清楚了Eureka相关的概念及源码，接下来开始研究下Ribbon的实现原理。</p>
<p>我们都知道Ribbon在spring cloud中担当<strong>负载均衡</strong>的角色， 当两个Eureka Client互相调用的时候，Ribbon能够做到调用时的负载，保证多节点的客户端均匀接收请求。(这个有点类似于前端调用后端时Nginx做的负载均衡)</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>本讲主通过一个简单的demo来了解ribbon内部实现，这里主要是对ribbon有个宏观的认识，后续篇章会一步步通过debug的方式对ribbon的细节做一个全面的讲解。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>一个demo来看看ribbon是做什么的</li>
<li>@LoadBalanced初探</li>
<li>LoadBalancerAutoConfiguration初探</li>
<li>RibbonLoadBalancerClient初探</li>
</ol>
<h3 id="Ribbon正文"><a href="#Ribbon正文" class="headerlink" title="Ribbon正文"></a>Ribbon正文</h3><h4 id="一个demo来看看ribbon是做什么的"><a href="#一个demo来看看ribbon是做什么的" class="headerlink" title="一个demo来看看ribbon是做什么的"></a>一个demo来看看ribbon是做什么的</h4><p>首先看下我们这里的demo，目录结构如下：</p>
<p><a href="https://pic.downk.cc/item/5e0eac8f76085c32897e7ab3.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082029929-1729026027.png" alt="img"></a></p>
<p>这里有3个模块，eurekaServer作为注册中心，serviceA和serviceB分别作为EurekaClient。</p>
<p>代码地址上传到了自己的git：<br> <a href="https://github.com/barrywangmeng/spring-cloud-learn" target="_blank" rel="noopener">https://github.com/barrywangmeng/spring-cloud-learn</a></p>
<h4 id="ribbon相关的类结构信息"><a href="#ribbon相关的类结构信息" class="headerlink" title="ribbon相关的类结构信息"></a>ribbon相关的类结构信息</h4><ol>
<li>启动了eureka client如下：<br> <strong>服务A 2个</strong>： 一个端口号为8087，另一个为8088<br> <strong>服务B 1个</strong><br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082033179-443484132.png" alt="image.png"></li>
<li>查看注册中心Dashboard<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082033567-1400489503.png" alt="image.png"></li>
<li>服务B调用服务A中的接口<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082034121-82344400.jpg" alt="调用"></li>
<li>查看负载均衡情况<br> 第一次调用服务B的greeting方法：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082036089-380230309.png" alt="image.png"></li>
<li>第二次调用服务A的greeting方法：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082037662-612781460.png" alt="image.png"></li>
</ol>
<p>这里可以看到服务A调用的时候加了一个注解: <code>@LoadBalanced</code></p>
<p>服务B第一次调用到了服务A的<strong>8088</strong>那个节点<br> 服务B第二次调用到了服务A的<strong>8087</strong>那个节点</p>
<p>这里就可以证明使用<code>@LoadBalanced</code> 自动对我们的http请求加了负载均衡，接下来我们就用<code>@LoadBalanced</code>来一步步往下看。</p>
<h4 id="LoadBalanced初探"><a href="#LoadBalanced初探" class="headerlink" title="@LoadBalanced初探"></a>@LoadBalanced初探</h4><p>接下来看下<code>@LoadBalanced</code>的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** * Annotation to mark a RestTemplate bean to be configured to use </span><br><span class="line">a LoadBalancerClient * @author Spencer Gibb */@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, </span><br><span class="line">ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifierpublic @interface LoadBalanced &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要看注释，这里意思是使用这个注解后可以将普通的<code>RestTemplate</code> 使用 <code>LoadBalanceClient</code> 这个类去处理。</p>
<p>接着我们看下<code>LoadBalanced</code>相关的配置。</p>
<h4 id="LoadBalancerAutoConfiguration初探"><a href="#LoadBalancerAutoConfiguration初探" class="headerlink" title="LoadBalancerAutoConfiguration初探"></a>LoadBalancerAutoConfiguration初探</h4><p>我们知道，springboot + springcloud 对应的组件都会有相应的XXXAutoConfigure配置类，同理，我们在<code>LoadBalanced</code>同级包下可以找到对应的AutoConfigure类：<code>LoadBalancerAutoConfiguration</code>, 先看下类的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RestTemplate.class)</span><br><span class="line">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="line">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="line">public class LoadBalancerAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里有个 <code>@ConditionalOnClass(RestTemplate.class)</code>，这个含义是 只有存在<code>RestTemplate</code> 这个类的时该配置才会生效。</p>
<p>接着看<code>LoadBalancerAutoConfiguration</code>中的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerAutoConfiguration &#123;    </span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SmartInitializingSingleton loadBalancedRestTemplateInitializer(</span><br><span class="line">            final List&lt;RestTemplateCustomizer&gt; customizers) &#123;</span><br><span class="line">        return new SmartInitializingSingleton() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void afterSingletonsInstantiated() &#123;</span><br><span class="line">                for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123;</span><br><span class="line">                    for (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                        customizer.customize(restTemplate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看下<code>loadBalancedRestTemplateInitializer</code> 方法，这个里面会遍历<code>restTemplates</code>然后调用<code>customize()</code> 方法进行特殊处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerAutoConfiguration &#123;    </span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span><br><span class="line">    static class LoadBalancerInterceptorConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        public LoadBalancerInterceptor ribbonInterceptor(</span><br><span class="line">                LoadBalancerClient loadBalancerClient,</span><br><span class="line">                LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">            return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Bean</span><br><span class="line">        @ConditionalOnMissingBean</span><br><span class="line">        public RestTemplateCustomizer restTemplateCustomizer(</span><br><span class="line">                final LoadBalancerInterceptor loadBalancerInterceptor) &#123;</span><br><span class="line">            return new RestTemplateCustomizer() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void customize(RestTemplate restTemplate) &#123;</span><br><span class="line">                    List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList&lt;&gt;(</span><br><span class="line">                            restTemplate.getInterceptors());</span><br><span class="line">                    list.add(loadBalancerInterceptor);</span><br><span class="line">                    restTemplate.setInterceptors(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面是为每一个<code>restTemplate</code> 添加一个<code>loadBalancerInterceptor</code> 拦截器，紧接着看一下<code>LoadBalancerInterceptor.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private LoadBalancerClient loadBalancer;</span><br><span class="line">    private LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,</span><br><span class="line">            final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">        final URI originalUri = request.getURI();</span><br><span class="line">        String serviceName = originalUri.getHost();</span><br><span class="line">        Assert.state(serviceName != null, &quot;Request URI does not contain a valid hostname: &quot; + originalUri);</span><br><span class="line">        return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面就很简单了，将serviceName(这里就是对应我们demo中的：ServiceA)和request、body、excution等组成的新的request传递给<code>LoadBalancerClient</code>，然后调用其中的<code>execute</code>,这个方法的实现继续往下看<code>RibbonLoadBalancerClient</code></p>
<h4 id="RibbonLoadBalancerClient初探"><a href="#RibbonLoadBalancerClient初探" class="headerlink" title="RibbonLoadBalancerClient初探"></a>RibbonLoadBalancerClient初探</h4><p>接下来再看一下 <code>LoadBalanceClient</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface LoadBalancerClient extends ServiceInstanceChooser &#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line"></span><br><span class="line">    URI reconstructURI(ServiceInstance instance, URI original);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口只有一个实现类：<code>RibbonLoadBalancerClient</code>， 那么我们继续看实现类中的execute方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException &#123;</span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer);</span><br><span class="line">    if (server == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;No instances available for &quot; + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">            serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    return execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就可以在这个方法上愉快的debug了，我们先看看<code>ILoadBalancer</code> 是干嘛的：</p>
<p><a href="https://pic.downk.cc/item/5e0eb24e76085c32897f94fb.jpg" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082039639-1582989998.jpg" alt="img"></a></p>
<p>我们通过debug可以看到 获取的<code>ILoadBalancer</code> 已经获取到服务A所有的节点信息了，这一章就先不延伸下去了，后面会详细来说<code>ILoadBalancer</code>处理的细节。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇主要讲解了一个<code>RestTemplate</code> 加上<code>@LoadBalanced</code> 注解后是如何获取到请求服务的多个节点信息的，通过debug 我们可以很清晰的看到请求流程，最后画一个图来总结一下：</p>
<p><a href="https://pic.downk.cc/item/5e0eb7c876085c328980ebe1.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082040226-3881986.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码十二：Eureka总结、架构图以及思维导图</title>
    <url>/2020/01/14/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E5%8D%81%E4%BA%8C%EF%BC%9AEureka%E6%80%BB%E7%BB%93%E3%80%81%E6%9E%B6%E6%9E%84%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码十二：Eureka总结、架构图以及思维导图"><a href="#Nexflix-Eureka-源码十二：Eureka总结、架构图以及思维导图" class="headerlink" title="[Nexflix Eureka 源码十二：Eureka总结、架构图以及思维导图]"></a>[Nexflix Eureka 源码十二：Eureka总结、架构图以及思维导图]</h1><p>主要是架构图、思维导图、以及相关的资料</p>
<a id="more"></a>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先看一下整体的Eureka架构图：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200104063201630-143273808.png" alt="13_Eureka整体架构设计.png"></p>
<p>总结的思维导图：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200104063205750-263272955.png" alt="思维导图.png"></p>
<p>附录几个对spring cloud netflix eureka分析比较好的博客：</p>
<p><a href="https://www.cnblogs.com/rickiyang/p/11802413.html" target="_blank" rel="noopener">Spring Cloud Eureka源码分析—服务注册</a><br><a href="https://www.cnblogs.com/rickiyang/p/11802434.html" target="_blank" rel="noopener">Spring Cloud Eureka源码分析 — client 注册流程</a><br><a href="https://www.cnblogs.com/rickiyang/p/11802441.html" target="_blank" rel="noopener">Spring Cloud Eureka配置文件详解</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码十一：EurekaServer集群模式</title>
    <url>/2020/01/13/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E5%8D%81%E4%B8%80%EF%BC%9AEurekaServer%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%8A%A0%E5%88%86%E9%A2%98)%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码十一：EurekaServer集群模式源码分析-加分题"><a href="#Nexflix-Eureka-源码十一：EurekaServer集群模式源码分析-加分题" class="headerlink" title="[Nexflix Eureka 源码十一：EurekaServer集群模式源码分析(加分题)]"></a>[Nexflix Eureka 源码十一：EurekaServer集群模式源码分析(加分题)]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲看了Eureka 注册中心的自我保护机制，以及里面提到的bug问题。这一讲主要是集群相关的源码</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>本讲主要是EurekaServer集群模式的数据同步讲解，主要目录如下。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>eureka server集群机制</li>
<li>注册、下线、续约的注册表同步机制</li>
<li>注册表同步三层队列机制详解</li>
</ol>
<p><strong>技术亮点：</strong></p>
<ol>
<li>3层队列机制实现注册表的批量同步需求</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="eureka-server集群机制"><a href="#eureka-server集群机制" class="headerlink" title="eureka server集群机制"></a>eureka server集群机制</h4><p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062115508-1016632232.png" alt="image.png"></p>
<p>Eureka Server会在注册、下线、续约的时候进行数据同步，将信息同步到其他Eureka Server节点。</p>
<p>可以想象到的是，这里肯定不会是实时同步的，往后继续看注册表的同步机制吧。</p>
<h4 id="注册、下线、续约的注册表同步机制"><a href="#注册、下线、续约的注册表同步机制" class="headerlink" title="注册、下线、续约的注册表同步机制"></a>注册、下线、续约的注册表同步机制</h4><p>我们以Eureka Client注册为例，看看Eureka Server是如何同步给其他节点的。</p>
<p><code>PeerAwareInstanceRegistryImpl.java</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">    <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  InstanceInfo info <span class="comment">/* optional */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    Stopwatch tracer = action.getTimer().start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isReplication) &#123;</span><br><span class="line">            numberOfReplicationsLastMin.increment();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></span><br><span class="line">        <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</span><br><span class="line">            <span class="comment">// If the url represents this host, do not replicate to yourself.</span></span><br><span class="line">            <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        tracer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateInstanceActionsToPeers</span><span class="params">(Action action, String appName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String id, InstanceInfo info, InstanceStatus newStatus,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 PeerEurekaNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InstanceInfo infoFromRegistry = <span class="keyword">null</span>;</span><br><span class="line">        CurrentRequestVersion.set(Version.V2);</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> Cancel:</span><br><span class="line">                node.cancel(appName, id);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Heartbeat:</span><br><span class="line">                InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</span><br><span class="line">                infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">                node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Register:</span><br><span class="line">                node.register(info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> StatusUpdate:</span><br><span class="line">                infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">                node.statusUpdate(appName, id, newStatus, infoFromRegistry);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DeleteStatusOverride:</span><br><span class="line">                infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</span><br><span class="line">                node.deleteStatusOverride(appName, id, infoFromRegistry);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Cannot replicate information to &#123;&#125; for action &#123;&#125;"</span>, node.getServiceUrl(), action.name(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>注册完成后，调用<code>replicateToPeers()</code>，注意这里面有一个参数<code>isReplication</code>，如果是true，代表是其他Eureka Server节点同步的，false则是EurekaClient注册来的。</li>
<li><code>replicateToPeers()</code>中一段逻辑，如果<code>isReplication</code>为true则直接跳出，这里意思是client注册来的服务实例需要向其他节点扩散，如果不是则不需要去同步</li>
<li><code>peerEurekaNodes.getPeerEurekaNodes()</code>拿到所有的Eureka Server节点，循环遍历去同步数据，调用<code>replicateInstanceActionsToPeers()</code></li>
<li><code>replicateInstanceActionsToPeers()</code>方法中根据注册、下线、续约等去处理不同逻辑</li>
</ol>
<p>接下来就是真正执行同步逻辑的地方，这里主要用了三层队列对同步请求进行了batch操作，将请求打成一批批 然后向各个EurekaServer进行http请求。</p>
<h4 id="注册表同步三层队列机制详解"><a href="#注册表同步三层队列机制详解" class="headerlink" title="注册表同步三层队列机制详解"></a>注册表同步三层队列机制详解</h4><p>到了这里就是真正进入了同步的逻辑，这里还是以上面注册逻辑为主线，接着上述代码继续往下跟：</p>
<p><code>PeerEurekaNode.java</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">    batchingDispatcher.process(</span><br><span class="line">            taskId(<span class="string">"register"</span>, info),</span><br><span class="line">            <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Register, info, <span class="keyword">null</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> replicationClient.register(info);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            expiryTime</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会执行<code>batchingDispatcher.process()</code> 方法，我们继续点进去，然后会进入 <code>TaskDispatchers.createBatchingTaskDispatcher()</code> 方法，查看其中的匿名内部类中的<code>process()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将请求都放入到acceptorQueue中</span></span><br><span class="line">        acceptorQueue.add(<span class="keyword">new</span> TaskHolder&lt;ID, T&gt;(id, task, expiryTime));</span><br><span class="line">        acceptedTasks++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将需要同步的Task数据放入到<code>acceptorQueue</code>队列中。<br> 接着回到<code>createBatchingTaskDispatcher()</code>方法中，看下<code>AcceptorExecutor</code>，它的构造函数中会启动一个后台线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.acceptorThread = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> AcceptorRunner(), <span class="string">"TaskAcceptor-"</span> + id);</span><br></pre></td></tr></table></figure>

<p>我们继续跟<code>AcceptorRunner.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptorRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> scheduleTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isShutdown.get()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理acceptorQueue队列中的数据</span></span><br><span class="line">                drainInputQueues();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> totalItems = processingOrder.size();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (scheduleTime &lt; now) &#123;</span><br><span class="line">                    scheduleTime = now + trafficShaper.transmissionDelay();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (scheduleTime &lt;= now) &#123;</span><br><span class="line">                    <span class="comment">// 将processingOrder拆分成一个个batch，然后进行操作</span></span><br><span class="line">                    assignBatchWork();</span><br><span class="line">                    assignSingleItemWork();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If no worker is requesting data or there is a delay injected by the traffic shaper,</span></span><br><span class="line">                <span class="comment">// sleep for some time to avoid tight loop.</span></span><br><span class="line">                <span class="keyword">if</span> (totalItems == processingOrder.size()) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></span><br><span class="line">                logger.warn(<span class="string">"Discovery AcceptorThread error"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainInputQueues</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            drainAcceptorQueue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isShutdown.get()) &#123;</span><br><span class="line">                <span class="comment">// If all queues are empty, block for a while on the acceptor queue</span></span><br><span class="line">                <span class="keyword">if</span> (reprocessQueue.isEmpty() &amp;&amp; acceptorQueue.isEmpty() &amp;&amp; pendingTasks.isEmpty()) &#123;</span><br><span class="line">                    TaskHolder&lt;ID, T&gt; taskHolder = acceptorQueue.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        appendTaskHolder(taskHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainAcceptorQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!acceptorQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将acceptor队列中的数据放入到processingOrder队列中去，方便后续拆分成batch</span></span><br><span class="line">            appendTaskHolder(acceptorQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTaskHolder</span><span class="params">(TaskHolder&lt;ID, T&gt; taskHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            pendingTasks.remove(processingOrder.poll());</span><br><span class="line">            queueOverflows++;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskHolder&lt;ID, T&gt; previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);</span><br><span class="line">        <span class="keyword">if</span> (previousTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            processingOrder.add(taskHolder.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            overriddenTasks++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>认真跟这里面的代码，可以看到这里是将上面的<code>acceptorQueue</code>放入到<code>processingOrder</code>, 其中<code>processingOrder</code>也是一个队列。</p>
<p>在<code>AcceptorRunner.java</code>的<code>run()</code>方法中，还会调用<code>assignBatchWork()</code>方法，这里面就是将<code>processingOrder</code>打成一个个batch，接着看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignBatchWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hasEnoughTasksForNextBatch()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (batchWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">int</span> len = Math.min(maxBatchingSize, processingOrder.size());</span><br><span class="line">                    List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = <span class="keyword">new</span> ArrayList&lt;&gt;(len);</span><br><span class="line">                    <span class="keyword">while</span> (holders.size() &lt; len &amp;&amp; !processingOrder.isEmpty()) &#123;</span><br><span class="line">                        ID id = processingOrder.poll();</span><br><span class="line">                        TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</span><br><span class="line">                        <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123;</span><br><span class="line">                            holders.add(holder);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            expiredTasks++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (holders.isEmpty()) &#123;</span><br><span class="line">                        batchWorkRequests.release();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="comment">// 将批量数据放入到batchWorkQueue中</span></span><br><span class="line">                        batchWorkQueue.add(holders);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEnoughTasksForNextBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (processingOrder.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认maxBufferSize为250</span></span><br><span class="line">            <span class="keyword">if</span> (pendingTasks.size() &gt;= maxBufferSize) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TaskHolder&lt;ID, T&gt; nextHolder = pendingTasks.get(processingOrder.peek());</span><br><span class="line">            <span class="comment">// 默认maxBatchingDelay为500ms</span></span><br><span class="line">            <span class="keyword">long</span> delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();</span><br><span class="line">            <span class="keyword">return</span> delay &gt;= maxBatchingDelay;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里加入batch的规则是：<code>maxBufferSize</code> 默认为250<br> <code>maxBatchingDelay</code> 默认为500ms，打成一个个batch后就开始发送给server端。至于怎么发送 我们接着看 <code>PeerEurekaNode.java</code>， 我们在最开始调用<code>register()</code>方法就是调用<code>PeerEurekaNode.register()</code>, 我们来看看它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,</span><br><span class="line">                                     HttpReplicationClient replicationClient, EurekaServerConfig config,</span><br><span class="line">                                     <span class="keyword">int</span> batchSize, <span class="keyword">long</span> maxBatchingDelayMs,</span><br><span class="line">                                     <span class="keyword">long</span> retrySleepTimeMs, <span class="keyword">long</span> serverUnavailableSleepTimeMs) &#123;</span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    <span class="keyword">this</span>.targetHost = targetHost;</span><br><span class="line">    <span class="keyword">this</span>.replicationClient = replicationClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.serviceUrl = serviceUrl;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.maxProcessingDelayMs = config.getMaxTimeForReplication();</span><br><span class="line"></span><br><span class="line">    String batcherName = getBatcherName();</span><br><span class="line">    ReplicationTaskProcessor taskProcessor = <span class="keyword">new</span> ReplicationTaskProcessor(targetHost, replicationClient);</span><br><span class="line">    <span class="keyword">this</span>.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(</span><br><span class="line">            batcherName,</span><br><span class="line">            config.getMaxElementsInPeerReplicationPool(),</span><br><span class="line">            batchSize,</span><br><span class="line">            config.getMaxThreadsForPeerReplication(),</span><br><span class="line">            maxBatchingDelayMs,</span><br><span class="line">            serverUnavailableSleepTimeMs,</span><br><span class="line">            retrySleepTimeMs,</span><br><span class="line">            taskProcessor</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会实例化一个<code>ReplicationTaskProcessor.java</code>， 我们跟进去，发下它是实现<code>TaskProcessor</code>的，所以一定会执行此类中的<code>process()</code>方法，执行方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</span><br><span class="line">    ReplicationList list = createReplicationListOf(tasks);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</span><br><span class="line">        <span class="keyword">int</span> statusCode = response.getStatusCode();</span><br><span class="line">        <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</span><br><span class="line">                <span class="keyword">return</span> ProcessingResult.Congestion;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></span><br><span class="line">                logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</span><br><span class="line">                <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleBatchResponse(tasks, response.getEntity().getResponseList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</span><br><span class="line">            logNetworkErrorSample(<span class="keyword">null</span>, e);</span><br><span class="line">            <span class="keyword">return</span> ProcessingResult.TransientError;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> ProcessingResult.PermanentError;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ProcessingResult.Success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面是将<code>List tasks</code> 通过<code>submitBatchUpdate()</code> 发送给server端。<br> server端在<code>PeerReplicationResource.batchReplication()</code>去处理，实际上就是循环调用<code>ApplicationResource.addInstance()</code> 方法，又回到了最开始注册的方法。</p>
<p>到此 EurekaServer同步的逻辑就结束了，这里主要是三层队列的数据结构很绕，通过一个batchList去批量同步数据的。</p>
<p>注意这里还有一个很重要的点，就是Client注册时调用addInstance()方法，这里到了server端<code>PeerAwareInstanceRegistryImpl</code>会执行同步其他EurekaServer逻辑。</p>
<p>而EurekaServer同步注册接口仍然会调用addInstance()方法，这里难不成就死循环调用了？当然不是，addInstance()中也有个参数：<code>isReplication</code>， 在最后调用server端方法的时候如下：<code>registry.register(info, &quot;true&quot;.equals(isReplication));</code></p>
<p>我们知道，EurekaClient在注册的时候<code>isReplication</code>传递为空，所以这里为false，而Server端同步的时候调用：</p>
<p><code>PeerReplicationResource</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Builder handleRegister(ReplicationInstance instanceInfo, ApplicationResource applicationResource) &#123;</span><br><span class="line">        applicationResource.addInstance(instanceInfo.getInstanceInfo(), REPLICATION);</span><br><span class="line">        return new Builder().setStatusCode(Status.OK.getStatusCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>REPLICATION</code> 为true</p>
<p>另外在<code>AbstractJersey2EurekaHttpClient</code>中发送register请求的时候，有个<code>addExtraHeaders()</code>方法，如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062116891-1070419267.png" alt="image.png"></p>
<p>如果是使用的<code>Jersey2ReplicationClient</code>发送的，那么header中的<code>x-netflix-discovery-replication</code>配置则为true，在后面执行注册的<code>addInstance()</code>方法中会接收这个参数的：</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>仍然一图流，文中解析的内容都包含在这张图中了：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062117279-1230211095.png" alt="11_Eureka注册中心集群同步原理.png"></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码十：EurekaServer自我保护机制</title>
    <url>/2020/01/11/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E5%8D%81%EF%BC%9AEurekaServer%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%AB%9F%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9ABug%EF%BC%9F%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码十：EurekaServer自我保护机制"><a href="#Nexflix-Eureka-源码十：EurekaServer自我保护机制" class="headerlink" title="[Nexflix Eureka 源码十：EurekaServer自我保护机制]"></a>[Nexflix Eureka 源码十：EurekaServer自我保护机制]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲主要讲了服务下线，已经注册中心自动感知宕机的服务。<br> 其实上一讲已经包含了很多EurekaServer自我保护的代码，其中还发现了1.7.x（1.9.x）包含的一些bug，但这些问题在master分支都已修复了。</p>
<p>服务下线会将服务实例从注册表中删除，然后放入到recentQueue中，下次其他EurekaClient来进行注册表抓取的时候就能感知到对应的哪些服务下线了。</p>
<p>自动感知服务实例宕机不会调用下线的逻辑，所以我们还抛出了一个问题，一个client宕机，其他的client需要多久才能感知到？通过源码我们知道 至少要180s 才能被注册中心给摘除，也就是最快180s才能被其他服务感知，因为这里还涉及读写缓存和只读缓存不一致的情况。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class that kick starts the eureka server. 负责启动Eureka server的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这里要注意两个关键点：</span></span><br><span class="line"><span class="comment"> * eureka server对应的配置类为：EurekaServerConfig</span></span><br><span class="line"><span class="comment"> * eureka client对应的配置类为：EurekaInstanceConfig</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The eureka server is configured by using the configuration</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EurekaServerConfig&#125; specified by &lt;em&gt;eureka.server.props&lt;/em&gt; in the</span></span><br><span class="line"><span class="comment"> * classpath.  The eureka client component is also initialized by using the</span></span><br><span class="line"><span class="comment"> * configuration &#123;<span class="doctag">@link</span> EurekaInstanceConfig&#125; specified by</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;eureka.client.props&lt;/em&gt;. If the server runs in the AWS cloud, the eureka</span></span><br><span class="line"><span class="comment"> * server binds it to the elastic ip as specified.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Karthik Ranganathan, Greg Kim, David Liu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责EurekaServer初始化的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes Eureka, including syncing up with other Eureka peers and publishing the registry.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span></span></span><br><span class="line"><span class="comment">     * javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initEurekaEnvironment();</span><br><span class="line">            initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.setAttribute(EurekaServerContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">serverContext</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>本讲主要讲解注册中心一个独有的功能，如果使用Eureka作为注册中心的小伙伴可能都看过注册中心Dashboard上会有这么一段文字：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090703315-1189988611.png" alt="image.png"></p>
<p>那注册中心为何要做这种自我保护呢？这里要跟注册中心的设计思想相关联了，我们知道Eureka是一个高可用的组件，符合CAP架构中的A、P，如果注册中心检测到很多服务实例宕机的时候，它不会将这些宕机的数据全都剔除，会做一个判断，如果宕机的服务实例大于所有实例数的15%，那么就会开启保护模式，不会摘除任何实例（代码中是通过每分钟所有实例心跳总数和期望实例心跳总数对比）。</p>
<p>试想，如果没有自我保护机制，注册中心因为网络故障，收不到其他服务实例的续约 而误将这些服务实例都剔除了，是不是就出大问题了。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li><code>evict()</code>方法解读</li>
<li><code>expectedNumberOfRenewsPerMin</code>计算方式</li>
<li><code>expectedNumberOfRenewsPerMin</code>自动更新机制</li>
<li>注册中心<code>Dashboard</code>显示自我保护页面实现</li>
<li>自我保护机制bug汇总</li>
</ol>
<p><strong>技术亮点：</strong></p>
<ol>
<li>如何计算每一分钟内的内存中的计数呢？<br> <code>MeassuredRate</code> 计算每一分钟内的心跳的次数，保存上一分钟心跳次数和当前分钟的心跳次数 后面我们会看一下这个类似怎么实现的</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="evict-方法解读"><a href="#evict-方法解读" class="headerlink" title="evict()方法解读"></a><code>evict()</code>方法解读</h4><p>接着上一讲的内容，上一讲其实已经讲到了<code>evict()</code>的使用，我们再来说下如何一步步调入进来的：</p>
<p><code>EurekaBootStrap.initEurekaServerContext()</code> 中调用<code>registry.openForTraffic()</code>， 然后进入<code>PeerAwareInstanceRegistryImpl.openForTraffic()</code>方法，其中有调用<code>super.postInit()</code> 这里面直接进入到 <code>AbstractInstanceRegistry.postInit()</code>方法，这里其实就是一个定时调度任务，默认一分钟执行一次，这里会执行<code>EvictionTask</code>,在这个task里面会有一个<code>run()</code>方法，最后就是执行到了<code>evict()</code> 方法了。</p>
<p>这里再来看下<code>evict()</code>方法代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void evict(long additionalLeaseMs) &#123;</span><br><span class="line">    logger.debug(&quot;Running the evict task&quot;);</span><br><span class="line"></span><br><span class="line">    // 是否允许主动删除宕机节点数据，这里判断是否进入自我保护机制，如果是自我保护了则不允许摘除服务</span><br><span class="line">    if (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;DS: lease expiration is currently disabled.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略服务摘除等等操作...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入<code>PeerAwareInstanceRegistryImpl.isLeaseExpirationEnabled()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isLeaseExpirationEnabled() &#123;</span><br><span class="line">    if (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">        // The self preservation mode is disabled, hence allowing the instances to expire.</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这行代码触发自我保护机制，期望的一分钟要有多少次心跳发送过来，所有服务实例一分钟得发送多少次心跳</span><br><span class="line">    // getNumOfRenewsInLastMin 上一分钟所有服务实例一共发送过来多少心跳，10次</span><br><span class="line">    // 如果上一分钟 的心跳次数太少了（20次）&lt; 我期望的100次，此时会返回false</span><br><span class="line">    return numberOfRenewsPerMinThreshold &gt; 0 &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先解读一下，上面注释已经说得很清晰了。</p>
<ol>
<li>我们在代码中可以找到<code>this.numberOfRenewsPerMinThreshold =              (int) (this.expectedNumberOfRenewsPerMin *  serverConfig.getRenewalPercentThreshold());</code></li>
<li>这段的意思<code>expectedNumberOfRenewsPerMin</code> 代表每分钟期待的心跳时间，例如现在有100次心跳，然后乘以默认的心跳配比85%,这里就是nuberOfRenewsPerMinThreshold的含义了</li>
<li>如果上一分钟实际心跳次数小于这个值，那么就会进入自我保护模式</li>
</ol>
<p>然后是<code>getNumOfRenewsInLastMin()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MeasuredRate renewsLastMin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNumOfRenewsInLastMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> renewsLastMin.getCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasuredRate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MeasuredRate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong currentBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sampleInterval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Timer timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isActive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sampleInterval in milliseconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeasuredRate</span><span class="params">(<span class="keyword">long</span> sampleInterval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sampleInterval = sampleInterval;</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"Eureka-MeasureRateTimer"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isActive) &#123;</span><br><span class="line">            timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// Zero out the current bucket.</span></span><br><span class="line">                        <span class="comment">// renewsLastMin 为1分钟</span></span><br><span class="line">                        <span class="comment">// 每分钟调度一次，将当前的88次总心跳设置到lastBucket中去，然后将当前的currentBucket 设置为0 秒啊！</span></span><br><span class="line">                        lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Cannot reset the Measured Rate"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, sampleInterval, sampleInterval);</span><br><span class="line"></span><br><span class="line">            isActive = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isActive) &#123;</span><br><span class="line">            timer.cancel();</span><br><span class="line">            isActive = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the count in the last sample interval.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastBucket.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increments the count in the current sample interval.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 心跳次数+1 例如说1分钟所有服务实例共发起了88次心跳</span></span><br><span class="line">        currentBucket.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最上面我们说过,<code>MeasuredRate</code>的设计是一个闪光点，看下重要的两个属性：</p>
<ol>
<li><code>lastBucket</code>: 记录上一分钟总心跳次数</li>
<li><code>currentBucket</code>: 记录当前最近一分钟总心跳次数</li>
</ol>
<p>首先我们看下<code>increment()</code>方法，这里看一下调用会发现在服务端处理续约<code>renew()</code>中的最后会调用此方法，使得<code>currentBucket</code>进行原子性的+1操作。</p>
<p>然后这里明有一个<code>start()</code>方法，这里面也是个时间调度任务，我们可以看下<code>sampleInterval</code>这个时间戳，在构造函数中被赋值，在<code>AbstractInstanceRegistry</code>的构造方法中被调用，默认时间为一分钟。</p>
<p>这里最重要的是<code>lastBucket.set(currentBucket.getAndSet(0));</code> 每分钟调度一次，把当前一分钟总心跳时间赋值给上一分钟总心跳时间，然后将当前一分钟总心跳时间置为0.</p>
<h4 id="expectedNumberOfRenewsPerMin计算方式"><a href="#expectedNumberOfRenewsPerMin计算方式" class="headerlink" title="expectedNumberOfRenewsPerMin计算方式"></a><code>expectedNumberOfRenewsPerMin</code>计算方式</h4><p>我们上一讲中已经介绍过<code>expectedNumberOfRenewsPerMin</code>的计算方式，因为这个属性很重要，所以这里再深入研究一下。</p>
<p>首先我们要理解这个属性的含义：期待的一分钟注册中心接收到的总心跳时间，接着看看哪几个步骤会更新：</p>
<ol>
<li>EurekaServer初始的时候会计算<br> 在<code>openForTraffic()</code> 方法的入口会有计算</li>
<li>服务注册调用<code>register()</code>方法是会更新</li>
<li>服务下线调用<code>cancel()</code>方法时会更新</li>
<li>服务剔除<code>evict()</code> 也应该调用，可惜是代码中并未找到调用的地方？这里其实是个bug，我们可以看后面<code>自我保护机制Bug汇总</code>中提到更多详细内容。此问题至今未修复，我们先继续往后看。</li>
</ol>
<h4 id="expectedNumberOfRenewsPerMin自动更新机制"><a href="#expectedNumberOfRenewsPerMin自动更新机制" class="headerlink" title="expectedNumberOfRenewsPerMin自动更新机制"></a><code>expectedNumberOfRenewsPerMin</code>自动更新机制</h4><p>Server端初始化上下文的时候，15分钟跑的一次定时任务：<br> <code>scheduleRenewalThresholdUpdateTask</code></p>
<p>入口是：<code>EurekaBootStrap.initEurekaServerContext()</code>方法，然后执行<code>serverContext.initialize()</code>方法，里面的<code>registry.init()</code>执行<code>PeerAwareInstanceRegistryImpl.init()</code>中会执行<code>scheduleRenewalThresholdUpdateTask()</code>，这个调度任务默认是每15分钟执行一次的，来看下源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRenewalThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// count为注册表中服务实例的个数</span></span><br><span class="line">        <span class="comment">// 将自己作为eureka client，从其他eureka server拉取注册表</span></span><br><span class="line">        <span class="comment">// 合并到自己本地去 将从别的eureka server拉取到的服务实例的数量作为count</span></span><br><span class="line">        Applications apps = eurekaClient.getApplications();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isRegisterable(instance)) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// Update threshold only if the threshold is greater than the</span></span><br><span class="line">            <span class="comment">// current expected threshold of if the self preservation is disabled.</span></span><br><span class="line">            <span class="comment">// 这里也是存在bug的，master分支已经修复</span></span><br><span class="line">            <span class="comment">// 一分钟服务实例心跳个数(其他eureka server拉取的服务实例个数 * 2) &gt; 自己本身一分钟所有服务实例实际心跳次数 * 0.85(阈值)</span></span><br><span class="line">            <span class="comment">// 这里主要是跟其他的eureka server去做一下同步</span></span><br><span class="line">            <span class="keyword">if</span> ((count * <span class="number">2</span>) &gt; (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)</span><br><span class="line">                    || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) ((count * <span class="number">2</span>) * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"Current renewal threshold is : &#123;&#125;"</span>, numberOfRenewsPerMinThreshold);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Cannot update renewal threshold"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一点，为何上面说<code>eurekaClient.getApplications()</code>是从别的注册中心获取注册表实例信息，因为一个eurekaServer对于其他注册中心来说也是一个eurekaClient。</p>
<p>这里注释已经写得很清晰了，就不再多啰嗦了。</p>
<h4 id="注册中心Dashboard显示自我保护页面实现"><a href="#注册中心Dashboard显示自我保护页面实现" class="headerlink" title="注册中心Dashboard显示自我保护页面实现"></a>注册中心<code>Dashboard</code>显示自我保护页面实现</h4><p>还是自己先找到对应jsp看看具体代码实现：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090704517-87373756.png" alt="image.png"></p>
<p>这里主要是看：<code>registry.isBelowRenewThresold()</code>逻辑。</p>
<p><code>PeerAwareInstanceRegistryImpl.isBelowRenewThresold()</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isBelowRenewThresold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((getNumOfRenewsInLastMin() &lt;= numberOfRenewsPerMinThreshold)</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            ((<span class="keyword">this</span>.startupTime &gt; <span class="number">0</span>) &amp;&amp; (System.currentTimeMillis() &gt; <span class="keyword">this</span>.startupTime + (serverConfig.getWaitTimeInMsWhenSyncEmpty())))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的意思就是 <strong>上一分钟服务实例实际总心跳个数 &lt;= 一分钟期望的总心跳实例 * 85%</strong>，而且判断 Eureka-Server 是否允许被 Eureka-Client 获取注册信息。如果都满足的话就会返回1，当前警告信息就会在dashbord上显示自我保护的提示了。</p>
<p><strong>这里面注意一下配置：</strong><br> <code>#getWaitTimeInMsWhenSyncEmpty()</code> ：Eureka-Server 启动时，从远程 Eureka-Server 读取不到注册信息时，多长时间不允许 Eureka-Client 访问，默认是5分钟</p>
<h4 id="自我保护机制bug汇总"><a href="#自我保护机制bug汇总" class="headerlink" title="自我保护机制bug汇总"></a>自我保护机制bug汇总</h4><ol>
<li>expectedNumberOfRenewsPerMin计算方式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// numberOfRenewsPerMinThreshold = count * 2 * 0.85 = 34 期望一分钟 20个服务实例，得有34个心跳</span></span><br><span class="line"><span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">        (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br></pre></td></tr></table></figure>

<p>这里为何要使用<strong>count * 2</strong>？count是注册表中所有的注册实例的数量，因为作者以为用户不会修改默认续约时间(30s)， 所以理想的认为这里应该乘以2就是一分钟得心跳总数了。</p>
<p>好在看了master 分支此问题已经修复。如下图：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090706562-911306263.png" alt="image.png"></p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090707883-1182042213.png" alt="image.png"></p>
<ol>
<li>同理 服务注册、服务下线 都是将</li>
</ol>
<p>注册：expectedNumberOfRenewsPerMin+2<br> 下线：expectedNumberOfRenewsPerMin-2</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090709026-1204348958.png" alt="image.png"></p>
<p>master分支也给予修复，图片如下：<br> 服务注册：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090711591-637529175.png" alt="image.png"></p>
<p>服务下线：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090712861-351882549.png" alt="image.png"></p>
<ol>
<li><code>evict()</code>方法为何不更新<code>expectedNumberOfRenewsPerMin</code> 按常理来说这里也应该进行 -2操作的，实际上并没有更新，于是看了下master分支源码仍然没有更新，于是早上我便在<code>netflix eureka</code> git<br> 上提了一个isssue：(我蹩脚的英语大家就不要吐槽了，哈哈哈)</li>
</ol>
<p>地址为：<a href="https://github.com/Netflix/eureka/issues/1266" target="_blank" rel="noopener">Where to update the “expectedNumberOfClientsSendingRenews” when we evict a instance?</a><br> 疑问：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090714482-150389264.png" alt="image.png"></p>
<p>搜索了github 发现也有人在2017年就遇到了这个问题，从最后一个回答来看这个问题依然没有解决：</p>
<p><a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/2407" target="_blank" rel="noopener">Eureka seems to do not recalculate numberOfRenewsPerMinThreshold during evicting expired leases</a></p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090715979-1310915119.png" alt="image.png"></p>
<p>翻译如下：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090717128-417363191.png" alt="image.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一张图代为总结一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200102090718248-464926094.png" alt="08_注册中心自我保护机制原理流程图.png"></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码九：服务下线及实例摘除</title>
    <url>/2020/01/10/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E4%B9%9D%EF%BC%9A%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E5%8F%8A%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4%EF%BC%8C%E4%B8%80%E4%B8%AAclient%E4%B8%8B%E7%BA%BF%E5%88%B0%E5%BA%95%E5%A4%9A%E4%B9%85%E6%89%8D%E4%BC%9A%E8%A2%AB%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E6%84%9F%E7%9F%A5%EF%BC%9F%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码九：服务下线及实例摘除"><a href="#Nexflix-Eureka-源码九：服务下线及实例摘除" class="headerlink" title="[Nexflix Eureka 源码九：服务下线及实例摘除]"></a>[Nexflix Eureka 源码九：服务下线及实例摘除]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲我们讲了 client端向server端发送心跳检查，也是默认每30钟发送一次，server端接收后会更新注册表的一个时间戳属性，然后一次心跳(续约)也就完成了。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>这一篇有两个知识点及一个疑问，这个疑问是在工作中真真实实遇到过的。</p>
<p>例如我有服务A、服务B，A、B都注册在同一个注册中心，当B下线后，A多久能感知到B已经下线了呢？</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>Client端服务实例下线通知Server端</li>
<li>Server端定时任务 服务摘除</li>
</ol>
<p><strong>技术亮点：定时任务错误触发时间补偿机制</strong></p>
<p>在Server端定时任务进行服务故障自动感知摘除的时候有一个设计很巧妙的点，时间补偿机制。</p>
<p>我们知道，在做定时任务的时候，基于某个固定点触发的操作都可能由于一些其他原因导致固定的点没有执行对应的操作，这时再次执行定时操作后，计算的每次任务相隔时间就会出现问题。而Eureka 这里采用了一种补偿机制，再计算时间差值的时候完美解决此问题。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Client端服务实例下线通知Server端"><a href="#Client端服务实例下线通知Server端" class="headerlink" title="Client端服务实例下线通知Server端"></a>Client端服务实例下线通知Server端</h4><p>Client下线 我们还是依照之前的原则，从<code>DiscoveryClient</code> 看起，可以看到有一个<code>shutdown()</code> 方法，然后接着跟一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PUT</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFromReplicaNode = <span class="string">"true"</span>.equals(isReplication);</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">"Found (Renew): &#123;&#125; - &#123;&#125;; reply status=&#123;&#125;"</span> + app.getName(), id, response.getStatus());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    RENEW.increment(isReplication);</span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">    Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leaseToRenew = gMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">        logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InstanceInfo instanceInfo = leaseToRenew.getHolder();</span><br><span class="line">        <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></span><br><span class="line">            InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</span><br><span class="line">                    instanceInfo, leaseToRenew, isReplication);</span><br><span class="line">            <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</span><br><span class="line">                logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></span><br><span class="line">                        + <span class="string">"; re-register required"</span>, instanceInfo.getId());</span><br><span class="line">                RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</span><br><span class="line">                Object[] args = &#123;</span><br><span class="line">                        instanceInfo.getStatus().name(),</span><br><span class="line">                        instanceInfo.getOverriddenStatus().name(),</span><br><span class="line">                        instanceInfo.getId()</span><br><span class="line">                &#125;;</span><br><span class="line">                logger.info(</span><br><span class="line">                        <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></span><br><span class="line">                                + <span class="string">"Hence setting the status to overridden status"</span>, args);</span><br><span class="line">                instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        renewsLastMin.increment();</span><br><span class="line">        leaseToRenew.renew();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也很简单，做一些资源释放，取消调度任等操作，这里主要还是关注的是通知Server端的逻辑，及Server端是如何做实例下线的。这里请求Server端请求主要看下<code>unregister</code>方法，这里是调用jersey中的<code>cancel</code> 方法，调用Server端<code>ApplicationsResource</code>中的<code>@DELETE</code> 请求。（<strong>看到这里，前面看到各种client端调用server端，都是通过请求方式来做restful风格调用的，这里不仅要感叹 妙啊</strong>）</p>
<p>我们到Server端看下接收请求的入口代码：</p>
<p><code>InstanceResource.cancelLease()</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DELETE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">cancelLease</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = registry.cancel(app.getName(), id,</span><br><span class="line">            <span class="string">"true"</span>.equals(isReplication));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</span><br><span class="line">        <span class="keyword">return</span> Response.ok().build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Not Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</span><br><span class="line">        <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后接着往下跟，<code>AbstractInstanceRegistry.internalCancel</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        read.lock();</span><br><span class="line">        CANCEL.increment(isReplication);</span><br><span class="line">        <span class="comment">// 通过appName获取注册表信息</span></span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">        Lease&lt;InstanceInfo&gt; leaseToCancel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过实例id将注册信息从注册表中移除</span></span><br><span class="line">            leaseToCancel = gMap.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最近取消的注册表信息队列添加该注册表信息</span></span><br><span class="line">        <span class="keyword">synchronized</span> (recentCanceledQueue) &#123;</span><br><span class="line">            recentCanceledQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + <span class="string">"("</span> + id + <span class="string">")"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</span><br><span class="line">        <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leaseToCancel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CANCEL_NOT_FOUND.increment(isReplication);</span><br><span class="line">            logger.warn(<span class="string">"DS: Registry: cancel failed because Lease is not registered for: &#123;&#125;/&#123;&#125;"</span>, appName, id);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行下线操作的cancel方法</span></span><br><span class="line">            leaseToCancel.cancel();</span><br><span class="line">            InstanceInfo instanceInfo = leaseToCancel.getHolder();</span><br><span class="line">            String vip = <span class="keyword">null</span>;</span><br><span class="line">            String svip = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                instanceInfo.setActionType(ActionType.DELETED);</span><br><span class="line">                <span class="comment">// 最近更新的队列中加入此服务实例信息</span></span><br><span class="line">                recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(leaseToCancel));</span><br><span class="line">                instanceInfo.setLastUpdatedTimestamp();</span><br><span class="line">                vip = instanceInfo.getVIPAddress();</span><br><span class="line">                svip = instanceInfo.getSecureVipAddress();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使注册表的读写缓存失效</span></span><br><span class="line">            invalidateCache(appName, vip, svip);</span><br><span class="line">            logger.info(<span class="string">"Cancelled instance &#123;&#125;/&#123;&#125; (replication=&#123;&#125;)"</span>, appName, id, isReplication);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        read.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看 <code>Lease.cancel</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里只是更新服务实例中下线的时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (evictionTimestamp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        evictionTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里已经加了注释，再总结下：</p>
<p>1、加上读锁，支持多服务实例下线<br> 2、通过appName获取注册表信息map<br> 3、通过appId移除对应注册表信息<br> 4、recentCanceledQueue添加该服务实例<br> 5、更新Lease中的服务实例下线时间<br> 6、recentlyChangedQueue添加该服务实例<br> 7、invalidateCache() 使注册表的读写缓存失效</p>
<p>这里针对于6、7再解释一下，我们在之前：EurekaClient服务发现之注册表抓取 精妙设计分析！  中讲过，当client端第一次进行增量注册表抓取的时候，是会从recentlyChangedQueue中获取数据的，然后放入到读写缓存，然后再同步到只读缓存，下次再获取的时候直接从只读缓存获取即可。</p>
<p>这里会存在一个问题，如果一个服务下线了，读写缓存更新了，但是只读缓存并未更新，30s后由定时任务刷新 读写缓存的数据到了只读缓存，这时其他客户端才会感知到该下线的服务实例。</p>
<p>配合文字说明这里加一个EurekaClient下线流程图，<strong>红色线是下线逻辑</strong>，<strong>黑色线是抓取注册表 感知服务下线逻辑</strong>：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200101100643770-1686507285.png" alt="07_EurekaClient下线逻辑流程.png"></p>
<p>记住一点，这里是正常的服务下线，走shutdown逻辑，如果一个服务突然自己宕机了，那么注册中心怎么去自动感知这个服务下线呢？紧接着往下看吧。</p>
<h4 id="Server端定时任务-服务摘除"><a href="#Server端定时任务-服务摘除" class="headerlink" title="Server端定时任务 服务摘除"></a>Server端定时任务 服务摘除</h4><p>举例一个场景，上面也说过，一个Client服务端自己挂掉了，并没有正常的去执行shutdown方法，那么注册中心该如何感知这个服务实例下线了并从注册表摘除这个实例呢？</p>
<p>我们知道，eureka靠心跳机制来感知服务实例是否还存活着，如果某个服务挂掉了是不会再发送心跳过来了，如果在一段时间内没有接收到某个服务的心跳，那么就将这个服务实例给摘除掉，认为这个服务实例以及宕机了。</p>
<p>这里自动检测服务实例是否宕机的入口在:<code>EurekaBootStrap</code>，eureka server在启动初始化的时候，有个方法<code>registry.openForTraffic(applicationInfoManager, registryCount)</code> 里面会有一个服务实例检测的调度任务（这个入口真的很隐蔽，网上查了别人的分析才找到），接着直接看代码吧。</p>
<p><code>EurekaBootStrap.initEurekaServerContext()</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> registryCount = registry.syncUp();</span><br><span class="line">    registry.openForTraffic(applicationInfoManager, registryCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码前面看过很多次，<code>syncUp</code>是获取其他EurekaServer中注册表数据，然后拿到注册表中服务实例<code>registryCount</code>，然后和自己本地注册表服务实例数量进行对比等等。</p>
<p>接着是openForTraffic方法，这里会计算预期的1分钟所有服务实例心跳次数<code>expectedNumberOfRenewsPerMin</code><br> （插个眼，后面eureka server自我保护机制会用到这个属性）后面会详细讲解，而且这里设置还是有bug的。</p>
<p>在方法的最后会有一个：<code>super.postInit();</code> 到了这里才是真正的服务实例自动感知的调度任务逻辑。兜兜转转 在这个不起眼的地方 隐藏了这么重要的逻辑。</p>
<p><code>PeerAwareInstanceRegistryImpl.java</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Copy entire entry from neighboring DS node</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Interrupted during registry transfer.."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Applications apps = eurekaClient.getApplications();</span><br><span class="line">        <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// isRegisterable：是否可以在当前服务实例所在的注册中心注册。这个方法一定返回true，那么count就是相邻注册中心所有服务实例数量</span></span><br><span class="line">                    <span class="keyword">if</span> (isRegisterable(instance)) &#123;</span><br><span class="line">                        register(instance, instance.getLeaseInfo().getDurationInSecs(), <span class="keyword">true</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"During DS init copy"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span></span><br><span class="line">    <span class="comment">// 如果有20个服务实例，乘以2 代表需要40次心跳</span></span><br><span class="line">    <span class="comment">// 这里有bug，count * 2 是硬编码，作者是不是按照心跳时间30秒计算的？所以计算一分钟得心跳就是 * 2，但是心跳时间是可以自己配置修改的</span></span><br><span class="line">    <span class="comment">// 看了master源码，这一块已经改为：</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * this.expectedNumberOfClientsSendingRenews = this.expectedNumberOfClientsSendingRenews + 1;</span></span><br><span class="line"><span class="comment">     * updateRenewsPerMinThreshold();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 主要是看 updateRenewsPerMinThreshold 方法：</span></span><br><span class="line"><span class="comment">     * this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds() * serverConfig.getRenewalPercentThreshold());</span></span><br><span class="line"><span class="comment">     * 这里完全是读取用户自己配置的心跳检查时间，然后用60s / 配置时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = count * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// numberOfRenewsPerMinThreshold = count * 2 * 0.85 = 34 期望一分钟 20个服务实例，得有34个心跳</span></span><br><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">            (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">    logger.info(<span class="string">"Got "</span> + count + <span class="string">" instances from neighboring DS node"</span>);</span><br><span class="line">    logger.info(<span class="string">"Renew threshold is: "</span> + numberOfRenewsPerMinThreshold);</span><br><span class="line">    <span class="keyword">this</span>.startupTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DataCenterInfo.Name selfName = applicationInfoManager.getInfo().getDataCenterInfo().getName();</span><br><span class="line">    <span class="keyword">boolean</span> isAws = Name.Amazon == selfName;</span><br><span class="line">    <span class="keyword">if</span> (isAws &amp;&amp; serverConfig.shouldPrimeAwsReplicaConnections()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Priming AWS connections for all replicas.."</span>);</span><br><span class="line">        primeAwsReplicas(applicationInfoManager);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"Changing status to UP"</span>);</span><br><span class="line">    applicationInfoManager.setInstanceStatus(InstanceStatus.UP);</span><br><span class="line">    <span class="comment">// 此方法会做服务实例的自动摘除任务</span></span><br><span class="line">    <span class="keyword">super</span>.postInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>关于<code>syncUp</code> 方法，这里知道它是获取其他服务注册表信息，然后获取注册实例数量就行了，后面还会有更详细的讲解。</p>
</li>
<li><p>接着<code>openForTraffic</code> 方法，第一行代码：<code>this.expectedNumberOfRenewsPerMin = count * 2;</code> 这个count是相邻注册表中所有服务实例数量，至于乘以2 是什么意思呢？ 首先是这个字段的含义是：期待的一分钟所有服务实例心跳次数，因为服务续约renew 默认是30s执行一次，所以这里就想当然一分钟就乘以2了。</p>
</li>
<li><p>大家看出来了吧？这是个很明显的bug。因为续约时间是可配置的，如果手动配置成10s，那么这里乘以6才对。看了下公司代码 spring-cloud版本是<code>Finchley.RELEASE</code>， 其中以来的netflix eureka 是<code>1.9.2</code> 仍然存在这个问题。</p>
</li>
<li><p>我也翻看了master分支的代码，此bug已经修复了，修改如下：<br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200101100645809-1878647416.png" alt="image.png"><br> <img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200101100648322-1270157262.png" alt="image.png"></p>
<p>其实这一块还有很多bug，包括服务注册、下线 用的都是+2 -2操作，后面一篇文章会有更多讲解。</p>
</li>
</ol>
<p>继续看服务实例自动感知的调度任务：</p>
<p><code>AbstractInstanceRegistry.java</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    renewsLastMin.start();</span><br><span class="line">    <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        evictionTaskRef.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">    evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">            serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvictionTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastExecutionNanosRef = <span class="keyword">new</span> AtomicLong(<span class="number">0l</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取补偿时间 可能大于0</span></span><br><span class="line">            <span class="keyword">long</span> compensationTimeMs = getCompensationTimeMs();</span><br><span class="line">            logger.info(<span class="string">"Running the evict task with compensationTime &#123;&#125;ms"</span>, compensationTimeMs);</span><br><span class="line">            evict(compensationTimeMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Could not run the evict task"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * compute a compensation time defined as the actual time this task was executed since the prev iteration,</span></span><br><span class="line"><span class="comment">     * vs the configured amount of time for execution. This is useful for cases where changes in time (due to</span></span><br><span class="line"><span class="comment">     * clock skew or gc for example) causes the actual eviction task to execute later than the desired time</span></span><br><span class="line"><span class="comment">     * according to the configured cycle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次进来先获取当前时间 currNanos=20:00:00</span></span><br><span class="line">        <span class="comment">// 第二次过来，此时currNanos=20:01:00</span></span><br><span class="line">        <span class="comment">// 第三次过来，currNanos=20:03:00才过来，本该60s调度一次的，由于fullGC或者其他原因，到了这个时间点没执行</span></span><br><span class="line">        <span class="keyword">long</span> currNanos = getCurrentTimeNano();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上一次这个EvictionTask执行的时间 getAndSet ：以原子方式设置为给定值，并返回以前的值</span></span><br><span class="line">        <span class="comment">// 第一次 将20:00:00 设置到lastNanos，然后return 0</span></span><br><span class="line">        <span class="comment">// 第二次过来后，拿到的lastNanos为20:00:00</span></span><br><span class="line">        <span class="comment">// 第三次过来，拿到的lastNanos为20:01:00</span></span><br><span class="line">        <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</span><br><span class="line">        <span class="keyword">if</span> (lastNanos == <span class="number">0l</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0l</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次进来，计算elapsedMs = 60s</span></span><br><span class="line">        <span class="comment">// 第三次进来，计算elapsedMs = 120s</span></span><br><span class="line">        <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</span><br><span class="line">        <span class="comment">// 第二次进来，配置的服务驱逐间隔默认时间为60s，计算的补偿时间compensationTime=0</span></span><br><span class="line">        <span class="comment">// 第三次进来，配置的服务驱逐间隔默认时间为60s，计算的补偿时间compensationTime=60s</span></span><br><span class="line">        <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</span><br><span class="line">        <span class="keyword">return</span> compensationTime &lt;= <span class="number">0l</span> ? <span class="number">0l</span> : compensationTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getCurrentTimeNano</span><span class="params">()</span> </span>&#123;  <span class="comment">// for testing</span></span><br><span class="line">        <span class="keyword">return</span> System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这里执行<code>postInit</code> 方法，然后执行<code>EvictionTask</code> 任务，执行时间是<code>serverConfig.getEvictionIntervalTimerInMs()</code> 默认是60s执行一次。</li>
<li>接着调用<code>EvictionTask</code> ，这里也加了一些注释，我们再来分析一下。<br> 2.1 首先是获取补偿时间，compenstationTimeMs，这个时间很关键<br> 2.2 调用<code>evict</code> 方法，摘除过期没有发送心跳的实例</li>
</ol>
<p>查看<code>getCompensationTimeMs</code> 方法，这里我添加了很详细的注释，这个方法主要是 为了防止 定时任务触发点，服务因为某些原因没有执行该调度任务，此时<code>elapsedMs</code> 会超过60s的，最后返回的<code>compensationTime</code> 就是实际延误且需要补偿的时间。</p>
<p>接着再看下<code>evict</code> 逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否允许主动删除宕机节点数据，这里判断是否进入自我保护机制，如果是自我保护了则不允许摘除服务</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">                Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    expiredLeases.add(lease);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</span><br><span class="line">    <span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">    <span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line">    <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">            <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">            <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</span><br><span class="line">            Collections.swap(expiredLeases, i, next);</span><br><span class="line">            Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</span><br><span class="line"></span><br><span class="line">            String appName = lease.getHolder().getAppName();</span><br><span class="line">            String id = lease.getHolder().getId();</span><br><span class="line">            EXPIRED.increment();</span><br><span class="line">            logger.warn(<span class="string">"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;"</span>, appName, id);</span><br><span class="line">            internalCancel(appName, id, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">        <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这行代码触发自我保护机制，期望的一分钟要有多少次心跳发送过来，所有服务实例一分钟得发送多少次心跳</span></span><br><span class="line">    <span class="comment">// getNumOfRenewsInLastMin 上一分钟所有服务实例一共发送过来多少心跳，10次</span></span><br><span class="line">    <span class="comment">// 如果上一分钟 的心跳次数太少了（20次）&lt; 我期望的100次，此时会返回false</span></span><br><span class="line">    <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先看<code>isLeaseExpirationEnabled</code> 方法，这个方法是判断是否需要自我保护的，里面逻辑其实也很简单，获取山一分钟所有实例心跳的次数和<code>numberOfRenewsPerMinThreshold</code> (期望的每分钟所有实例心跳次数x85%) 进行对比，如果大于<code>numberOfRenewsPerMinThreshold</code> 才允许摘除实例，否则进入自我保护模式。下一节会详细讲解这个方法。</li>
<li>如果服务实例可以被移除，接着往下看，这里是遍历所有的服务注册信息，然后一个个遍历服务实例心跳时间是否超过了对应的时间，主要看 <code>lease.isExpired(additionalLeaseMs)</code> 方法：</li>
</ol>
<p><code>Lease.isExpired()</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if the lease of a given &#123;<span class="doctag">@link</span> com.netflix.appinfo.InstanceInfo&#125; has expired or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that due to renew() doing the 'wrong" thing and setting lastUpdateTimestamp to +duration more than</span></span><br><span class="line"><span class="comment"> * what it should be, the expiry will actually be 2 * duration. This is a minor bug and should only affect</span></span><br><span class="line"><span class="comment"> * instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will</span></span><br><span class="line"><span class="comment"> * not be fixed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> additionalLeaseMs any additional lease time to add to the lease evaluation in ms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lastUpdateTimestamp renew成功后就会刷新这个时间，可以理解为最近一次活跃时间</span></span><br><span class="line">    <span class="comment">// 查看 Lease.renew方法：lastUpdateTimestamp = System.currentTimeMillis() + duration;</span></span><br><span class="line">    <span class="comment">// duration可以查看为：LeaseInfo中的DEFAULT_LEASE_RENEWAL_INTERVAL=90s 默认为90s</span></span><br><span class="line">    <span class="comment">// 这段逻辑为 当前时间 &gt; 上一次心跳时间 + 90s + 补偿时间</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里先不看补偿时间，假设补偿时间为0，这段的含义是 如果当前时间大于上次续约的时间+90s，那么就认为该实例过期了</span></span><br><span class="line"><span class="comment">     * 因为lastUpdateTimestamp=System.currentTimeMillis()+duration，所以这里可以理解为 超过180是还没有续约，那么就认为该服务实例过期了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * additionalLeaseMs 时间是一个容错的机制，也是服务保持最终一致性的一种手段，针对于定时任务 因为一些不可控原因在某些时间点没有定时执行，那么这个就是很好的容错机制</span></span><br><span class="line"><span class="comment">     * 这段代码 意思现在理解为：服务如果宕机了，那么最少180s 才会被注册中心摘除掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注释已经写得很清楚了，<code>System.currentTimeMillis() &gt; lastUpdateTimestamp + duration + additionalLeaseMs</code> 如果将补偿时间记为0，那么这段代码的含义是 <strong>如果服务如果宕机了，那么最少180s 才会被注册中心摘除掉</strong></p>
<p>上面这段代码翻译完了，接着看一个<strong>彩蛋</strong><br> 看这段代码注释，我先谷歌翻译给大家看下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200101100649867-1806975433.png" alt="image.png"></p>
<p>翻译的不是很好，我再来说下，这里说的是在<code>renew()</code> 方法中，我们写了一个bug，那里不应该多加一个duration(默认90s)时间的，加上了会导致这里duration * 2了，所以也就是至少180s才会被摘除。但是又由于修改会产生其他的问题，所以我们不予修改。</p>
<p>顺便看下<code>renew()</code> 做了什么错事：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/202001/799093-20200101100651074-1725687706.png" alt="image.png"></p>
<p>这里确实多给加了一个duration。</p>
<p>这里接着看<code>evict()</code>后面的操作：</p>
<ol>
<li>将所有需要摘除的服务实例放到<code>expiredLeases</code> 集合中去</li>
<li>计算服务摘除的阈值，<code>registrySizeThreshold</code> 为注册实例总数量 * 85%</li>
<li>计算最多可摘除的服务实例个数：总数量 - 总数量 * 85%<br> 这里实则也是一种保护机制，即使我很多服务宕机了，但是最多只能摘除15%的服务实例。</li>
<li>随机摘取指定的服务实例数量，然后遍历调用<code>internalCancel</code> 方法来remove宕机的服务实例， 这里就是上面讲解的服务下线调用的方法</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分析完了上面所有的代码 是不是有一种大跌眼镜的感觉？我们现在查看的版本确实还存在bug的，有一些bug在master中已经被修复，但仍有些存在。后面一讲会重点跟进这些问题。</p>
<p>接下来就回答开头抛出来的一个问题了：</p>
<p><strong>例如我有服务A、服务B，A、B都注册在同一个注册中心，当B下线后，A多久能感知到B已经下线了呢？</strong></p>
<p>答案是：最快180s才会被感知。如果有补偿时间，或者服务摘除的时候 计算随机摘除服务的时候 没有摘除此服务，那么又会等待180s 来摘除。所以这个只能说一个最块180被感知到。</p>
<p>这一讲还是写了很多，其实这里面包含了很多下一讲的内容，下一讲会对本讲做一个补充。敬请期待。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码八：服务续约源码分析</title>
    <url>/2020/01/10/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E5%85%AB%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码八：服务续约源码分析"><a href="#Nexflix-Eureka-源码八：服务续约源码分析" class="headerlink" title="[Nexflix Eureka 源码八：服务续约源码分析]"></a>[Nexflix Eureka 源码八：服务续约源码分析]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲 我们讲解了服务发现的相关逻辑，所谓服务发现 其实就是注册表抓取，服务实例默认每隔30s去注册中心抓取一下注册表增量数据，然后合并本地注册表数据，最后有个hash对比的操作。</p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><p>今天主要是看下服务续约的逻辑，服务续约就是client端给server端发送心跳检测，告诉对方我还活着。现在很多分布式系统都会有心跳检查的机制，这里一起来学习下Eureka是怎么做心跳检查的。</p>
<p><strong>目录如下：</strong></p>
<ol>
<li>client端心跳检查调度任务</li>
<li>server端接收心跳检查，设置最后renew时间</li>
</ol>
<p>这一讲内容不太多，因为上一篇文章写全量和增量注册表信息内容有点多，所以这里将博客尽量一篇保持一个知识点，后面还会讲服务实例下线、摘除、注册中心自我保护等机制的实现原理。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="client端心跳检查调度任务"><a href="#client端心跳检查调度任务" class="headerlink" title="client端心跳检查调度任务"></a>client端心跳检查调度任务</h4><p>服务实例续约代码比较简单，这里还是从<code>DiscovertClient.java</code> 开始，很多源码的入口都是在这里，因为client端初始化、注册 都是走的这里，因为前几篇文章对这个类已经分析很多了，这里只截取部分重要代码：</p>
<p><code>DiscovertClient.java</code> 初始化后 会继续初始化一些调度任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="comment">//  默认也是30s</span></span><br><span class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Heartbeat timer</span></span><br><span class="line">        <span class="comment">// 执行heartbeatExecutor心跳检查，默认是30s</span></span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"heartbeat"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        heartbeatExecutor,</span><br><span class="line">                        renewalIntervalInSecs,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                ),</span><br><span class="line">                renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行线程</span></span><br><span class="line">        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (renew()) &#123;</span><br><span class="line">            lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">        logger.debug(<span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</span><br><span class="line">            REREGISTER_COUNTER.increment();</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, PREFIX + appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">            <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">            <span class="keyword">boolean</span> success = register();</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, PREFIX + appPathIdentifier, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;InstanceInfo&gt; <span class="title">sendHeartBeat</span><span class="params">(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus)</span> </span>&#123;</span><br><span class="line">    String urlPath = <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id;</span><br><span class="line">    Response response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WebTarget webResource = jerseyClient.target(serviceUrl)</span><br><span class="line">                .path(urlPath)</span><br><span class="line">                .queryParam(<span class="string">"status"</span>, info.getStatus().toString())</span><br><span class="line">                .queryParam(<span class="string">"lastDirtyTimestamp"</span>, info.getLastDirtyTimestamp().toString());</span><br><span class="line">        <span class="keyword">if</span> (overriddenStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">            webResource = webResource.queryParam(<span class="string">"overriddenstatus"</span>, overriddenStatus.name());</span><br><span class="line">        &#125;</span><br><span class="line">        Builder requestBuilder = webResource.request();</span><br><span class="line">        addExtraProperties(requestBuilder);</span><br><span class="line">        addExtraHeaders(requestBuilder);</span><br><span class="line">        requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE);</span><br><span class="line">        response = requestBuilder.put(Entity.entity(<span class="string">"&#123;&#125;"</span>, MediaType.APPLICATION_JSON_TYPE)); <span class="comment">// Jersey2 refuses to handle PUT with no body</span></span><br><span class="line">        EurekaHttpResponseBuilder&lt;InstanceInfo&gt; eurekaResponseBuilder = anEurekaHttpResponse(response.getStatus(), InstanceInfo<span class="class">.<span class="keyword">class</span>).<span class="title">headers</span>(<span class="title">headersOf</span>(<span class="title">response</span>))</span>;</span><br><span class="line">        <span class="keyword">if</span> (response.hasEntity()) &#123;</span><br><span class="line">            eurekaResponseBuilder.entity(response.readEntity(InstanceInfo<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eurekaResponseBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Jersey2 HTTP PUT &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的流程很简单，初始化<code>DiscoveryClient</code> 后会新建一个调度任务，然后执行<code>HeartbeatThread</code>中的run方法，默认是<code>renewalIntervalInSecs</code> 30s执行一次。<br> 具体就是给Server端发送一个http请求，类似于：<code>http://localhost:8080/v2/apps/ServiceA/i-000000-1</code>, 走的是put请求。<br> 最后拿到响应结果，续约成功后会更新<code>lastSuccessfulHeartbeatTimestamp</code> 最近成功心跳检测的时间戳。</p>
<h4 id="server端接收心跳检查请求"><a href="#server端接收心跳检查请求" class="headerlink" title="server端接收心跳检查请求"></a>server端接收心跳检查请求</h4><p>前几篇文章已经说过，Server端接收http请求的入口在<code>eureka-core</code>模块下的 <code>resource</code>包里面，这里直接找到<code>ApplicationResource.java</code>中的<code>getInstanceInfo</code> 方法，这里直接请求的<code>InstanceResource</code> 类的构造方法，找到这个方法中的<code>@PUT</code>请求。可以直接看下代码：</p>
<p><code>InstanceResource.renewLease</code> +<code>AbstractInstanceRegistry.renew</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PUT</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</span></span><br><span class="line"><span class="function">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFromReplicaNode = <span class="string">"true"</span>.equals(isReplication);</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">"Found (Renew): &#123;&#125; - &#123;&#125;; reply status=&#123;&#125;"</span> + app.getName(), id, response.getStatus());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    RENEW.increment(isReplication);</span><br><span class="line">    Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</span><br><span class="line">    Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leaseToRenew = gMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">        logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InstanceInfo instanceInfo = leaseToRenew.getHolder();</span><br><span class="line">        <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></span><br><span class="line">            InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</span><br><span class="line">                    instanceInfo, leaseToRenew, isReplication);</span><br><span class="line">            <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</span><br><span class="line">                logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></span><br><span class="line">                        + <span class="string">"; re-register required"</span>, instanceInfo.getId());</span><br><span class="line">                RENEW_NOT_FOUND.increment(isReplication);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</span><br><span class="line">                Object[] args = &#123;</span><br><span class="line">                        instanceInfo.getStatus().name(),</span><br><span class="line">                        instanceInfo.getOverriddenStatus().name(),</span><br><span class="line">                        instanceInfo.getId()</span><br><span class="line">                &#125;;</span><br><span class="line">                logger.info(</span><br><span class="line">                        <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></span><br><span class="line">                                + <span class="string">"Hence setting the status to overridden status"</span>, args);</span><br><span class="line">                instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        renewsLastMin.increment();</span><br><span class="line">        leaseToRenew.renew();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要看<code>renew</code>方法， 这里看到<code>registry</code> 是一个注册表，通过appName获取对应的服务注册表信息。</p>
<p>这里主要还是看<code>leaseToRenew.renew()</code> 其实很简单，就是设置当前示例注册表的renew属性的<code>lastUpdateTimestamp</code> 为最新时间+duration。</p>
<p>至于这里的duration 我们下一讲会详细讲解，duration 和服务实例摘除有关。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）DiscoveryClient初始化的时候，会去调度一堆定时任务，其中有一个就是HeartbeatThread，心跳线程</p>
<p>（2）在这里可以看到，默认是每隔30秒去发送一次心跳，每隔30秒执行一次HeartbeatTHread线程的逻辑，发送心跳</p>
<p>（3）这边的话就是去发送这个心跳，走的是EurekaHttpClient的sendHeartbeat()方法，<a href="http://localhost:8080/v2/apps/ServiceA/i-000000-1，走的是put请求" target="_blank" rel="noopener">http://localhost:8080/v2/apps/ServiceA/i-000000-1，走的是put请求</a></p>
<p>（4）负责承接服务实例的心跳相关的这些操作的，是ApplicationsResource，服务相关的controller。找到ApplicationResource，再次找到InstanceResource，通过PUT请求，可以找到renewLease方法。</p>
<p>（5）通过注册表的renew()方法，进去完成服务续约，实际进入AbstractInstanceRegistry的renew()方法</p>
<p>（6）从注册表的map中，根据服务名和实例id，获取一个Lease，实际的服务续约的逻辑，其实就是在Lease对象中，更新一下lastUpdateTimestamp这个时间戳，每次续约，就更新一下这个时间戳就ok了。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码七：EurekaClient注册表抓取</title>
    <url>/2020/01/09/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E4%B8%83%EF%BC%9AEurekaClient%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%8A%93%E5%8F%96%20%E7%B2%BE%E5%A6%99%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90%EF%BC%81%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码七：EurekaClient注册表抓取"><a href="#Nexflix-Eureka-源码七：EurekaClient注册表抓取" class="headerlink" title="[Nexflix Eureka 源码七：EurekaClient注册表抓取]"></a>[Nexflix Eureka 源码七：EurekaClient注册表抓取]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h4><p>上一讲 我们通过单元测试 来梳理了EurekaClient是如何注册到server端，以及server端接收到请求是如何处理的，这里最重要的关注点是注册表的一个数据结构：<code>ConcurrentHashMap&gt;&gt;()</code></p>
<a id="more"></a>

<h4 id="本讲目录"><a href="#本讲目录" class="headerlink" title="本讲目录"></a>本讲目录</h4><ol>
<li>client端第一次注册全量抓取注册表的逻辑</li>
<li>server端返回注册表信息集合的多级缓存机制</li>
<li>server端注册表多级缓存过期机制：主动+定时+被动</li>
<li>client端增量抓取注册表逻辑</li>
</ol>
<p><strong>技术亮点：</strong></p>
<ol>
<li>注册表抓取的多级缓存机制</li>
<li>增量抓取返回的全量数据hashCode，和本地数据hashCode对比，保证数据一致性</li>
</ol>
<p>这里再啰嗦一点，之前一直吐槽EurekaClient注册的逻辑，今天看了EurekaClient注册表抓取的逻辑后，不由的感叹设计的精妙之处，这里说的精妙是指EurekaServer端对于注册表读取逻辑的设计，缓存逻辑以及增量获取时Hash一致性的判断，真的很妙，感觉又学到了不少东西。</p>
<h3 id="EurekaClient全量抓取注册表逻辑"><a href="#EurekaClient全量抓取注册表逻辑" class="headerlink" title="EurekaClient全量抓取注册表逻辑"></a>EurekaClient全量抓取注册表逻辑</h3><p>一直在想着怎么才能把自己看完代码后的理解用文字表达出来，这里采用一种新模式吧，先画图，然后源码，然后解读。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191230100153319-2129447041.png" alt="04_EurekaClient注册表全量抓取逻辑.png"></p>
<p>图片看起来很简单，Client发送Http请求给Server端，Server端返回全量的注册表信息给Client端。接下来就是跟进代码一步步分析，这里先有个大概印象</p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><ol>
<li>Client端发送获取全量注册表请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略很多无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">        fetchRegistryFromBackup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</span><br><span class="line">    Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If the delta is disabled or if it is the first time, get all</span></span><br><span class="line">        <span class="comment">// applications</span></span><br><span class="line">        Applications applications = getApplications();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientConfig.shouldDisableDelta()</span><br><span class="line">                || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br><span class="line">                || forceFullRegistryFetch</span><br><span class="line">                || (applications == <span class="keyword">null</span>)</span><br><span class="line">                || (applications.getRegisteredApplications().size() == <span class="number">0</span>)</span><br><span class="line">                || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></span><br><span class="line">        &#123;</span><br><span class="line">            logger.info(<span class="string">"Disable delta property : &#123;&#125;"</span>, clientConfig.shouldDisableDelta());</span><br><span class="line">            logger.info(<span class="string">"Single vip registry refresh property : &#123;&#125;"</span>, clientConfig.getRegistryRefreshSingleVipAddress());</span><br><span class="line">            logger.info(<span class="string">"Force full registry fetch : &#123;&#125;"</span>, forceFullRegistryFetch);</span><br><span class="line">            logger.info(<span class="string">"Application is null : &#123;&#125;"</span>, (applications == <span class="keyword">null</span>));</span><br><span class="line">            logger.info(<span class="string">"Registered Applications size is zero : &#123;&#125;"</span>,</span><br><span class="line">                    (applications.getRegisteredApplications().size() == <span class="number">0</span>));</span><br><span class="line">            logger.info(<span class="string">"Application version is -1: &#123;&#125;"</span>, (applications.getVersion() == -<span class="number">1</span>));</span><br><span class="line">            getAndStoreFullRegistry();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getAndUpdateDelta(applications);</span><br><span class="line">        &#125;</span><br><span class="line">        applications.setAppsHashCode(applications.getReconcileHashCode());</span><br><span class="line">        logTotalInstances();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(PREFIX + <span class="string">"&#123;&#125; - was unable to refresh its cache! status = &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tracer.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删减掉一些代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// registry was fetched successfully, so return true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"Getting all instance registry info from the eureka server"</span>);</span><br><span class="line"></span><br><span class="line">    Applications apps = <span class="keyword">null</span>;</span><br><span class="line">    EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></span><br><span class="line">            ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</span><br><span class="line">            : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</span><br><span class="line">    <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</span><br><span class="line">        apps = httpResponse.getEntity();</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (apps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        logger.error(<span class="string">"The application is null for some reason. Not storing this information"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</span><br><span class="line">        localRegionApps.set(<span class="keyword">this</span>.filterAndShuffle(apps));</span><br><span class="line">        logger.debug(<span class="string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.warn(<span class="string">"Not updating applications as another thread is updating it already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不再赘述Client端是如何一步步跟进到发请求的代码的，因为之前通过单元测试代码已经搞清楚了Server端接受请求的类是<code>ApplicationsResource.java</code>, Client端主要核心的代码也在 <code>DiscoveryClient.java</code>中。</p>
<p>代码还是之前看了好多遍的祖传代码，只是省略了很多内容，只展示我们需要分析的地方。<br> <code>clientConfig.shouldFetchRegistry()</code> 这个配置默认是true，然后<code>fetchRegistry</code>方法中<code>getAndStoreFullRegistry()</code>，因为第一次都是获取全量注册表信息，继续往后。</p>
<p><code>getAndStoreFullRegistry</code> 方法中可以看到就是发送Http请求给Server端，然后等待Server端返回全量注册表信息。</p>
<p>这里获取全量请求执行的是<code>eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</code></p>
<p>然后再一路往下，跟踪到 <code>AbstractJersey2EurekaHttpClient.java</code>中，<code>getApplicationsInternal</code>方法，发下发送的是<code>GET</code>请求，于是到Server端<code>ApplicationsResource.java</code>中的<code>GET</code>方法<code>getContainers</code>中查看逻辑</p>
<h3 id="server端返回注册表信息集合的多级缓存机制"><a href="#server端返回注册表信息集合的多级缓存机制" class="headerlink" title="server端返回注册表信息集合的多级缓存机制"></a>server端返回注册表信息集合的多级缓存机制</h3><p>上面已经看了Client端 发送抓取全量注册表的逻辑，到了Server端查看<code>ApplicationsResource.java</code>中的<code>GET</code>方法<code>getContainers</code>，接着看看这部分的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseCache responseCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">getContainers</span><span class="params">(@PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">                              @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT)</span> String acceptHeader,</span></span><br><span class="line"><span class="function">                              @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT_ENCODING)</span> String acceptEncoding,</span></span><br><span class="line"><span class="function">                              @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept,</span></span><br><span class="line"><span class="function">                              @Context UriInfo uriInfo,</span></span><br><span class="line"><span class="function">                              @Nullable @<span class="title">QueryParam</span><span class="params">(<span class="string">"regions"</span>)</span> String regionsStr) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</span><br><span class="line">            ResponseCacheImpl.ALL_APPS,</span><br><span class="line">            keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</span><br><span class="line">        response = Response.ok(responseCache.getGZIP(cacheKey))</span><br><span class="line">                .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br><span class="line">                .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response = Response.ok(responseCache.get(cacheKey))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    CurrentRequestVersion.remove();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接收到Client端的请求后，会去<code>responseCache</code> 中去拿去全量的数据信息。<br> 从属性名字就可以看出来，这个是从缓存中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseCacheImpl.java</span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</span><br><span class="line">    Value payload = getValue(key, useReadOnlyCache);</span><br><span class="line">    <span class="keyword">if</span> (payload == <span class="keyword">null</span> || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> payload.getPayload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Value <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</span><br><span class="line">    Value payload = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (useReadOnlyCache) &#123;</span><br><span class="line">            <span class="keyword">final</span> Value currentPayload = readOnlyCacheMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (currentPayload != <span class="keyword">null</span>) &#123;</span><br><span class="line">                payload = currentPayload;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                payload = readWriteCacheMap.get(key);</span><br><span class="line">                readOnlyCacheMap.put(key, payload);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            payload = readWriteCacheMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Cannot get value for key : &#123;&#125;"</span>, key, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> payload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要关注<code>getValue</code>方法，这里主要有两个map，一个是<code>readOnlyCacheMap</code> 另一个是<code>readWriteCacheMap</code>, 这里我们光看名字就可以知道一个是只读缓存，一个是读写缓存，这里用了两层的缓存结构，如果只读缓存不为空 则直接返回，如果为空查询可读缓存。</p>
<p>关于缓存的讲解 我们继续往下看。</p>
<h3 id="server端注册表多级缓存过期机制：主动-定时-被动"><a href="#server端注册表多级缓存过期机制：主动-定时-被动" class="headerlink" title="server端注册表多级缓存过期机制：主动+定时+被动"></a>server端注册表多级缓存过期机制：主动+定时+被动</h3><p><strong>继续看缓存相关，用到了多级缓存这里可能就会存在一些疑问：</strong></p>
<ol>
<li>两级缓存数据如何保存同步？</li>
<li>缓存数据如何过期？</li>
</ol>
<p>带着疑问我们来继续看源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Key, Value&gt; readOnlyCacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Key, Value&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LoadingCache&lt;Key, Value&gt; readWriteCacheMap;</span><br><span class="line"></span><br><span class="line">ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> responseCacheUpdateIntervalMs = serverConfig.getResponseCacheUpdateIntervalMs();</span><br><span class="line">    <span class="keyword">this</span>.readWriteCacheMap =</span><br><span class="line">            CacheBuilder.newBuilder().initialCapacity(serverConfig.getInitialCapacityOfResponseCache())</span><br><span class="line">                    .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</span><br><span class="line">                    .removalListener(<span class="keyword">new</span> RemovalListener&lt;Key, Value&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Key, Value&gt; notification)</span> </span>&#123;</span><br><span class="line">                            Key removedKey = notification.getKey();</span><br><span class="line">                            <span class="keyword">if</span> (removedKey.hasRegions()) &#123;</span><br><span class="line">                                Key cloneWithNoRegions = removedKey.cloneWithoutRegions();</span><br><span class="line">                                regionSpecificKeys.remove(cloneWithNoRegions, removedKey);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .build(<span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Value <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (key.hasRegions()) &#123;</span><br><span class="line">                                Key cloneWithNoRegions = key.cloneWithoutRegions();</span><br><span class="line">                                regionSpecificKeys.put(cloneWithNoRegions, key);</span><br><span class="line">                            &#125;</span><br><span class="line">                            Value value = generatePayload(key);</span><br><span class="line">                            <span class="keyword">return</span> value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>readOnlyCacheMap</code>用的是ConcurrentHashMap，线程安全的。<br> <code>readWriteCacheMap</code>用的是GuavaCache，不懂的小伙伴可以自己阅读以下，我之前的博客也有讲解这个，这个是谷歌开源的Guava项目基于内存的缓存，其内部也是实现的Map结构。</li>
<li>主要重点我们来看下GuavaCache，这里初始化大小是<code>serverConfig.getInitialCapacityOfResponseCache()</code> 默认是1000，也是Map的初始大小。<br> <code>expireAfterWrite</code> 刷新时间是<code>serverConfig.getResponseCacheAutoExpirationInSeconds()</code>默认时间是180s。<br> 接着是build方法，这里获取注册表信息就是用的<code>generatePayload</code>方法，如果查询readWriteCacheMap中注册表信息为空，这会执行build方法。</li>
</ol>
<p>继续跟进<code>generatePayload</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">generatePayload</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Stopwatch tracer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String payload;</span><br><span class="line">        <span class="keyword">switch</span> (key.getEntityType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> Application:</span><br><span class="line">                <span class="keyword">boolean</span> isRemoteRegionRequested = key.hasRegions();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ALL_APPS.equals(key.getName())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRemoteRegionRequested) &#123;</span><br><span class="line">                        tracer = serializeAllAppsWithRemoteRegionTimer.start();</span><br><span class="line">                        payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tracer = serializeAllAppsTimer.start();</span><br><span class="line">                        payload = getPayLoad(key, registry.getApplications());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ALL_APPS_DELTA.equals(key.getName())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRemoteRegionRequested) &#123;</span><br><span class="line">                        tracer = serializeDeltaAppsWithRemoteRegionTimer.start();</span><br><span class="line">                        versionDeltaWithRegions.incrementAndGet();</span><br><span class="line">                        versionDeltaWithRegionsLegacy.incrementAndGet();</span><br><span class="line">                        payload = getPayLoad(key,</span><br><span class="line">                                registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        tracer = serializeDeltaAppsTimer.start();</span><br><span class="line">                        versionDelta.incrementAndGet();</span><br><span class="line">                        versionDeltaLegacy.incrementAndGet();</span><br><span class="line">                        payload = getPayLoad(key, registry.getApplicationDeltas());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Value(payload);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tracer.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码删减了一部分，到时增量抓取注册表也会走这个逻辑，<code>ALL_APPS</code>就是全量抓取，<code>ALL_APPS_DELTA</code>就是增量抓取的意思，这里先插个眼，一会增量抓取注册表的逻辑再回头看。</p>
<p>上面的逻辑我们只需要关注<code>registry.getApplicationsFromMultipleRegions</code> 即可，这个是获取注册表的逻辑。接着继续往下跟代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractInstanceRegistry.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Applications apps = <span class="keyword">new</span> Applications();</span><br><span class="line">    apps.setVersion(<span class="number">1L</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123;</span><br><span class="line">                Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    app = <span class="keyword">new</span> Application(lease.getHolder().getAppName());</span><br><span class="line">                &#125;</span><br><span class="line">                app.addInstance(decorateInstanceInfo(lease));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            apps.addApplication(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</span><br><span class="line">            RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</span><br><span class="line">                Applications remoteApps = remoteRegistry.getApplications();</span><br><span class="line">                <span class="keyword">for</span> (Application application : remoteApps.getRegisteredApplications()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Application &#123;&#125;  fetched from the remote region &#123;&#125;"</span>,</span><br><span class="line">                                application.getName(), remoteRegion);</span><br><span class="line"></span><br><span class="line">                        Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());</span><br><span class="line">                        <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</span><br><span class="line">                            apps.addApplication(appInstanceTillNow);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</span><br><span class="line">                            appInstanceTillNow.addInstance(instanceInfo);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a "</span></span><br><span class="line">                                        + <span class="string">"whitelist and this app is not in the whitelist."</span>,</span><br><span class="line">                                application.getName(), remoteRegion);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"No remote registry available for the remote region &#123;&#125;"</span>, remoteRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    apps.setAppsHashCode(apps.getReconcileHashCode());</span><br><span class="line">    <span class="keyword">return</span> apps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再看到 <code>registry.entrySet()</code>是不是会特别亲切？<code>Map&gt;</code> 我们上一篇讲Client注册的时候 就是将注册信息放入到registry对应这个数据结构中的，果不其然，这里拿到所有的注册信息，然后封装到<code>Applications</code> 对象中的。</p>
<p>这里最后<code>apps.setAppsHashCode()</code>逻辑，先插个眼 后面讲增量同步有类似的逻辑，后面再回头看。接着再回头看 返回数据后 <code>readWriteCacheMap</code> 的操作逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldUseReadOnlyResponseCache) &#123;</span><br><span class="line">    timer.schedule(getCacheUpdateTask(),</span><br><span class="line">            <span class="keyword">new</span> Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)</span><br><span class="line">                    + responseCacheUpdateIntervalMs),</span><br><span class="line">            responseCacheUpdateIntervalMs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TimerTask <span class="title">getCacheUpdateTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            logger.debug(<span class="string">"Updating the client cache from response cache"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Key key : readOnlyCacheMap.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Updating the client cache from response cache for key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                            key.getEntityType(), key.getName(), key.getVersion(), key.getType());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    CurrentRequestVersion.set(key.getVersion());</span><br><span class="line">                    Value cacheValue = readWriteCacheMap.get(key);</span><br><span class="line">                    Value currentCacheValue = readOnlyCacheMap.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (cacheValue != currentCacheValue) &#123;</span><br><span class="line">                        readOnlyCacheMap.put(key, cacheValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Error while updating the client cache from response cache for key &#123;&#125;"</span>, key.toStringCompact(), th);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    CurrentRequestVersion.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是起了一个调度任务，会去定时比较一级和二级缓存是否一致，如果不一致 就会用二级缓存覆盖一级缓存。这就回答了上面的第一个问题，两级缓存一致性的问题，默认30s执行一次。所以这里仍会有问题，可能缓存在30s内会存在不一致的情况，这里用的是最终一致的思想。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191230100155385-1911116225.png" alt="image.png"></p>
<p>紧接着 读写缓存获取到数据后再去回写只读缓存，这是上面<code>ResponseCacheImpl.java</code> 的逻辑，到了这里 全量抓取注册表的代码都已经看完了，这里主要的亮点是使用了两级缓存策略来返回对应的数据。</p>
<p>接着整理下过期的几个机制，也是回应上面抛出的第二个问题。</p>
<p><strong>用一张图作为总结：</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191230100156361-820219091.png" alt="05_EurekaServer多节缓存过期机制.png"></p>
<ol>
<li><p>主动过期<br> readWriteCacheMap，读写缓存</p>
<p>有新的服务实例发生注册、下线、故障的时候，就会去刷新readWriteCacheMap（在Client注册的时候，AbstractInstanceRegistry中register方法最后会有一个invalidateCache()方法）</p>
<p>比如说现在有一个服务A，ServiceA，有一个新的服务实例，Instance010来注册了，注册完了之后，其实必须是得刷新这个缓存的，然后就会调用ResponseCache.invalidate()，将之前缓存好的ALL_APPS这个key对应的缓存，给他过期掉</p>
<p>将readWriteCacheMap中的ALL_APPS缓存key，对应的缓存给过期掉</p>
</li>
<li><p>定时过期</p>
<p>readWriteCacheMap在构建的时候，指定了一个自动过期的时间，默认值就是180秒，所以你往readWriteCacheMap中放入一个数据过后，自动会等180秒过后，就将这个数据给他过期了</p>
</li>
<li><p>被动过期</p>
<p>readOnlyCacheMap怎么过期呢？<br> 默认是每隔30秒，执行一个定时调度的线程任务，TimerTask，有一个逻辑，会每隔30秒，对readOnlyCacheMap和readWriteCacheMap中的数据进行一个比对，如果两块数据是不一致的，那么就将readWriteCacheMap中的数据放到readOnlyCacheMap中来。</p>
<p>比如说readWriteCacheMap中，ALL_APPS这个key对应的缓存没了，那么最多30秒过后，就会同步到readOnelyCacheMap中去。</p>
</li>
</ol>
<h3 id="client端增量抓取注册表逻辑"><a href="#client端增量抓取注册表逻辑" class="headerlink" title="client端增量抓取注册表逻辑"></a>client端增量抓取注册表逻辑</h3><p>上面抓取全量注册表的代码已经说了，这里来讲一下增量抓取，入口还是在<code>DiscoverClient.java</code><br> 中，当初始化完<code>DiscoverClient.java</code> 后会执行一个初始化定时任务的方法<code>initScheduledTasks()</code>， 其中这个里面就会每隔30s 增量抓取一次注册表信息。</p>
<p>这里就不跟着这里的逻辑一步步看了，看过上面的代码后 应该会对这里比较清晰了，这里我们直接看Server端代码了。</p>
<p>还记的我们上面插过的眼，获取全量用的是<code>ALL_APPS</code> 增量用的是<code>ALL_APPS_DELTA</code>， 所以我们这里只看增量的逻辑就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ALL_APPS_DELTA.equals(key.getName())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRemoteRegionRequested) &#123;</span><br><span class="line">        tracer = serializeDeltaAppsWithRemoteRegionTimer.start();</span><br><span class="line">        versionDeltaWithRegions.incrementAndGet();</span><br><span class="line">        versionDeltaWithRegionsLegacy.incrementAndGet();</span><br><span class="line">        payload = getPayLoad(key,</span><br><span class="line">                registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tracer = serializeDeltaAppsTimer.start();</span><br><span class="line">        versionDelta.incrementAndGet();</span><br><span class="line">        versionDeltaLegacy.incrementAndGet();</span><br><span class="line">        payload = getPayLoad(key, registry.getApplicationDeltas());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是截取了部分代码，这里直接看主要的逻辑<code>registry.getApplicationDeltasFromMultipleRegions</code>即可，这个和全量的方法名只有一个Deltas的区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltasFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == remoteRegions) &#123;</span><br><span class="line">        remoteRegions = allKnownRemoteRegions; <span class="comment">// null means all remote regions.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> includeRemoteRegion = remoteRegions.length != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">        GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GET_ALL_CACHE_MISS_DELTA.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Applications apps = <span class="keyword">new</span> Applications();</span><br><span class="line">    apps.setVersion(responseCache.getVersionDeltaWithRegions().get());</span><br><span class="line">    Map&lt;String, Application&gt; applicationInstancesMap = <span class="keyword">new</span> HashMap&lt;String, Application&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        write.lock();</span><br><span class="line">        Iterator&lt;RecentlyChangedItem&gt; iter = <span class="keyword">this</span>.recentlyChangedQueue.iterator();</span><br><span class="line">        logger.debug(<span class="string">"The number of elements in the delta queue is :&#123;&#125;"</span>, <span class="keyword">this</span>.recentlyChangedQueue.size());</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Lease&lt;InstanceInfo&gt; lease = iter.next().getLeaseInfo();</span><br><span class="line">            InstanceInfo instanceInfo = lease.getHolder();</span><br><span class="line">            logger.debug(<span class="string">"The instance id &#123;&#125; is found with status &#123;&#125; and actiontype &#123;&#125;"</span>,</span><br><span class="line">                    instanceInfo.getId(), instanceInfo.getStatus().name(), instanceInfo.getActionType().name());</span><br><span class="line">            Application app = applicationInstancesMap.get(instanceInfo.getAppName());</span><br><span class="line">            <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                app = <span class="keyword">new</span> Application(instanceInfo.getAppName());</span><br><span class="line">                applicationInstancesMap.put(instanceInfo.getAppName(), app);</span><br><span class="line">                apps.addApplication(app);</span><br><span class="line">            &#125;</span><br><span class="line">            app.addInstance(<span class="keyword">new</span> InstanceInfo(decorateInstanceInfo(lease)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (includeRemoteRegion) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</span><br><span class="line">                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</span><br><span class="line">                    Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != remoteAppsDelta) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Application application : remoteAppsDelta.getRegisteredApplications()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</span><br><span class="line">                                Application appInstanceTillNow =</span><br><span class="line">                                        apps.getRegisteredApplications(application.getName());</span><br><span class="line">                                <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</span><br><span class="line">                                    apps.addApplication(appInstanceTillNow);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</span><br><span class="line">                                    appInstanceTillNow.addInstance(<span class="keyword">new</span> InstanceInfo(instanceInfo));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);</span><br><span class="line">        apps.setAppsHashCode(allApps.getReconcileHashCode());</span><br><span class="line">        <span class="keyword">return</span> apps;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        write.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码还是比较多的，我们只需要抓住重点即可：</p>
<ol>
<li>从<code>recentlyChangedQueue</code>中获取注册信息，从名字可以看出来 这是最近改变的client注册信息的队列</li>
<li>使用writeLock，因为这里是获取增量注册信息，是从队列中获取，如果不加写锁，那么获取的时候又有新数据加入队列中，新数据会获取不到的</li>
</ol>
<p>基于上面第一点，我们来看看这个队列怎么做的：</p>
<ol>
<li>数据结构：<code>ConcurrentLinkedQueue  recentlyChangedQueue</code></li>
<li><code>AbstractInstanceRegistry.java</code>初始化的时候会启动一个定时任务，默认30s中执行一次。如果注册时间小于当前时间的180s，就会放到这个队列中</li>
</ol>
<p><code>AbstractInstanceRegistry.java</code>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractInstanceRegistry</span><span class="params">(EurekaServerConfig serverConfig, EurekaClientConfig clientConfig, ServerCodecs serverCodecs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serverConfig = serverConfig;</span><br><span class="line">    <span class="keyword">this</span>.clientConfig = clientConfig;</span><br><span class="line">    <span class="keyword">this</span>.serverCodecs = serverCodecs;</span><br><span class="line">    <span class="keyword">this</span>.recentCanceledQueue = <span class="keyword">new</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">this</span>.recentRegisteredQueue = <span class="keyword">new</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.renewsLastMin = <span class="keyword">new</span> MeasuredRate(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.deltaRetentionTimer.schedule(getDeltaRetentionTask(),</span><br><span class="line">            serverConfig.getDeltaRetentionTimerIntervalInMs(),</span><br><span class="line">            serverConfig.getDeltaRetentionTimerIntervalInMs());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TimerTask <span class="title">getDeltaRetentionTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Iterator&lt;RecentlyChangedItem&gt; it = recentlyChangedQueue.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.next().getLastUpdateTime() &lt;</span><br><span class="line">                        System.currentTimeMillis() - serverConfig.getRetentionTimeInMSInDeltaQueue()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就能看明白了，也就是说增量抓取会获取EurekaServer端3分钟内保存的变动的Client信息。<br> 最后还有一个亮点，我们上面说过，无论是全量抓取还是增量抓取，最后都会返回一个全量注册表的hash值，代码是<code>apps.setAppsHashCode(allApps.getReconcileHashCode());</code>, 其中apps就是返回的<code>Applications</code>中的属性，最后我们再看看这个hashCode的用法。</p>
<p>回到<code>DiscoveryClient.java</code>, 找到<code>refreshRegistry</code> 方法，然后一路跟踪到<code>getAndUpdateDelta</code>方法，这里具体代码我就不贴了，流程如下：</p>
<ol>
<li>获取delta增量数据</li>
<li>根据增量数据和本地注册表数据进行合并</li>
<li>计算中本地注册表信息的hashCode值</li>
<li>如果本地hashCode值和server端返回的hashCode值不一致则再全量获取一次注册表信息</li>
</ol>
<p>最后一张图总结增量注册表抓取逻辑：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191230100157542-1986591842.png" alt="06_EurekaClient增量抓取注册表流程.png"></p>
<h3 id="总结-amp-感悟"><a href="#总结-amp-感悟" class="headerlink" title="总结&amp;感悟"></a>总结&amp;感悟</h3><p>这篇文章写得有点长了，确实自己也很用心去写了，我感觉这里多级缓存机制+增量数据Hash一致性的对比方案做的很优秀，如果要我做一个数据全量+增量同步 我也会借鉴这种方案。</p>
<p>看源码 能够学到的就是别人的设计思想。总结的部分可以看上面的一些图，注册表抓取的源码学习就到这了，后面 还准备看下心跳机制、保护机制、集群等等一些的源码。</p>
<p>这里读完源码之后会发下一个问题：</p>
<p>假设有服务实例注册、下线、故障，要调用这个服务的其他服务，可能会过30秒之后才能感知倒，为什么呢？因为这里再获取服务注册表的时候，有一个多级缓存的机制，最多是30秒后才会去更新一级缓存。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码六：通过单元测试来Debug Eureka注册过程</title>
    <url>/2020/01/07/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E5%85%AD%EF%BC%9A%E9%80%9A%E8%BF%87%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9D%A5Debug%20Eureka%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码六：通过单元测试来Debug-Eureka注册过程"><a href="#Nexflix-Eureka-源码六：通过单元测试来Debug-Eureka注册过程" class="headerlink" title="[Nexflix Eureka 源码六：通过单元测试来Debug Eureka注册过程]"></a>[Nexflix Eureka 源码六：通过单元测试来Debug Eureka注册过程]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一讲eureka client是如何注册的，一直跟到源码发送http请求为止，当时看eureka client注册时如此费尽，光是找一个regiter的地方就找了半天，那么client端发送了http请求给server端，server端是如何处理的呢？</p>
<p>带着这么一个疑问 就开始今天源码的解读了。</p>
<a id="more"></a>

<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="从何读起？"><a href="#从何读起？" class="headerlink" title="从何读起？"></a>从何读起？</h4><p>上一讲我们知道，跟进client注册 一直到 <code>AbstractJersey2EurekaHttpClient.register</code>方法，这里先看下其中的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        String urlPath = <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line">        Response response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送请求，类似于：http://localhost:8080/v2/apps/ServiceA</span></span><br><span class="line">            <span class="comment">// 发送的是post请求，服务实例的对象被打成了一个json发送，包括自己的主机、ip、端口号</span></span><br><span class="line">            <span class="comment">// eureka server 就知道了这个ServiceA这个服务，有一个服务实例，比如是在192.168.31.109、host-01、8761端口</span></span><br><span class="line">            Builder resourceBuilder = jerseyClient.target(serviceUrl).path(urlPath).request();</span><br><span class="line">            addExtraProperties(resourceBuilder);</span><br><span class="line">            addExtraHeaders(resourceBuilder);</span><br><span class="line">            response = resourceBuilder</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .acceptEncoding(<span class="string">"gzip"</span>)</span><br><span class="line">                    .post(Entity.json(info));</span><br><span class="line">            <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Jersey2 HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                        response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那这种情况我们肯定可以猜测，server端应该有个controller来接收此http请求，然后默默的去做一些注册的逻辑。</p>
<p>紧接着我们从<code>/apps/</code>这个关键词入手，进行全局搜索：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191229204947283-946476056.png" alt="image.png"></p>
<p>全局搜索结果如下，这里可以看到很多test 调用，这里框起来的一个是不是类似于我们controller接口的调用呢？直接点进去查看，然后一步步跟进。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>接着上面说的，跟进<code>ApplicationResource</code>这个类，可以找到如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"&#123;appId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">        @<span class="title">PathParam</span><span class="params">(<span class="string">"appId"</span>)</span> String appId) </span>&#123;</span><br><span class="line">    CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个appId可以理解为我们之前传递的appName，紧接着这里是直接构造了一个<code>ApplicationResource</code>实例，接着跟进代码，进入<code>ApplicationResource</code>中我们可以看到很多<code>@GET</code>、<code>@POST</code> 等restful接口，还记得上面我们register方法中，发送的http请求用的就是POST方法，所以我们这里直接看<code>@POST</code>请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"Registering instance &#123;&#125; (replication=&#123;&#125;)"</span>, info.getId(), isReplication);</span><br><span class="line">    <span class="comment">// validate that the instanceinfo contains all the necessary required fields</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(info.getId())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing instanceId"</span>).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getHostName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing hostname"</span>).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getIPAddr())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing ip address"</span>).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getAppName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing appName"</span>).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!appName.equals(info.getAppName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Mismatched appName, expecting "</span> + appName + <span class="string">" but was "</span> + info.getAppName()).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo"</span>).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo().getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo Name"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle cases where clients may be registering with bad DataCenterInfo with missing data</span></span><br><span class="line">    DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</span><br><span class="line">    <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</span><br><span class="line">        String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();</span><br><span class="line">        <span class="keyword">if</span> (isBlank(dataCenterInfoId)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> experimental = <span class="string">"true"</span>.equalsIgnoreCase(serverConfig.getExperimental(<span class="string">"registration.validation.dataCenterInfoId"</span>));</span><br><span class="line">            <span class="keyword">if</span> (experimental) &#123;</span><br><span class="line">                String entity = <span class="string">"DataCenterInfo of type "</span> + dataCenterInfo.getClass() + <span class="string">" must contain a valid id"</span>;</span><br><span class="line">                <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(entity).build();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> AmazonInfo) &#123;</span><br><span class="line">                AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;</span><br><span class="line">                String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);</span><br><span class="line">                <span class="keyword">if</span> (effectiveId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Registering DataCenterInfo of type &#123;&#125; without an appropriate id"</span>, dataCenterInfo.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registry.register(info, <span class="string">"true"</span>.equals(isReplication));</span><br><span class="line">    <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于代码不是很长，这里都给截取出来了。其实这里做的事情就很简单了。</p>
<ol>
<li>做一些常规的chek，检查注册实例<code>InstanceInfo</code>的一些基本信息</li>
<li>DataCenter的相关操作，这里还涉及到亚马逊云，我们直接跳过</li>
<li><code>registry.register(info, &quot;true&quot;.equals(isReplication));</code> 这里才是核心的注册，我们继续往下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">    <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        read.lock();</span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">        REGISTER.increment(isReplication);</span><br><span class="line">        <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">            gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">            <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                gMap = gNewMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">        <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></span><br><span class="line">        <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();</span><br><span class="line">            Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();</span><br><span class="line">            logger.debug(<span class="string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span></span><br><span class="line">            <span class="comment">// InstanceInfo instead of the server local copy.</span></span><br><span class="line">            <span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</span><br><span class="line">                logger.warn(<span class="string">"There is an existing lease and the existing lease's dirty timestamp &#123;&#125; is greater"</span> +</span><br><span class="line">                        <span class="string">" than the one that is being registered &#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br><span class="line">                logger.warn(<span class="string">"Using the existing instanceInfo instead of the new instanceInfo as the registrant"</span>);</span><br><span class="line">                registrant = existingLease.getHolder();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The lease does not exist and hence it is a new registration</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></span><br><span class="line">                    <span class="comment">// (1</span></span><br><span class="line">                    <span class="comment">// for 30 seconds, 2 for a minute)</span></span><br><span class="line">                    <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</span><br><span class="line">                            (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(<span class="string">"No previous lease information found; it is new registration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">        <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">        &#125;</span><br><span class="line">        gMap.put(registrant.getId(), lease);</span><br><span class="line">        <span class="keyword">synchronized</span> (recentRegisteredQueue) &#123;</span><br><span class="line">            recentRegisteredQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(</span><br><span class="line">                    System.currentTimeMillis(),</span><br><span class="line">                    registrant.getAppName() + <span class="string">"("</span> + registrant.getId() + <span class="string">")"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is where the initial state transfer of overridden status happens</span></span><br><span class="line">        <span class="keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span></span><br><span class="line">                            + <span class="string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());</span><br><span class="line">            <span class="keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</span><br><span class="line">                logger.info(<span class="string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());</span><br><span class="line">                overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</span><br><span class="line">        <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</span><br><span class="line">            registrant.setOverriddenStatus(overriddenStatusFromMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the status based on the overridden status rules</span></span><br><span class="line">        InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</span><br><span class="line">        registrant.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the lease is registered with UP status, set lease service up timestamp</span></span><br><span class="line">        <span class="keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</span><br><span class="line">            lease.serviceUp();</span><br><span class="line">        &#125;</span><br><span class="line">        registrant.setActionType(ActionType.ADDED);</span><br><span class="line">        recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</span><br><span class="line">        registrant.setLastUpdatedTimestamp();</span><br><span class="line">        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</span><br><span class="line">        logger.info(<span class="string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,</span><br><span class="line">                registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        read.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里东西就有点多了，我们慢慢梳理。</p>
<ol>
<li>reda.lock() 这里使用的是读锁，方便多个服务实例同时来注册</li>
<li>这里关键信息是registry的数据结构，同时这也是保存注册实例的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</span><br><span class="line">            = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap的key是appName<br> 第二层Map的key是appId，所以数据结构格式类似于：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “ServiceA”: &#123;</span><br><span class="line">        “001”: Lease&lt;InstanceInfo&gt;,</span><br><span class="line">        “002”: Lease&lt;InstanceInfo&gt;,</span><br><span class="line">        “003”: Lease&lt;InstanceInfo&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    “ServiceB”: &#123;</span><br><span class="line">        “001”: Lease&lt;InstanceInfo&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这里面还有两个队列<code>recentRegisteredQueue</code>、<code>recentlyChangedQueue</code>，其中registerQueue默认保存最近1000条注册的实例信息。</li>
<li>后面就是一些状态设置之类的操作</li>
</ol>
<h4 id="注册表使用场景"><a href="#注册表使用场景" class="headerlink" title="注册表使用场景"></a>注册表使用场景</h4><p>我们注册完成之后，打开eureka 后台配置页面，可以看到自己的实例已经在页面上了，那么这个东东是如何展示的呢？</p>
<p>我们都知道eureka-resources模块下有很多jsp信息，点开status.jsp查看一下：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191229204951371-91712911.png" alt="image.png"></p>
<p>这里用到了 <code>serverContext.getRegistry().getSortedApplications()</code>, 然后在通过获取的<code>Applicaiton</code> 去执行<code>app.getInstances()</code>等到了所有大的服务实例信息。</p>
<p>这里我们还需要回头看下<code>EurekaBootStrap</code>中的代码，看看Application是如何来的。</p>
<p>从<code>PeerAwareInstanceRegistryImpl.java</code>的<code>getSortedApplications()</code>一直跟到 <code>AbstractInstanceRegistry.java</code>的<code>getApplicationsFromMultipleRegions()</code>,如下图所示：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191229204955155-1709796290.png" alt="image.png"></p>
<p>看到这里是不是就真相大白了？<br> 这里再总结一下：</p>
<p>在jsp代码中，拿到了EurekaServerContext，所以之前为什么要将这个东东放到一个Holder里面去，就是随时都要从这个里面去获取一些数据</p>
<p>然后会从EurekaServerContext，获取到注册表，PeerAwareInstanceRegistry，注册表，从里面获取所有的服务信息，从底层的map数据结构中，获取所有的服务注册的信息，遍历，封装到一个叫Application的东西里去，一个Application就代表了一个服务，里面包含很多个服务实例。</p>
<h4 id="Eureka的服务注册流程图"><a href="#Eureka的服务注册流程图" class="headerlink" title="Eureka的服务注册流程图"></a>Eureka的服务注册流程图</h4><p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191229204956521-2000791919.png" alt="image.png"></p>
<h3 id="申明"><a href="#申明" class="headerlink" title="申明"></a>申明</h3>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码五：在眼花缭乱的代码中，EurekaClient是如何注册的？</title>
    <url>/2020/01/05/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E4%BA%94%EF%BC%9A%E5%9C%A8%E7%9C%BC%E8%8A%B1%E7%BC%AD%E4%B9%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8CEurekaClient%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84%EF%BC%9F%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码五：在眼花缭乱的代码中，EurekaClient是如何注册的？"><a href="#Nexflix-Eureka-源码五：在眼花缭乱的代码中，EurekaClient是如何注册的？" class="headerlink" title="[Nexflix Eureka 源码五：在眼花缭乱的代码中，EurekaClient是如何注册的？]"></a>[Nexflix Eureka 源码五：在眼花缭乱的代码中，EurekaClient是如何注册的？]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一讲已经讲解了EurekaClient的启动流程，到了这里已经有6篇Eureka源码分析的文章了，看了下之前的文章，感觉代码成分太多，会影响阅读，后面会只截取主要的代码，加上注释讲解。</p>
<p>这一讲看的是EurekaClient注册的流程，当然也是一块核心，标题为什么会写上眼花缭乱呢？关于EurekaClient注册的代码，真的不是这么容易被发现的。</p>
<a id="more"></a>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>如果是看过前面文章的同学，肯定会知道，Eureka Client启动流程最后是初始化DiscoveryClient这个类，那么我们就直接从这个类开始分析，后面代码都只截取重要代码，具体大家可以自行参照源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryClient.java</span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</span><br><span class="line">    <span class="comment">// 创建一个配置实例，这里面会有eureka的各种信息，看InstanceInfo类的注释为：The class that holds information required for registration with Eureka Server </span></span><br><span class="line">    <span class="comment">// and to be discovered by  other components.</span></span><br><span class="line">    InstanceInfo myInfo = applicationInfoManager.getInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 支持底层的eureka client跟eureka server进行网络通信的组件</span></span><br><span class="line">        eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line">        <span class="comment">// 发送http请求，调用restful接口</span></span><br><span class="line">        scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to initialize DiscoveryClient!"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化调度任务</span></span><br><span class="line">    initScheduledTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面省略了很多代码，这段代码在之前的几篇文章也都有提及，说实话看到这里 仍然一脸闷逼，入册的入口在哪呢？不急，下面慢慢分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryClient.java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略大部分代码，这段代码是初始化eureka client的一些调度任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// InstanceInfo replicator</span></span><br><span class="line">    <span class="comment">// 创建服务拷贝副本</span></span><br><span class="line">    instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            instanceInfo,</span><br><span class="line">            clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">            <span class="number">2</span>); <span class="comment">// burstSize</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程 InitialInstanceInfoReplicationIntervalSeconds默认为40s</span></span><br><span class="line">    instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面仍然是DiscoveryClient中的源码，看方法名我们知道这里肯定是初始化EurekaClient启动时的相关定时任务的。<br> 这里主要是截取了<code>instanceInfoReplicator</code>初始化和执行<code>instanceInfoReplicator.start</code>的任务，</p>
<p>接着我们就可以顺着这个线先看看<code>InstatnceInfoReplicator</code>是何方神圣？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A task for updating and replicating the local instanceinfo to the remote server. Properties of this task are:</span></span><br><span class="line"><span class="comment"> * - configured with a single update thread to guarantee sequential update to the remote server</span></span><br><span class="line"><span class="comment"> * - update tasks can be scheduled on-demand via onDemandUpdate()</span></span><br><span class="line"><span class="comment"> * - task processing is rate limited by burstSize</span></span><br><span class="line"><span class="comment"> * - a new update task is always scheduled automatically after an earlier update task. However if an on-demand task</span></span><br><span class="line"><span class="comment"> *   is started, the scheduled automatic update task is discarded (and a new one will be scheduled after the new</span></span><br><span class="line"><span class="comment"> *   on-demand update).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于将本地instanceinfo更新和复制到远程服务器的任务。此任务的属性是：</span></span><br><span class="line"><span class="comment"> * -配置有单个更新线程以保证对远程服务器的顺序更新</span></span><br><span class="line"><span class="comment"> * -可以通过onDemandUpdate（）按需调度更新任务</span></span><br><span class="line"><span class="comment"> * -任务处理的速率受burstSize的限制</span></span><br><span class="line"><span class="comment"> * -新更新总是在较早的更新任务之后自动计划任务。但是，如果启动了按需任务*，则计划的自动更新任务将被丢弃（并且将在新的按需更新之后安排新的任务）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个关键点：</p>
<ol>
<li>此类实现了<code>Runnable</code>接口，说白了就是执行一个异步线程</li>
<li>该类作用是：用于将本地instanceinfo更新和复制到远程服务器的任务</li>
</ol>
<p>看完这两点，我又不禁陷入思考，我找的是eurekaClient注册过程，咋还跑到这个里面来了？不甘心，于是继续往下看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InstanceInfoReplicator.start()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initialDelayMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        instanceInfo.setIsDirty();  <span class="comment">// for initial register</span></span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, initialDelayMs, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个scheduler是一个调度任务线程池，会将this线程放入到线程池中，然后再指定时间后执行该线程的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InstanceInfoReplicator.run()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 刷新一下服务实例信息</span></span><br><span class="line">        discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">        <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            discoveryClient.register();</span><br><span class="line">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里是不是有种豁然开朗的感觉？看到了<code>register</code>就感觉到希望来了，这里使用的是DiscoveryClient.register方法，其实这里我们也可以先找DiscoveryClient中的register方法，然后再反查调用方，这也是一种好的思路呀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryClient.register</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    logger.info(PREFIX + appPathIdentifier + <span class="string">": registering service..."</span>);</span><br><span class="line">    EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 回看eurekaTransport创建及初始化过程</span></span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, PREFIX + appPathIdentifier, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是使用eurekaTransport.registrationClient去进行注册，我们在最开始DiscoveryClient构造方法中已经截取了eurekaTransport创建及初始化代码，这里再贴一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持底层的eureka client跟eureka server进行网络通信的组件</span></span><br><span class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line"><span class="comment">// 发送http请求，调用restful接口</span></span><br><span class="line">scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略大量代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要抓取注册表，读取其他server的注册信息</span></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        EurekaHttpClientFactory newRegistrationClientFactory = <span class="keyword">null</span>;</span><br><span class="line">        EurekaHttpClient newRegistrationClient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newRegistrationClientFactory = EurekaHttpClients.registrationClientFactory(</span><br><span class="line">                    eurekaTransport.bootstrapResolver,</span><br><span class="line">                    eurekaTransport.transportClientFactory,</span><br><span class="line">                    transportConfig</span><br><span class="line">            );</span><br><span class="line">            newRegistrationClient = newRegistrationClientFactory.newClient();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Transport initialization failure"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将newRegistrationClient放入到eurekaTransport中</span></span><br><span class="line">        eurekaTransport.registrationClientFactory = newRegistrationClientFactory;</span><br><span class="line">        eurekaTransport.registrationClient = newRegistrationClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里，可以看到eurekaTransport.registrationClient实际就是<code>EurekaHttpClient</code>，不知道是我没找对地方还是什么原因，我并没有找到具体执行的实现类。</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191228124301728-2031115897.png" alt="image.png"></p>
<p>最后网上查了下，具体执行的实现类是：<code>AbstractJersey2EurekaHttpClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractJersey2EurekaHttpClient.register()</span><br><span class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">        String urlPath = <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line">        Response response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送请求，类似于：http://localhost:8080/v2/apps/ServiceA</span></span><br><span class="line">            <span class="comment">// 发送的是post请求，服务实例的对象被打成了一个json发送，包括自己的主机、ip、端口号</span></span><br><span class="line">            <span class="comment">// eureka server 就知道了这个ServiceA这个服务，有一个服务实例，比如是在192.168.31.109、host-01、8761端口</span></span><br><span class="line">            Builder resourceBuilder = jerseyClient.target(serviceUrl).path(urlPath).request();</span><br><span class="line">            addExtraProperties(resourceBuilder);</span><br><span class="line">            addExtraHeaders(resourceBuilder);</span><br><span class="line">            response = resourceBuilder</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .acceptEncoding(<span class="string">"gzip"</span>)</span><br><span class="line">                    .post(Entity.json(info));</span><br><span class="line">            <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Jersey2 HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                        response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到了这里就已经真相大白了，可是 读了一通发现这个代码实在是不好理解，最后再总结一波才行。。。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）DiscoveryClient构造函数会初始化EurekaClient相关的定时任务，定时任务里面会启动instanceInfo 互相复制的任务，就是InstanceInfoReplicator中的start()</p>
<p>（2）InstanceInfoReplicator的start()方法里面，将自己作为一个线程放到一个调度线程池中去了，默认是延迟40s去执行这个线程，还将isDirty设置为了ture</p>
<p>（3）如果执行线程的时候，是执行run()方法，线程</p>
<p>（3）先是找EurekaClient.refreshInstanceInfo()这个方法，里面其实是调用ApplicationInfoManager的一些方法刷新了一下服务实例的配置，看看配置有没有改变，如果改变了，就刷新一下；用健康检查器，检查了一下状态，将状态设置到了ApplicationInfoManager中去，更新服务实例的状态</p>
<p>（4）因为之前设置过isDirty，所以这里会执行进行服务注册</p>
<p>（5）服务注册的时候，是基于EurekaClient的reigster()方法去注册的，调用的是底层的TransportClient的RegistrationClient，执行了register()方法，将InstanceInfo服务实例的信息，通过http请求，调用eureka  server对外暴露的一个restful接口，将InstanceInfo给发送了过去。这里找的是EurekaTransport，在构造的时候，调用了scheduleServerEndpointTask()方法，这个方法里就初始化了专门用于注册的RegistrationClient。</p>
<p>（6）找SessionedEurekaHttpClient调用register()方法，去进行注册，底层最终使用的AbstractJersey2EurekaHttpClient的register方法实现的</p>
<p>（7）eureka大量的基于jersey框架，在eureka server上提供restful接口，在eureka client如果要发送请求到eureka server的话，一定是基于jersey框架，去发送的http restful接口调用的请求</p>
<p>（8）真正执行注册请求的，就是eureka-client-jersey2工程里的AbstractJersey2EurekaHttpClient，请求<a href="http://localhost:8080/v2/apps/ServiceA，将服务实例的信息发送过去" target="_blank" rel="noopener">http://localhost:8080/v2/apps/ServiceA，将服务实例的信息发送过去</a></p>
<p>eureka client这一块，在服务注册的这块代码，很多槽点：</p>
<p>（1）服务注册，不应该放在InstanceInfoReplicator里面，语义不明朗</p>
<p>（2）负责发送请求的HttpClient，类体系过于复杂，导致人根本就找不到对应的Client，最后是根据他是使用jersey框架来进行restful接口暴露和调用，才能连蒙带猜，找到真正发送服务注册请求的地方</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码四：EurekaClient启动要经历哪些艰难险阻？</title>
    <url>/2020/01/04/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E5%9B%9B%EF%BC%9AEurekaClient%E5%90%AF%E5%8A%A8%E8%A6%81%E7%BB%8F%E5%8E%86%E5%93%AA%E4%BA%9B%E8%89%B0%E9%9A%BE%E9%99%A9%E9%98%BB%EF%BC%9F%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码四：EurekaClient启动要经历哪些艰难险阻？"><a href="#Nexflix-Eureka-源码四：EurekaClient启动要经历哪些艰难险阻？" class="headerlink" title="[Nexflix Eureka 源码四：EurekaClient启动要经历哪些艰难险阻？]"></a>[Nexflix Eureka 源码四：EurekaClient启动要经历哪些艰难险阻？]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在源码分析三、四都有提及到EurekaClient启动的一些过程。因为EurekaServer在集群模式下 自己本身就是一个client，所以之前初始化eurekaServerContext就有涉及到eurekaClient的初始化。</p>
<p>我们也看了EurekaClient（DiscoveryClient）初始化的过程，繁杂的启动过程让人眼花缭乱，这篇文章就专门来唠唠 里面经历的一些艰难险阻。这也会是后面client注册的一个前置文章。</p>
<a id="more"></a>

<h3 id="从ExampleEurekaClient开始说起"><a href="#从ExampleEurekaClient开始说起" class="headerlink" title="从ExampleEurekaClient开始说起"></a>从ExampleEurekaClient开始说起</h3><p>在第一讲我们就说过，eureka项目有一个examples模块的，现在看一下其中的EurekaClientExample对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleEurekaClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationInfoManager applicationInfoManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ApplicationInfoManager <span class="title">initializeApplicationInfoManager</span><span class="params">(EurekaInstanceConfig instanceConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationInfoManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            InstanceInfo instanceInfo = <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();</span><br><span class="line">            applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(instanceConfig, instanceInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> applicationInfoManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> EurekaClient <span class="title">initializeEurekaClient</span><span class="params">(ApplicationInfoManager applicationInfoManager, EurekaClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequestToServiceUsingEureka</span><span class="params">(EurekaClient eurekaClient)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialize the client</span></span><br><span class="line">        <span class="comment">// this is the vip address for the example service to talk to as defined in conf/sample-eureka-service.properties</span></span><br><span class="line">        String vipAddress = <span class="string">"sampleservice.mydomain.net"</span>;</span><br><span class="line"></span><br><span class="line">        InstanceInfo nextServerInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Cannot get an instance of example service to talk to from eureka"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Found an instance of example service to talk to from eureka: "</span></span><br><span class="line">                + nextServerInfo.getVIPAddress() + <span class="string">":"</span> + nextServerInfo.getPort());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"healthCheckUrl: "</span> + nextServerInfo.getHealthCheckUrl());</span><br><span class="line">        System.out.println(<span class="string">"override: "</span> + nextServerInfo.getOverriddenStatus());</span><br><span class="line"></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line">        <span class="keyword">int</span> serverPort = nextServerInfo.getPort();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.connect(<span class="keyword">new</span> InetSocketAddress(nextServerInfo.getHostName(), serverPort));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Could not connect to the server :"</span></span><br><span class="line">                    + nextServerInfo.getHostName() + <span class="string">" at port "</span> + serverPort);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Could not connect to the server :"</span></span><br><span class="line">                    + nextServerInfo.getHostName() + <span class="string">" at port "</span> + serverPort + <span class="string">"due to Exception "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String request = <span class="string">"FOO "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">            System.out.println(<span class="string">"Connected to server. Sending a sample request: "</span> + request);</span><br><span class="line"></span><br><span class="line">            PrintStream out = <span class="keyword">new</span> PrintStream(s.getOutputStream());</span><br><span class="line">            out.println(request);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Waiting for server response.."</span>);</span><br><span class="line">            BufferedReader rd = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">            String str = rd.readLine();</span><br><span class="line">            <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Received response from server: "</span> + str);</span><br><span class="line">                System.out.println(<span class="string">"Exiting the client. Demo over.."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            rd.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        injectEurekaConfiguration();</span><br><span class="line">        ExampleEurekaClient sampleClient = <span class="keyword">new</span> ExampleEurekaClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MyDataCenterInstanceConfig 就是加载eureka-client.properties配置信息,形成一个服务实例的配置EurekaInstanceConfig</span></span><br><span class="line">        <span class="comment">// 基于EurekaClient配置，构造了一个服务实例（InstanceInfo）</span></span><br><span class="line">        <span class="comment">// 基于eureka client配置和服务实例，构造了一个服务实例管理器（ApplicationInfoManager）</span></span><br><span class="line">        <span class="comment">// 读取eureka-client.properties配置文件，形成了一个eureka client的配置，接口对外提供eureka client的配置项的读取</span></span><br><span class="line">        <span class="comment">// 基于eureka client的配置，和服务实例管理器，来构造了一个EurekaClient（DiscoveryClient</span></span><br><span class="line">        <span class="comment">// ），保存了一些配置，处理服务的注册和注册表的抓取，启动了几个线程池，启动了网络通信组件，启动了一些调度任务，注册了监控项</span></span><br><span class="line">        ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(<span class="keyword">new</span> MyDataCenterInstanceConfig());</span><br><span class="line">        EurekaClient client = initializeEurekaClient(applicationInfoManager, <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the client</span></span><br><span class="line">        sampleClient.sendRequestToServiceUsingEureka(client);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// shutdown the client</span></span><br><span class="line">        eurekaClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This will be read by server internal discovery client. We need to salience it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEurekaConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        String myHostName = InetAddress.getLocalHost().getHostName();</span><br><span class="line">        String myServiceUrl = <span class="string">"http://"</span> + myHostName + <span class="string">":8080/v2/"</span>;</span><br><span class="line"></span><br><span class="line">        System.setProperty(<span class="string">"eureka.region"</span>, <span class="string">"default"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.name"</span>, <span class="string">"eureka"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.vipAddress"</span>, <span class="string">"eureka.mydomain.net"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.port"</span>, <span class="string">"8080"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.preferSameZone"</span>, <span class="string">"false"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.shouldUseDns"</span>, <span class="string">"false"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.shouldFetchRegistry"</span>, <span class="string">"true"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.serviceUrl.defaultZone"</span>, myServiceUrl);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.serviceUrl.default.defaultZone"</span>, myServiceUrl);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.awsAccessId"</span>, <span class="string">"fake_aws_access_id"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.awsSecretKey"</span>, <span class="string">"fake_aws_secret_key"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"eureka.numberRegistrySyncRetries"</span>, <span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们从main函数开始看起：</p>
<ol>
<li>注入eureka配置信息：<code>injectEurekaConfiguration();</code></li>
<li>读取eureka-client.properties配置文件，形成一个服务器实例的配置，基于接口对外提供实例的配置项读取<br> 这里就是涉及到我么你之前讲解的<code>DynamicPropertyFactory</code>和<code>ConfigurationManager</code>,这里可以查看<code>new MyDataCenterInstanceConfig()</code>然后一步步往后跟。</li>
<li>基于服务实例的配置，构造了一个服务实例（InstanceInfo）。<code>initializeApplicationInfoManager</code>中会构建InstanceInfo信息</li>
<li>基于服务实例的配置和服务实例，初始化服务实例管理器（ApplicationInfoManager）</li>
<li>基于eureka client配置，和服务实例管理器，来构造了一个EurekaClient（DiscoveryClient），保存了一些配置，处理服务的注册和注册表的抓取，启动了几个线程池，启动了网络通信组件，启动了一些调度任务，注册了监控项<br> 具体可查看 <code>EurekaClient client = initializeEurekaClient(applicationInfoManager, new DefaultEurekaClientConfig());</code></li>
</ol>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191227111631564-1145037618.png" alt="02_Eureka_Client启动流程图.png"></p>
<h3 id="申明"><a href="#申明" class="headerlink" title="申明"></a>申明</h3>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码三：EurekaServer启动之完成上下文构建及EurekaServer总结</title>
    <url>/2020/01/03/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E4%B8%89%EF%BC%9AEurekaServer%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%AE%8C%E6%88%90%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9E%84%E5%BB%BA%E5%8F%8AEurekaServer%E6%80%BB%E7%BB%93%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码三：EurekaServer启动之完成上下文构建及EurekaServer总结"><a href="#Nexflix-Eureka-源码三：EurekaServer启动之完成上下文构建及EurekaServer总结" class="headerlink" title="[Nexflix Eureka 源码三：EurekaServer启动之完成上下文构建及EurekaServer总结]"></a>[Nexflix Eureka 源码三：EurekaServer启动之完成上下文构建及EurekaServer总结]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上篇文章已经介绍了 Eureka Server上下文创建相关的Eureka Client逻辑，这一部分还是比较复杂的。接下来就讲解下Eureka Server上下文初始化最后的部分，然后加上整个Eureka Server启动的总结。</p>
<a id="more"></a>

<h3 id="initEurekaServerContext"><a href="#initEurekaServerContext" class="headerlink" title="initEurekaServerContext"></a>initEurekaServerContext</h3><p>EurekaBootStrap.initEurekaServerContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 省略之前内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、处理注册相关的事情  下面是拆解单词加深理解：</span></span><br><span class="line">    <span class="comment">// PeerAware:可以识别eureka server集群的。多个同样的东西组成一个集群，peers：集群，peer就是集群中的一个实例</span></span><br><span class="line">    <span class="comment">// InstanceRegistry:实例注册，服务实例注册。注册表，这个里面放了所有的主车道这个eureka server上的服务实例，就是一个服务实例的注册表。</span></span><br><span class="line">    <span class="comment">// PeerAwareInstanceRegistry：可以感知eureka server集群的服务实例注册表，eureka client(作为服务实例)过来注册的注册表，而且这个注册表是可以感知到eureka</span></span><br><span class="line">    <span class="comment">// server集群的，假如有一个eureka server集群的话，这里包含了其他eureka server中的服务实例注册表信息的。</span></span><br><span class="line">    PeerAwareInstanceRegistry registry;</span><br><span class="line">    <span class="keyword">if</span> (isAws(applicationInfoManager.getInfo())) &#123;</span><br><span class="line">        registry = <span class="keyword">new</span> AwsInstanceRegistry(</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                eurekaClient</span><br><span class="line">        );</span><br><span class="line">        awsBinder = <span class="keyword">new</span> AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);</span><br><span class="line">        awsBinder.start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建PeerAwareInstanceRegistry。最近取消的实例，最近注册的实例都会保存到registry中</span></span><br><span class="line">        registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                eurekaClient</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、处理peer节点相关的事情</span></span><br><span class="line">    <span class="comment">// peerEurekaNodes 代表了eureka server集群，peers大概来说是多个相同的实例组成的一个集群，peer就是peers中的一个实例</span></span><br><span class="line">    <span class="comment">// PeerEurekaNodes，代表的是eureka server集群</span></span><br><span class="line">    PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">            registry,</span><br><span class="line">            eurekaServerConfig,</span><br><span class="line">            eurekaClient.getEurekaClientConfig(),</span><br><span class="line">            serverCodecs,</span><br><span class="line">            applicationInfoManager</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、完成eureka-server上下文(context)的构建及初始化</span></span><br><span class="line">    serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</span><br><span class="line">            eurekaServerConfig,</span><br><span class="line">            serverCodecs,</span><br><span class="line">            registry,</span><br><span class="line">            peerEurekaNodes,</span><br><span class="line">            applicationInfoManager</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上下文信息放到holder中</span></span><br><span class="line">    EurekaServerContextHolder.initialize(serverContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将eureka server集群启动起来。里面会更新eureka server集群的信息，让当前的eureka server感知到所有的其他eureka server</span></span><br><span class="line">    <span class="comment">// 然后搞一个定时调度任务，就是一个后台线程，每隔一段时间，更新eureka server集群的信息</span></span><br><span class="line">    <span class="comment">// registry.init: 基于eureka server集群的信息，来初始化注册表，将eureka server集群中所有的eureka</span></span><br><span class="line">    <span class="comment">// server的注册表信息抓取过来，放到自己本地的注册表中。都是跟eureka server集群中之间的注册表信息互换有关联的</span></span><br><span class="line">    serverContext.initialize();</span><br><span class="line">    logger.info(<span class="string">"Initialized server context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></span><br><span class="line">    <span class="comment">// 6、处理一些善后的事情，从相邻的eureka节点拷贝注册信息</span></span><br><span class="line">    <span class="comment">// registry.syncUp()： 从相邻的一个eureka server节点拷贝注册表信息，如果拷贝失败，就找下一个</span></span><br><span class="line">    <span class="keyword">int</span> registryCount = registry.syncUp();</span><br><span class="line">    registry.openForTraffic(applicationInfoManager, registryCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register all monitoring statistics.</span></span><br><span class="line">    <span class="comment">// 7、注册所有的监控统计项</span></span><br><span class="line">    EurekaMonitors.registerAllStats();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里备注比较多，基本上是每个方法 实现的目的，并没有进一步跟踪细节问题，还是之前讲到的，看源码还是要抓大放小，我们尽量先把主流程搞清楚，然后再去一步步攻克细节。</p>
<h3 id="EurekaServer启动流程总结"><a href="#EurekaServer启动流程总结" class="headerlink" title="EurekaServer启动流程总结"></a>EurekaServer启动流程总结</h3><p>到这里 eureka server启动的相关代码就看完了，下面有一张流程图来总结一下的：</p>
<p><img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191226100224554-852172976.png" alt="01_EurekaServer启动流程图.png"></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码二：EurekaServer启动之EurekaServer上下文EurekaClient创建</title>
    <url>/2020/01/02/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E4%BA%8C%EF%BC%9AEurekaServer%E5%90%AF%E5%8A%A8%E4%B9%8BEurekaServer%E4%B8%8A%E4%B8%8B%E6%96%87EurekaClient%E5%88%9B%E5%BB%BA%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码二：EurekaServer启动之EurekaServer上下文EurekaClient创建"><a href="#Nexflix-Eureka-源码二：EurekaServer启动之EurekaServer上下文EurekaClient创建" class="headerlink" title="[Nexflix Eureka 源码二：EurekaServer启动之EurekaServer上下文EurekaClient创建]"></a>[Nexflix Eureka 源码二：EurekaServer启动之EurekaServer上下文EurekaClient创建]</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上篇文章已经介绍了 Eureka Server  环境和上下文初始化的一些代码，其中重点讲解了environment初始化使用的单例模式，以及EurekaServerConfigure基于接口对外暴露配置方法的设计方式。这一讲就是讲解Eureka Server上下文初始化剩下的内容：Eureka Client初始化。</p>
<a id="more"></a>

<h3 id="EurekaServer上下文构建之Client"><a href="#EurekaServer上下文构建之Client" class="headerlink" title="EurekaServer上下文构建之Client"></a>EurekaServer上下文构建之Client</h3><h4 id="EurekaClientConfigure创建过程"><a href="#EurekaClientConfigure创建过程" class="headerlink" title="EurekaClientConfigure创建过程"></a>EurekaClientConfigure创建过程</h4><p>因为eurekaSever是集群部署的，所以每个eurekaServer都需要注册到其他注册中心节点。这里自己既是一个eurekaServer，也是一个eurekaClient。</p>
<p>截取EurekaServer中初始化上下文代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3、初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点做注册和通信）</span></span><br><span class="line"><span class="comment">// 类的开头已经说明了：EurekaInstanceConfig其实就是eureka client相关的配置类</span></span><br><span class="line"><span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">    EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">            ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">            : <span class="keyword">new</span> MyDataCenterInstanceConfig();</span><br><span class="line">    </span><br><span class="line">    applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</span><br><span class="line">            instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DefaultEurekaClientConfig类似于上面的DefaultEurekaServerConfig类实现</span></span><br><span class="line">    EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">    eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    applicationInfoManager = eurekaClient.getApplicationInfoManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下eurekaClientConfig创建的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaClientConfig</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</span><br><span class="line">            ? namespace</span><br><span class="line">            : namespace + <span class="string">"."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</span><br><span class="line">    <span class="keyword">this</span>.transportConfig = <span class="keyword">new</span> DefaultEurekaTransportConfig(namespace, configInstance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicPropertyFactory <span class="title">initConfig</span><span class="params">(String configName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取eureka client配置文件，类似于 &#123;<span class="doctag">@link</span> DefaultEurekaServerConfig&#125;中的：</span></span><br><span class="line"><span class="comment">     * String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span></span><br><span class="line"><span class="comment">     * private static final DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory</span></span><br><span class="line"><span class="comment">     *             .getInstance().getStringProperty("eureka.server.props","eureka-server");</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty(<span class="string">"eureka.client.props"</span>, configName);</span><br><span class="line"></span><br><span class="line">    String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, <span class="string">"test"</span>);</span><br><span class="line">    ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</span><br><span class="line"></span><br><span class="line">    String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.warn(</span><br><span class="line">                <span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></span><br><span class="line">                        + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>,</span><br><span class="line">                eurekaPropsFile);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到上面代码想到了什么？这完全跟EurekaServerConfig创建的逻辑一样的呀，代码和DefaultEurekaServerConfig一致的逻辑。最后都是交给ConfigurationManager来管理。</p>
<h4 id="EurekaClient创建过程"><a href="#EurekaClient创建过程" class="headerlink" title="EurekaClient创建过程"></a>EurekaClient创建过程</h4><p>接着再来看<code>eurekaClient = new DiscoveryClient(applicationInfoManager, eurekaClientConfig);</code>代码：</p>
<p>这段代码确实很长，我们一段段来解读，解读完后再看代码：</p>
<ol>
<li><p>基于<code>ApplicationInfoManager</code>（包含了服务实例的信息、配置，作为服务实例管理的一个组件），eureka client相关的配置，一起构建了一个EurekaClient。</p>
</li>
<li><p>这里有两个配置：<code>config.shouldFetchRegistry()</code>和<code>config.shouldRegisterWithEureka()</code></p>
<p><code>config.shouldFetchRegistry()</code>：<br> 是否需要注册到别的注册中心。eurekaServer有个配置：eureka.client.fetchRegistry，单机情况下为false。false表示自己就是注册中心。我的职责就是维护服务实例，并不需要去检索服务</p>
<p><code>config.shouldRegisterWithEureka()</code>：<br> 是否要向别的注册中心注册自己。eurekaServer有个配置：eureka.client.registerWithEureka，单机情况下为false。false表示自己不需要向注册中心注册自己</p>
</li>
<li><p>创建线程池调度任务</p>
</li>
<li><p>创建一个心跳线程池</p>
</li>
<li><p>创建一个缓存刷新线程池</p>
</li>
<li><p>初始化线程调度任务</p>
</li>
</ol>
<p>具体代码如下，添加了一些代码备注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.healthCheckHandlerProvider = args.healthCheckHandlerProvider;</span><br><span class="line">        <span class="keyword">this</span>.healthCheckCallbackProvider = args.healthCheckCallbackProvider;</span><br><span class="line">        <span class="keyword">this</span>.eventListeners.addAll(args.getEventListeners());</span><br><span class="line">        <span class="keyword">this</span>.preRegistrationHandler = args.preRegistrationHandler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.healthCheckCallbackProvider = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.healthCheckHandlerProvider = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.preRegistrationHandler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</span><br><span class="line">    InstanceInfo myInfo = applicationInfoManager.getInfo();</span><br><span class="line"></span><br><span class="line">    clientConfig = config;</span><br><span class="line">    staticClientConfig = clientConfig;</span><br><span class="line">    transportConfig = config.getTransportConfig();</span><br><span class="line">    instanceInfo = myInfo;</span><br><span class="line">    <span class="keyword">if</span> (myInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// AppName是服务名称，instanceInfo.getId就是服务实例id，类似于：ServiceA/0001</span></span><br><span class="line">        appPathIdentifier = instanceInfo.getAppName() + <span class="string">"/"</span> + instanceInfo.getId();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.warn(<span class="string">"Setting instanceInfo to a passed in null value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.backupRegistryProvider = backupRegistryProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.urlRandomizer = <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);</span><br><span class="line">    localRegionApps.set(<span class="keyword">new</span> Applications());</span><br><span class="line"></span><br><span class="line">    fetchRegistryGeneration = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    remoteRegionsToFetch = <span class="keyword">new</span> AtomicReference&lt;String&gt;(clientConfig.fetchRegistryForRemoteRegions());</span><br><span class="line">    remoteRegionsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == <span class="keyword">null</span> ? <span class="keyword">null</span> : remoteRegionsToFetch.get().split(<span class="string">","</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要注册到别的注册中心。eurekaServer有个配置：eureka.client.fetchRegistry，单机情况下为false。false表示自己就是注册中心。我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="keyword">if</span> (config.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.registryStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="string">"lastUpdateSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eurekaServer有个配置：eureka.client.registerWithEureka，单机情况下为false。false表示自己不需要向注册中心注册自己</span></span><br><span class="line">    <span class="keyword">if</span> (config.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="string">"lastHeartbeatSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"Initializing Eureka in region &#123;&#125;"</span>, clientConfig.getRegion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要注册也不需要抓取 释放不必要的资源</span></span><br><span class="line">    <span class="keyword">if</span> (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Client configured to neither register nor query for data."</span>);</span><br><span class="line">        scheduler = <span class="keyword">null</span>;</span><br><span class="line">        heartbeatExecutor = <span class="keyword">null</span>;</span><br><span class="line">        cacheRefreshExecutor = <span class="keyword">null</span>;</span><br><span class="line">        eurekaTransport = <span class="keyword">null</span>;</span><br><span class="line">        instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(<span class="keyword">new</span> PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></span><br><span class="line">        <span class="comment">// to work with DI'd DiscoveryClient</span></span><br><span class="line">        DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</span><br><span class="line">        DiscoveryManager.getInstance().setEurekaClientConfig(config);</span><br><span class="line"></span><br><span class="line">        initTimestampMs = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</span><br><span class="line">                initTimestampMs, <span class="keyword">this</span>.getApplications().size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// no need to setup up an network tasks and we are done</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></span><br><span class="line">        <span class="comment">// 创建一个支持调度的线程池</span></span><br><span class="line">        scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                        .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</span><br><span class="line">                        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">                        .build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个心跳检查的线程池，最大线程数为5</span></span><br><span class="line">        heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                        .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</span><br><span class="line">                        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">                        .build()</span><br><span class="line">        );  <span class="comment">// use direct handoff</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 支持缓存刷新的线程池，最大线程数为5</span></span><br><span class="line">        cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                        .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</span><br><span class="line">                        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">                        .build()</span><br><span class="line">        );  <span class="comment">// use direct handoff</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 支持底层的eureka client跟eureka server进行网络通信的组件</span></span><br><span class="line">        eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line">        <span class="comment">// 发送http请求，调用restful接口</span></span><br><span class="line">        scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line"></span><br><span class="line">        AzToRegionMapper azToRegionMapper;</span><br><span class="line">        <span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</span><br><span class="line">            azToRegionMapper = <span class="keyword">new</span> DNSBasedAzToRegionMapper(clientConfig);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            azToRegionMapper = <span class="keyword">new</span> PropertyBasedAzToRegionMapper(clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsToFetch.get()) &#123;</span><br><span class="line">            azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(<span class="string">","</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to initialize DiscoveryClient!"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要抓取注册表，但是抓取失败后，需要从备份中读取</span></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">        fetchRegistryFromBackup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call and execute the pre registration handler before all background tasks (inc registration) is started</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.preRegistrationHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.preRegistrationHandler.beforeRegistration();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化调度任务</span></span><br><span class="line">    initScheduledTasks();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Monitors.registerObject(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Cannot register timers"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></span><br><span class="line">    <span class="comment">// to work with DI'd DiscoveryClient</span></span><br><span class="line">    DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</span><br><span class="line">    DiscoveryManager.getInstance().setEurekaClientConfig(config);</span><br><span class="line"></span><br><span class="line">    initTimestampMs = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</span><br><span class="line">            initTimestampMs, <span class="keyword">this</span>.getApplications().size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes all scheduled tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抓取注册表的定时任务，</span></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="comment">// registry cache refresh timer</span></span><br><span class="line">        <span class="comment">// registryFetchIntervalSeconds默认为30s</span></span><br><span class="line">        <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        <span class="comment">// 执行cacheRefreshExecutor调度任务，默认是30s</span></span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"cacheRefresh"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        cacheRefreshExecutor,</span><br><span class="line">                        registryFetchIntervalSeconds,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> CacheRefreshThread()</span><br><span class="line">                ),</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要将自己注册到其他注册中心</span></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="comment">//  默认也是30s</span></span><br><span class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Heartbeat timer</span></span><br><span class="line">        <span class="comment">// 执行heartbeatExecutor心跳检查，默认是30s</span></span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"heartbeat"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        heartbeatExecutor,</span><br><span class="line">                        renewalIntervalInSecs,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                ),</span><br><span class="line">                renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InstanceInfo replicator</span></span><br><span class="line">        <span class="comment">// 创建服务副本传播器</span></span><br><span class="line">        instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                instanceInfo,</span><br><span class="line">                clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                <span class="number">2</span>); <span class="comment">// burstSize</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建服务实例状态变更的监听器</span></span><br><span class="line">        statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">                        InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                    <span class="comment">// log at warn level if DOWN was involved</span></span><br><span class="line">                    logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">                &#125;</span><br><span class="line">                instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">            applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行线程</span></span><br><span class="line">        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果是eureka server的话，我们在玩儿spring  cloud的时候，会将这个fetchRegistry给手动设置为false，如果是eureka  server集群的话，就还是要保持为true。registerWithEureka也要设置为true。</p>
<p>（1）读取EurekaClientConfig，包括TransportConfig<br> （2）保存EurekaInstanceConfig和InstanceInfo<br> （3）处理了是否要注册以及抓取注册表，如果不要的话，释放一些资源<br> （4）支持调度的线程池<br> （5）支持心跳的线程池<br> （6）支持缓存刷新的线程池<br> （7）EurekaTransport，支持底层的eureka client跟eureka server进行网络通信的组件，对网络通信组件进行了一些初始化的操作<br> （8）如果要抓取注册表的话，在这里就会去抓取注册表了，但是如果说你配置了不抓取，那么这里就不抓取了<br> （9）初始化调度任务：如果要抓取注册表的话，就会注册一个定时任务，按照你设定的那个抓取的间隔，每隔一定时间（默认是30s），去执行一个CacheRefreshThread，给放那个调度线程池里去了；如果要向eureka  server进行注册的话，会搞一个定时任务，每隔一定时间发送心跳，执行一个HeartbeatThread；创建了服务实例副本传播器，将自己作为一个定时任务进行调度；创建了服务实例的状态变更的监听器，如果你配置了监听，那么就会注册监听器</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>unicode编码</title>
    <url>/2020/01/01/unicode%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><p>这个世界上从来没有纯文本这回事，如果你想读出一个字符串，你必须知道它的编码。</p>
</li>
<li><p>Unicode是一个简单的标准，用来把字符映射到数字上。Unicode协会的人会帮你处理所有幕后的问题，包括为新字符指定编码。</p>
</li>
<li><p>Unicode并不告诉你字符是怎么编码成字节的。这是被编码方案决定的，通过UTF来指定。</p>
</li>
</ol>
<p>还有最重要的：</p>
<ol start="4">
<li><p>永远记得通过Content-Type或者meta charset标签来显式指定你的文档的编码。这样浏览器就不需要猜测你使用的编码了，他们会准确的使用你指定的编码来渲染文档。</p>
<a id="more"></a>

</li>
</ol>
<p>计算机内只有0，1，使用0，1的组合来表示各种事务</p>
<p>ASCALL码，有8位，首位统一规定为0，那么，就是可以表示128个字符，在英文中是够了，对于其他语言远远不够，人们开始利用首位的1来表示更多的字符，这样就能表示256个字符，但是每个国家所要表示的字符不一样，中国需要表示汉字，别的国家不需要啊。所以在俄罗斯144可能表示‘ђ’，在阿拉伯可能表示 ‘گ’。而且中国的汉字太多了，256根本不能满足，所以人们开始用2个字节来表示字符。如果想把软件卖到国外，那么就需要一张内码表，转换为相应国家的字符。</p>
<p>UNICODE码，unicode的思想很简单，只是为每个字符都规定一个用来表示该字符的数字，just that。它不涉及到字符的存储，所以需要引入utf编码来帮助unicode字符的存储。那么问题来了。unicode中字符有些是1个字节，有些是2个字节。比如你给了2个字节，计算机如何知道你这2个字节表示的是一个字符还是两个字符呢？解决方案有一：假设unicode一共是4个字节这么大， 那直接用4个字节来表示一个字符不就完美统一了吗？计算机每次都会读4个字节然后解析得到相应的字符。但是这样产生了一个问题，那就是存储空间的浪费，如果是一个英文文档（只用一个字节来表示即可），活生生大了三倍。</p>
<p>utf-8，utf-16横空出世。它会为机器编码为不定长度，节省空间且向后兼容</p>
]]></content>
  </entry>
  <entry>
    <title>网页无法播放h265格式视频</title>
    <url>/2019/12/31/%E7%BD%91%E9%A1%B5%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BEh265%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前一段时间，运营同学频频跟我们说，在后台管理有几个文章中都存在着视频显示为音频无法在H5上播放的问题，部分存在在ios客户端打开视频为黑屏状态</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>查看这几个视频的编码，发现是H265，而正常显示的视频编码为H264。经查询资料后发现：H265是一个新的视频编码标准，它的压缩效率，鲁棒性以及错误恢复能力都相较于H264高。但是在chrome中是暂不支持这种视频格式的，且在客户端中的支持情况也是对旧版本不支持：</p>
<p>ios:phone7 ↑ 等</p>
<p>Android:5.0 ↑ 等</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>需要在视频上传时进行转码处理，后台接收到视频时，触发一个异步任务，将视频交由阿里云[媒体处理]，阿里云[媒体处理]会根据传过去的视频，进行转码从而生成一个H264格式的视频。</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://segmentfault.com/a/1190000017187346?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017187346?utm_source=tag-newest </a></p>
]]></content>
  </entry>
  <entry>
    <title>.class打开显示泛型</title>
    <url>/2019/12/31/class%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%98%BE%E7%A4%BA%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>编写了一个java文件，文件中有泛型，但在编译后，用idea打开，竟然还显示泛型，觉得蛮奇怪的。</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>之前看过，编译过后泛型是肯定会消失的，那么有可能是idea反编译器太智能了…</p>
<p>##解决</p>
<p>下载Beyond Compare来查看.class文件，查看确实没有泛型了。那为什么idea的反编译工具能解析得到泛型呢？使用java自带的反编译工具javap -c 来进行反编译，得到：</p>
<p><img src="/2019/12/31/class%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%98%BE%E7%A4%BA%E6%B3%9B%E5%9E%8B/fanxing.jpg" alt="img"></p>
<p>虽然不是很能看懂java自带的反编译工具编译出来的结果，但是可以得到的结论是，从不同的反编译工具中可以看出，至少反编译工具是可以从class文件中找到你之前使用的泛型的，证明文件中是存在标记来记录这个泛型的，然后从javap中我们可以看出，虽然泛型不在代码中了，但是他还是记录在了注释中，这样就可以解释通为什么有的反编译工具可以反显示泛型了。</p>
]]></content>
  </entry>
  <entry>
    <title>emoji表情md5签名不一致</title>
    <url>/2019/12/31/emoji%E8%A1%A8%E6%83%85md5%E7%AD%BE%E5%90%8D%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>和前端同学在联调时，发现只要传了emoji都会报签名不一致的问题。猜测是签名的算法不同导致的。</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>###Md5计算过程</p>
<ol>
<li>首先需要将加密的字符串按规则转为二进制，初始字符都是Unicode，只是utf-8，能减小存储的代价。</li>
<li>按utf-8转为二进制后，就开始了md5的加密。</li>
</ol>
<p>经过查看前端同学的加密方法，得知错误出现在前端对字符串转二进制编码的处理上，在用<code>utf-8</code>转为二进制编码时，用的方法有问题，导致对emoji表情的编码错误，得到了错误了二进制编码，从而与服务端的签名不一致。</p>
<p>###加密过程</p>
<ol>
<li>需要对512取余为448，填充方法是补一个1，然后用0补全。</li>
<li>用64位来记录信息的长度，放在最后面，这样信息长度就变为N<em>512+448+64=(N+1)</em>512位。</li>
<li>装入4个幻数。</li>
<li>四轮循环运算（循环的次数是n+1）。</li>
</ol>
<p>1）将每一512字节细分成16个小组，每个小组32位（4个字节）</p>
<p>2）先认识四个线性函数(&amp;是与,|是或,~是非,^是异或)</p>
<p>3）设Mj表示消息的第j个子分组（从0到15），&lt;&lt;</p>
<p>FF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s)</p>
<p>GG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s)</p>
<p>HH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s)</p>
<p>II(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s)</p>
<p>4）四轮运算</p>
<p>第一轮</p>
<p>a=FF(a,b,c,d,M0,7,0xd76aa478)</p>
<p>b=FF(d,a,b,c,M1,12,0xe8c7b756)</p>
<p>c=FF(c,d,a,b,M2,17,0x242070db)</p>
<p>d=FF(b,c,d,a,M3,22,0xc1bdceee)</p>
<p>a=FF(a,b,c,d,M4,7,0xf57c0faf)</p>
<p>b=FF(d,a,b,c,M5,12,0x4787c62a)</p>
<p>c=FF(c,d,a,b,M6,17,0xa8304613)</p>
<p>d=FF(b,c,d,a,M7,22,0xfd469501)</p>
<p>a=FF(a,b,c,d,M8,7,0x698098d8)</p>
<p>b=FF(d,a,b,c,M9,12,0x8b44f7af)</p>
<p>c=FF(c,d,a,b,M10,17,0xffff5bb1)</p>
<p>d=FF(b,c,d,a,M11,22,0x895cd7be)</p>
<p>a=FF(a,b,c,d,M12,7,0x6b901122)</p>
<p>b=FF(d,a,b,c,M13,12,0xfd987193)</p>
<p>c=FF(c,d,a,b,M14,17,0xa679438e)</p>
<p>d=FF(b,c,d,a,M15,22,0x49b40821)</p>
<p>第二轮</p>
<p>a=GG(a,b,c,d,M1,5,0xf61e2562)</p>
<p>b=GG(d,a,b,c,M6,9,0xc040b340)</p>
<p>c=GG(c,d,a,b,M11,14,0x265e5a51)</p>
<p>d=GG(b,c,d,a,M0,20,0xe9b6c7aa)</p>
<p>a=GG(a,b,c,d,M5,5,0xd62f105d)</p>
<p>b=GG(d,a,b,c,M10,9,0x02441453)</p>
<p>c=GG(c,d,a,b,M15,14,0xd8a1e681)</p>
<p>d=GG(b,c,d,a,M4,20,0xe7d3fbc8)</p>
<p>a=GG(a,b,c,d,M9,5,0x21e1cde6)</p>
<p>b=GG(d,a,b,c,M14,9,0xc33707d6)</p>
<p>c=GG(c,d,a,b,M3,14,0xf4d50d87)</p>
<p>d=GG(b,c,d,a,M8,20,0x455a14ed)</p>
<p>a=GG(a,b,c,d,M13,5,0xa9e3e905)</p>
<p>b=GG(d,a,b,c,M2,9,0xfcefa3f8)</p>
<p>c=GG(c,d,a,b,M7,14,0x676f02d9)</p>
<p>d=GG(b,c,d,a,M12,20,0x8d2a4c8a)</p>
<p>第三轮</p>
<p>a=HH(a,b,c,d,M5,4,0xfffa3942)</p>
<p>b=HH(d,a,b,c,M8,11,0x8771f681)</p>
<p>c=HH(c,d,a,b,M11,16,0x6d9d6122)</p>
<p>d=HH(b,c,d,a,M14,23,0xfde5380c)</p>
<p>a=HH(a,b,c,d,M1,4,0xa4beea44)</p>
<p>b=HH(d,a,b,c,M4,11,0x4bdecfa9)</p>
<p>c=HH(c,d,a,b,M7,16,0xf6bb4b60)</p>
<p>d=HH(b,c,d,a,M10,23,0xbebfbc70)</p>
<p>a=HH(a,b,c,d,M13,4,0x289b7ec6)</p>
<p>b=HH(d,a,b,c,M0,11,0xeaa127fa)</p>
<p>c=HH(c,d,a,b,M3,16,0xd4ef3085)</p>
<p>d=HH(b,c,d,a,M6,23,0x04881d05)</p>
<p>a=HH(a,b,c,d,M9,4,0xd9d4d039)</p>
<p>b=HH(d,a,b,c,M12,11,0xe6db99e5)</p>
<p>c=HH(c,d,a,b,M15,16,0x1fa27cf8)</p>
<p>d=HH(b,c,d,a,M2,23,0xc4ac5665)</p>
<p>第四轮</p>
<p>a=II(a,b,c,d,M0,6,0xf4292244)</p>
<p>b=II(d,a,b,c,M7,10,0x432aff97)</p>
<p>c=II(c,d,a,b,M14,15,0xab9423a7)</p>
<p>d=II(b,c,d,a,M5,21,0xfc93a039)</p>
<p>a=II(a,b,c,d,M12,6,0x655b59c3)</p>
<p>b=II(d,a,b,c,M3,10,0x8f0ccc92)</p>
<p>c=II(c,d,a,b,M10,15,0xffeff47d)</p>
<p>d=II(b,c,d,a,M1,21,0x85845dd1)</p>
<p>a=II(a,b,c,d,M8,6,0x6fa87e4f)</p>
<p>b=II(d,a,b,c,M15,10,0xfe2ce6e0)</p>
<p>c=II(c,d,a,b,M6,15,0xa3014314)</p>
<p>d=II(b,c,d,a,M13,21,0x4e0811a1)</p>
<p>a=II(a,b,c,d,M4,6,0xf7537e82)</p>
<p>b=II(d,a,b,c,M11,10,0xbd3af235)</p>
<p>c=II(c,d,a,b,M2,15,0x2ad7d2bb)</p>
<p>d=II(b,c,d,a,M9,21,0xeb86d391)</p>
<p>4）每轮循环后，将A，B，C，D分别加上a，b，c，d，然后进入下一循环。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>采用<a href="https://github.com/emn178/js-md5此md5编码库得到正确的二进制编码" target="_blank" rel="noopener">https://github.com/emn178/js-md5此md5编码库得到正确的二进制编码</a></p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://blog.csdn.net/xuejianbest/article/details/80391237" target="_blank" rel="noopener">https://blog.csdn.net/xuejianbest/article/details/80391237</a></p>
<p><a href="https://blog.csdn.net/lidongli1060939183/article/details/85679450" target="_blank" rel="noopener">https://blog.csdn.net/lidongli1060939183/article/details/85679450</a></p>
]]></content>
  </entry>
  <entry>
    <title>docker no route host</title>
    <url>/2019/12/31/docker-no-route-host/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用docker部署redis时，我使用了 <code>docker run -p 6379:6379 ...</code>的命令，在docker中以6379的端口暴露给外部，但是应用A在启动时通过却连接不上redis，查看日志报错 <code>no route host</code>。之后使用客户端连接工具发现也是连不上。</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>docker进程在启动时，会创建一个docker0网桥，应用A连接redis时，会从docker0网桥到宿主机，这时候宿主机的防火墙就会拦截，需要设置防火墙对docker0网络环境的接受。</p>
<p><img src="/2019/12/31/docker-no-route-host/1577804992(1).jpg" alt="img"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li><p>设置为network=host</p>
</li>
<li><p>使用link 或者add-host</p>
</li>
</ol>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://stackoverflow.com/questions/27654453/no-route-to-host-between-2-docker-containers-in-same-host" target="_blank" rel="noopener">https://stackoverflow.com/questions/27654453/no-route-to-host-between-2-docker-containers-in-same-host</a></p>
<p><a href="https://www.jianshu.com/p/96aebba5d3cc" target="_blank" rel="noopener">https://www.jianshu.com/p/96aebba5d3cc</a></p>
]]></content>
  </entry>
  <entry>
    <title>Nexflix Eureka 源码一：EurekaServer启动之配置文件加载以及面向接口的配置项读取</title>
    <url>/2019/12/31/%5BNexflix%20Eureka%20%E6%BA%90%E7%A0%81%E4%B8%80%EF%BC%9AEurekaServer%E5%90%AF%E5%8A%A8%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%BB%E5%8F%96%5D/</url>
    <content><![CDATA[<h1 id="Nexflix-Eureka-源码一：EurekaServer启动之配置文件加载以及面向接口的配置项读取"><a href="#Nexflix-Eureka-源码一：EurekaServer启动之配置文件加载以及面向接口的配置项读取" class="headerlink" title="[Nexflix Eureka 源码一：EurekaServer启动之配置文件加载以及面向接口的配置项读取]"></a>[Nexflix Eureka 源码一：EurekaServer启动之配置文件加载以及面向接口的配置项读取]</h1><h3 id="代码总览"><a href="#代码总览" class="headerlink" title="代码总览"></a>代码总览</h3><p>从eureka server入口的类<code>EurekaBootStrap</code>开始，这里我们就先来简单地看下：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class that kick starts the eureka server. 负责启动Eureka server的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 这里要注意两个关键点：</span></span><br><span class="line"><span class="comment"> * eureka server对应的配置类为：EurekaServerConfig</span></span><br><span class="line"><span class="comment"> * eureka client对应的配置类为：EurekaInstanceConfig</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The eureka server is configured by using the configuration</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EurekaServerConfig&#125; specified by &lt;em&gt;eureka.server.props&lt;/em&gt; in the</span></span><br><span class="line"><span class="comment"> * classpath.  The eureka client component is also initialized by using the</span></span><br><span class="line"><span class="comment"> * configuration &#123;<span class="doctag">@link</span> EurekaInstanceConfig&#125; specified by</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;eureka.client.props&lt;/em&gt;. If the server runs in the AWS cloud, the eureka</span></span><br><span class="line"><span class="comment"> * server binds it to the elastic ip as specified.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Karthik Ranganathan, Greg Kim, David Liu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责EurekaServer初始化的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes Eureka, including syncing up with other Eureka peers and publishing the registry.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span></span></span><br><span class="line"><span class="comment">     * javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initEurekaEnvironment();</span><br><span class="line">            initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.setAttribute(EurekaServerContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">serverContext</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下注释 我们可以了解到几个关键点：</p>
<ol>
<li>eureka server对应的配置类为：EurekaServerConfig</li>
<li>eureka client对应的配置类为：EurekaInstanceConfig</li>
<li>EurekaBootStrap implements ServletContextListener, 所以这里会直接执行contextInitialized方法。</li>
</ol>
<h3 id="Eureka-Server-环境配置"><a href="#Eureka-Server-环境配置" class="headerlink" title="Eureka-Server 环境配置"></a>Eureka-Server 环境配置</h3><h4 id="初始化enviroment"><a href="#初始化enviroment" class="headerlink" title="初始化enviroment"></a>初始化enviroment</h4><p>接着近一步往下跟，这里可以先看 <code>initEurekaEnvironment()</code></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Setting the eureka configuration.."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取dataCenter数据中心 这里重点看ConfigurationManager</span></span><br><span class="line">        <span class="comment">// ConfigurationManager:配置管理器，管理eureka自己所有的配置，</span></span><br><span class="line">        <span class="comment">// 重点：getConfigInstance里面使用的是volatile+synchronized+double check模式的单例模式</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ConfigurationManager 创建过程：（继续往后跟读代码）</span></span><br><span class="line"><span class="comment">         * 1、创建一个ConcurrentCompositeConfiguration实例，这个类代表了所谓的配置，包括eureka需要的所有配置。</span></span><br><span class="line"><span class="comment">         * 2、往ConcurrentCompositeConfiguration加入一堆config，然后返回ConfigurationManager实例</span></span><br><span class="line"><span class="comment">         * 3、初始化数据中心的配置，如果没有配置的话就是default data center</span></span><br><span class="line"><span class="comment">         * 4、初始化eureka 运行的环境，如果没有配置的话，默认就是test环境</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);</span><br><span class="line">        <span class="comment">// 初始化数据中心，没有配置的话 使用DEFAULT data center</span></span><br><span class="line">        <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</span><br><span class="line">            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取eureka server运行环境，没有配置的话默认使用test环境</span></span><br><span class="line">        <span class="comment">// 后面读取配置文件会根据运行环境读取，比如eureka-server-test.properties</span></span><br><span class="line">        String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);</span><br><span class="line">        <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</span><br><span class="line">            logger.info(<span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里注释写的比较详细，且这里有两个重点:</p>
<ol>
<li>getConfigInstance里面使用的是volatile+synchronized+double check模式的单例模式</li>
<li>ConfigurationManager 创建过程</li>
</ol>
<h4 id="getConfigInstance"><a href="#getConfigInstance" class="headerlink" title="getConfigInstance"></a>getConfigInstance</h4><p>这里一个关键点 是使用了很经典的double check 单例模式。</p>
<p>这种单例是一种线程安全的方式，里面使用了volatile+synchronized+double check，具体秒在何处 我这里就不展开讲解了，搜索double check单例模式就会有很多解析文章，这里直接看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> AbstractConfiguration instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the current system wide configuration. If there has not been set, it will return a default</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConcurrentCompositeConfiguration&#125; which contains a SystemConfiguration from Apache Commons</span></span><br><span class="line"><span class="comment"> * Configuration and a &#123;<span class="doctag">@link</span> DynamicURLConfiguration&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractConfiguration <span class="title">getConfigInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ConfigurationManager<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = getConfigInstance(Boolean.getBoolean(DynamicPropertyFactory.DISABLE_DEFAULT_CONFIG));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里instance用volatile修饰来保证线程之间的可见性，用synchronized来保证线程串行化，double check来保证不被单例化。</p>
<p>接着我们就继续往下跟，看看ConfigurationManager的创建过程。</p>
<h4 id="ConfigurationManager-创建"><a href="#ConfigurationManager-创建" class="headerlink" title="ConfigurationManager 创建"></a>ConfigurationManager 创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractConfiguration <span class="title">getConfigInstance</span><span class="params">(<span class="keyword">boolean</span> defaultConfigDisabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span> &amp;&amp; !defaultConfigDisabled) &#123;</span><br><span class="line">        instance = createDefaultConfigInstance();</span><br><span class="line">        registerConfigBean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractConfiguration <span class="title">createDefaultConfigInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcurrentCompositeConfiguration config = <span class="keyword">new</span> ConcurrentCompositeConfiguration();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DynamicURLConfiguration defaultURLConfig = <span class="keyword">new</span> DynamicURLConfiguration();</span><br><span class="line">        config.addConfiguration(defaultURLConfig, URL_CONFIG_NAME);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create default dynamic configuration"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.getBoolean(DISABLE_DEFAULT_SYS_CONFIG)) &#123;</span><br><span class="line">        SystemConfiguration sysConfig = <span class="keyword">new</span> SystemConfiguration();</span><br><span class="line">        config.addConfiguration(sysConfig, SYS_CONFIG_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.getBoolean(DISABLE_DEFAULT_ENV_CONFIG)) &#123;</span><br><span class="line">        EnvironmentConfiguration envConfig = <span class="keyword">new</span> EnvironmentConfiguration();</span><br><span class="line">        config.addConfiguration(envConfig, ENV_CONFIG_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    ConcurrentCompositeConfiguration appOverrideConfig = <span class="keyword">new</span> ConcurrentCompositeConfiguration();</span><br><span class="line">    config.addConfiguration(appOverrideConfig, APPLICATION_PROPERTIES);</span><br><span class="line">    config.setContainerConfigurationIndex(config.getIndexOfConfiguration(appOverrideConfig));</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCompositeConfiguration</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fireEvent(EVENT_CLEAR, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    configList.clear();</span><br><span class="line">    namedConfigurations.clear();</span><br><span class="line">    <span class="comment">// recreate the in memory configuration</span></span><br><span class="line">    containerConfiguration = <span class="keyword">new</span> ConcurrentMapConfiguration();</span><br><span class="line">    containerConfiguration.setThrowExceptionOnMissing(isThrowExceptionOnMissing());</span><br><span class="line">    containerConfiguration.setListDelimiter(getListDelimiter());</span><br><span class="line">    containerConfiguration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());</span><br><span class="line">    containerConfiguration.addConfigurationListener(eventPropagater);</span><br><span class="line">    configList.add(containerConfiguration);</span><br><span class="line">    </span><br><span class="line">    overrideProperties = <span class="keyword">new</span> ConcurrentMapConfiguration();</span><br><span class="line">    overrideProperties.setThrowExceptionOnMissing(isThrowExceptionOnMissing());</span><br><span class="line">    overrideProperties.setListDelimiter(getListDelimiter());</span><br><span class="line">    overrideProperties.setDelimiterParsingDisabled(isDelimiterParsingDisabled());</span><br><span class="line">    overrideProperties.addConfigurationListener(eventPropagater);</span><br><span class="line">    </span><br><span class="line">    fireEvent(EVENT_CLEAR, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    containerConfigurationChanged = <span class="keyword">false</span>;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是比较多，如果一行行去抠细节 真的就没有必要了，这里我们只是看一些重点的流程，我们上面注释也写到过ConfigurationManager的创建过程：<br> 1、创建一个ConcurrentCompositeConfiguration实例，这个类代表了所谓的配置，包括eureka需要的所有配置。<br> 2、往ConcurrentCompositeConfiguration加入一堆config，然后返回ConfigurationManager实例</p>
<p>这里我是不建议太过于扣细节的，因为往往这些细枝末节的东西会将我们绕进去。</p>
<p>关于ConfigurationManager具体的细节这里也有两篇比较好的文章推荐：</p>
<ol>
<li><a href="https://www.v2ex.com/t/392381" target="_blank" rel="noopener">关于 Eureka 启动的说明</a></li>
<li><a href="http://techblog.ppdai.com/2018/05/08/20180508/" target="_blank" rel="noopener">微服务动态配置组件netflix archaius</a></li>
</ol>
<h3 id="Eureka-Server-上下文加载"><a href="#Eureka-Server-上下文加载" class="headerlink" title="Eureka-Server 上下文加载"></a>Eureka-Server 上下文加载</h3><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1、加载eureka-server properties文件中和配置</span></span><br><span class="line">    EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For backward compatibility</span></span><br><span class="line">    JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</span><br><span class="line">    XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"Initializing the eureka client..."</span>);</span><br><span class="line">    logger.info(eurekaServerConfig.getJsonCodecName());</span><br><span class="line">    ServerCodecs serverCodecs = <span class="keyword">new</span> DefaultServerCodecs(eurekaServerConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、初始化一个ApplicationInfoManager，和第3步创建eureka client相关，后续会讲解</span></span><br><span class="line">    ApplicationInfoManager applicationInfoManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、初始化eureka-server内部的一个eureka-client（用来跟其他的eureka-server节点做注册和通信）</span></span><br><span class="line">    <span class="comment">// 类的开头已经说明了：EurekaInstanceConfig其实就是eureka client相关的配置类</span></span><br><span class="line">    <span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">                ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">                : <span class="keyword">new</span> MyDataCenterInstanceConfig();</span><br><span class="line">        </span><br><span class="line">        applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</span><br><span class="line">                instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</span><br><span class="line">        </span><br><span class="line">        EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">        eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationInfoManager = eurekaClient.getApplicationInfoManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、处理注册相关的事情</span></span><br><span class="line">    PeerAwareInstanceRegistry registry;</span><br><span class="line">    <span class="keyword">if</span> (isAws(applicationInfoManager.getInfo())) &#123;</span><br><span class="line">        registry = <span class="keyword">new</span> AwsInstanceRegistry(</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                eurekaClient</span><br><span class="line">        );</span><br><span class="line">        awsBinder = <span class="keyword">new</span> AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);</span><br><span class="line">        awsBinder.start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                eurekaClient</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、处理peer节点相关的事情</span></span><br><span class="line">    PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</span><br><span class="line">            registry,</span><br><span class="line">            eurekaServerConfig,</span><br><span class="line">            eurekaClient.getEurekaClientConfig(),</span><br><span class="line">            serverCodecs,</span><br><span class="line">            applicationInfoManager</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、完成eureka-server上下文(context)的构建及初始化</span></span><br><span class="line">    serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</span><br><span class="line">            eurekaServerConfig,</span><br><span class="line">            serverCodecs,</span><br><span class="line">            registry,</span><br><span class="line">            peerEurekaNodes,</span><br><span class="line">            applicationInfoManager</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    EurekaServerContextHolder.initialize(serverContext);</span><br><span class="line"></span><br><span class="line">    serverContext.initialize();</span><br><span class="line">    logger.info(<span class="string">"Initialized server context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></span><br><span class="line">    <span class="comment">// 6、处理一些善后的事情，从相邻的eureka节点拷贝注册信息</span></span><br><span class="line">    <span class="keyword">int</span> registryCount = registry.syncUp();</span><br><span class="line">    registry.openForTraffic(applicationInfoManager, registryCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register all monitoring statistics.</span></span><br><span class="line">    <span class="comment">// 7、注册所有的监控统计项</span></span><br><span class="line">    EurekaMonitors.registerAllStats();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码有点长，加载context信息分为了上面注释的好几步，代码注释都有写</p>
<p>加载eureka-server properties文件中和配置<br> EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory.getInstance().getStringProperty(<span class="string">"eureka.server.props"</span>,<span class="string">"eureka-server"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String env = ConfigurationManager.getConfigInstance().getString(</span><br><span class="line">            EUREKA_ENVIRONMENT, TEST);</span><br><span class="line">    ConfigurationManager.getConfigInstance().setProperty(</span><br><span class="line">            ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</span><br><span class="line"></span><br><span class="line">    String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ConfigurationManager</span></span><br><span class="line">        <span class="comment">// .loadPropertiesFromResources(eurekaPropsFile);</span></span><br><span class="line">        ConfigurationManager</span><br><span class="line">                .loadCascadedPropertiesFromResources(eurekaPropsFile);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.warn(</span><br><span class="line">                <span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></span><br><span class="line">                        + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>,</span><br><span class="line">                eurekaPropsFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCascadedPropertiesFromResources</span><span class="params">(String configName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties props = loadCascadedProperties(configName);</span><br><span class="line">    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> AggregatedConfiguration) &#123;</span><br><span class="line">        ConcurrentMapConfiguration config = <span class="keyword">new</span> ConcurrentMapConfiguration();</span><br><span class="line">        config.loadProperties(props);</span><br><span class="line">        ((AggregatedConfiguration) instance).addConfiguration(config, configName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ConfigurationUtils.loadProperties(props, instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们看下<code>EurekaServerConfig</code>：<br> <img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191224100449297-1718244259.png" alt="image.png"></p>
<p>里面包含好多getxxx方法，看一下具体实现：<br> <img src="https://img2018.cnblogs.com/blog/799093/201912/799093-20191224100450057-1914090144.png" alt="image.png"></p>
<p>其中configInstance是<code>DynamicPropertyFactory</code>对象。EurekaServerConfig，这是个接口，这里面有一堆getXXX()的方法，包含了eureka server需要使用的所有的配置，都可以通过这个接口来获取。</p>
<p>想象一下，eureka-sever.properties文件里，都是一个一个的key=value的很多的配置项，肯定是将这些key-value格式的配置项加载到内存的Properties对象去存放，Map。一般来说，如果让我们自己来设计这个读取properties文件的配置的代码，也许我们就是做到将配置加载到Properties对象中就结束了。</p>
<p>EurekaServerConfig，代表了eureka-server需要的所有的配置项，通过接口定义了大量的方法，让你可以从这里获取所有你需要的配置</p>
<p><code>DefaultEurekaServerConfig</code>就是上面<code>EurekaServerConfig</code>的实现类，创建实例的时候，会执行一个init()方法，在这个方法中，就会完成eureka-server.properties文件中的配置项的加载。EUREKA_PROPS_FILE，对应着要加载的eureka的配置文件的名字。</p>
<p>将加载出来的Properties中的配置项都放到ConfigurationManager中去，由这个ConfigurationManager来管理</p>
<p>比如说eureka-server那个工程里，就有一个src/main/resources/eureka-server.properties文件，只不过里面是空的，全部都用了默认的配置</p>
<p>DefaultEurekaServerConfig.init()方法中，会将eureka-server.properties文件中的配置加载出来，都放到ConfdigurationManager中去，然后在DefaultEurekaServerConfig的各种获取配置项的方法中，配置项的名字是在各个方硬编码的，是从一个DynamicPropertyFactory里面去获取的，你可以认为DynamicPropertyFactory是从ConfigurationManager那儿来的，因为ConfigurationManager中都包含了加载出来的配置了，所以DynamicPropertyFactory里，也可以获取到所有的配置项</p>
<p>在从DynamicPropertyFactory中获取配置项的时候，如果你没配置，那么就用默认值，全部都给你弄好了各个配置项的默认值，相当于所有的配置项的默认值，在DefaultEurekaServerConfig的各个方法中，都可以看到，如果你没配置，那么就用这里的默认值就可以了</p>
<p>加载eureka-server.properties的过程：</p>
<p>（1）创建了一个DefaultEurekaServerConfig对象<br> （2）创建DefaultEurekaServerConfig对象的时候，在里面会有一个init方法<br> （3）先是将eureka-server.properties中的配置加载到了一个Properties对象中，然后将Properties对象中的配置放到ConfigurationManager中去，此时ConfigurationManager中去就有了所有的配置了<br> （4）然后DefaultEurekaServerConfig提供的获取配置项的各个方法，都是通过硬编码的配置项名称，从DynamicPropertyFactory中获取配置项的值，DynamicPropertyFactory是从ConfigurationManager那儿来的，所以也包含了所有配置项的值<br> （5）在获取配置项的时候，如果没有配置，那么就会有默认的值，全部属性都是有默认值的</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Nexflix Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>docker悬空镜像占满磁盘</title>
    <url>/2019/12/31/docker%E6%82%AC%E7%A9%BA%E9%95%9C%E5%83%8F%E5%8D%A0%E6%BB%A1%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>钉钉群中突然报了磁盘报警的警告：</p>
<p><img src="/2019/12/31/docker%E6%82%AC%E7%A9%BA%E9%95%9C%E5%83%8F%E5%8D%A0%E6%BB%A1%E7%A3%81%E7%9B%98/baojing.jpg" alt="#"></p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>使用df -lh 查看是哪个文件系统里比较占用磁盘。接着用du -sh * 在占用比较大的文件系统中寻找到底是哪里占用大了。</p>
<p>最后找出来是由于docker的悬空镜像引起的</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>删除所有悬空镜像，但不会删除未使用镜像：</p>
<p> docker rmi $(docker images -f “dangling=true” -q)</p>
<p>删除所有未使用镜像和悬空镜像。</p>
<p>【说明】：轮询到还在被使用的镜像时，会有类似”image is being used by xxx container”的告警信息，所以相关镜像不会被删除，忽略即可。<br> docker rmi $(docker images-q)</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>kibana日志报警推送</title>
    <url>/2019/12/31/kibana%E6%97%A5%E5%BF%97%E6%8A%A5%E8%AD%A6%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>虽然有了elk日志分析系统，但还是架不住人懒呐，目前的情况，根本做不到实时的查看并且发现错误，所以就需要做一个日志的报警，当有错误日志时，通知开发人员，进行及时的修改，不用再去实时的盯着。</p>
<p>在调研的过程发现，这已经是一个造好的轮子了，就是<code>sentinl</code>，并且它可以通过配置针对某些属性进行持续关注。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我的安装有点蠢，主要还是因为服务器网速太尴尬了，一直没下载成功。</p>
<ol>
<li>下载sentinl安装包 <a href="https://github.com/sirensolutions/sentinl/releases/download/tag-6.4.2-0/sentinl-v6.4.2.zip。这里主要是因为服务器上去拉这个包实在是太慢了...注意这里的版本要和kibana的版本一致" target="_blank" rel="noopener">https://github.com/sirensolutions/sentinl/releases/download/tag-6.4.2-0/sentinl-v6.4.2.zip。这里主要是因为服务器上去拉这个包实在是太慢了...注意这里的版本要和kibana的版本一致</a></li>
<li>通过rz命令或者直接用xftp传送至服务器中</li>
<li>通过docker cp把文件传送至docker容器中(因为之间没有挂载目录)： docker cp /root/sentinl-v6.4.2.zip elk:/root。</li>
<li>使用命令 /opt/kibana/bin/kibana-plugin install <a href="file://root/sentinl-v6.4.2.zip" target="_blank" rel="noopener">file:///root/sentinl-v6.4.2.zip</a>进行安装</li>
<li>重启elk</li>
</ol>
<p><img src="https://images2018.cnblogs.com/blog/1296244/201804/1296244-20180426171221971-1545838205.png" alt="img"></p>
<p>可以看到，左边菜单栏多了一项 <code>sentinl</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>点击右上角的<code>New</code>，新建一个<code>watcher</code></p>
</li>
<li><p>watcher是一个json格式的文件，复制以下即可，这里的意思是每5分钟检测一次日志，如果有error日志，那么就将错误的详细信息以及错误日志的来源，发至钉钉群中，这样，开发人员就能及时的收到信息啦！</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"actions"</span>: &#123;</span><br><span class="line">    <span class="attr">"Webhook_7f20289e-9d9c-416f-9cd3-401a938fb410"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Webhook"</span>,</span><br><span class="line">      <span class="attr">"throttle_period"</span>: <span class="string">"5m"</span>,</span><br><span class="line">      <span class="attr">"webhook"</span>: &#123;</span><br><span class="line">        <span class="attr">"priority"</span>: <span class="string">"high"</span>,</span><br><span class="line">        <span class="attr">"stateless"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"POST"</span>,</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"oapi.dingtalk.com"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="string">"443"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/robot/send?access_token=f032ba2f856564ecf94163e709b8f9a6c92501d8df6564f153c41411bfaaef82"</span>,</span><br><span class="line">        <span class="attr">"body"</span>: <span class="string">"&#123;\n\"msgtype\":\"text\",\n\"text\":&#123;\n    \"content\":\"生产环境出现错误,请留意,系统来源: &#123;&#123;payload.hits.hits.0._source.origin&#125;&#125;, 详情如下 \\n\n   &#123;&#123;payload.hits.hits.0._source.message&#125;&#125; \\n\n    \"\n&#125;\n&#125;"</span>,</span><br><span class="line">        <span class="attr">"headers"</span>: &#123;</span><br><span class="line">          <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"message"</span>: <span class="string">"&#123;&#123;payload.hits.total&#125;&#125;"</span>,</span><br><span class="line">        <span class="attr">"auth"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"use_https"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"input"</span>: &#123;</span><br><span class="line">    <span class="attr">"search"</span>: &#123;</span><br><span class="line">      <span class="attr">"request"</span>: &#123;</span><br><span class="line">        <span class="attr">"index"</span>: [</span><br><span class="line">          <span class="string">"application-2019.02-prod*"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"body"</span>: &#123;</span><br><span class="line">          <span class="attr">"query"</span>: &#123;</span><br><span class="line">            <span class="attr">"bool"</span>: &#123;</span><br><span class="line">              <span class="attr">"must"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"query_string"</span>: &#123;</span><br><span class="line">                    <span class="attr">"analyze_wildcard"</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">"query"</span>: <span class="string">"\"error\""</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"@timestamp"</span>: &#123;</span><br><span class="line">                      <span class="attr">"gte"</span>: <span class="string">"now-5m"</span>,</span><br><span class="line">                      <span class="attr">"lte"</span>: <span class="string">"now"</span>,</span><br><span class="line">                      <span class="attr">"format"</span>: <span class="string">"epoch_millis"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"must_not"</span>: []</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"condition"</span>: &#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;</span><br><span class="line">      <span class="attr">"script"</span>: <span class="string">"payload.hits.total&gt;=1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"transform"</span>: &#123;</span><br><span class="line">    <span class="attr">"script"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"trigger"</span>: &#123;</span><br><span class="line">    <span class="attr">"schedule"</span>: &#123;</span><br><span class="line">      <span class="attr">"later"</span>: <span class="string">"every 5 minutes"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"disable"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"report"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"watcher_localnews"</span>,</span><br><span class="line">  <span class="attr">"save_payload"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"spy"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"impersonate"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>效果还是挺好的， 大家都能在第一时间看到错误的日志，并及时的改正，唯一的不足就是日志级别的紊乱，导致很多日志被   当作错误日志打出来了，需要提醒大家，谨慎的确定日志级别！</p>
</li>
</ol>
<p><img src="/2019/12/31/kibana%E6%97%A5%E5%BF%97%E6%8A%A5%E8%AD%A6%E6%8E%A8%E9%80%81/dingding.jpg" alt="效果图"></p>
]]></content>
  </entry>
  <entry>
    <title>文本检测方案调研</title>
    <url>/2019/12/31/%E6%96%87%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于项目是做内容相关的，有UGC也有PGC，针对UGC的部分需要用到文本检测，防止有不适当的言论或图片进入用户视野中。</p>
<a id="more"></a>

<p>##市场主要服务列表：</p>
<p>百度 || 网易云 易盾 || 数美 || 融云</p>
<p>##选型对象：</p>
<p>百度 || 网易云 易盾 || 数美 </p>
<p>由于融云（咨询电话：13161856839）在网上的资料较少，在此不列入选型对象</p>
<p>##对比参考：</p>
<p>其中，功能以及调用接口的难易度，大体上差不多，故不记录</p>
<table>
<thead>
<tr>
<th>产品</th>
<th>百度</th>
<th>易盾</th>
<th>数美</th>
</tr>
</thead>
<tbody><tr>
<td>价格</td>
<td>目前不支持付费，免费额度超过10000次/天无法用</td>
<td>附价格列表</td>
<td>相对易盾低，一天20万的调用量，一年大概5-6万。没有明确价格表，对第一个月进行测试，来给出一个方案</td>
</tr>
<tr>
<td>准确度</td>
<td>未知</td>
<td>召回率比数美高</td>
<td>准确率比易盾高</td>
</tr>
<tr>
<td>客户</td>
<td>未知</td>
<td>知乎”悟空”接入易盾，客户较少</td>
<td>客户较多，直播类，视频类等</td>
</tr>
</tbody></table>
<p>关于准确率与召回率：如果做疾病监测、反垃圾，则是要保证准确率的条件下，提升召回率。</p>
<p>##易盾价格参考：（1200万/年折合每天3W+次）</p>
<p><img src="data:image/png;base64,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" alt="/ 000 &#39; 89  / 000 ℃ S  / 000 ℃ 乙  工 Y 、 「 , 乙 ㄥ  士 / 乙 I  士 / 8 • I  士 / SZ  009  009E  00 乙 I "></p>
<p>结论：由于百度无法提供收费服务，10000次/天不够用，所以弃用。易盾和数美相差不多，数美相对来说比较早，客户拥有量也比较多，价格相对易盾也比较便宜。</p>
<p>##相关网站：</p>
<p>网易云易盾-文本识别：<a href="https://dun.163.com/trial/text" target="_blank" rel="noopener">https://dun.163.com/trial/text</a></p>
<p>百度-文本审核： <a href="http://ai.baidu.com/tech/textcensoring" target="_blank" rel="noopener">http://ai.baidu.com/tech/textcensoring</a></p>
<p>数美-智能文本过滤：<a href="https://www.fengkongcloud.com/product/text.html?keyUrl=https%3A%2F%2Fwww.fengkongcloud.com%2F%23%23%23&amp;keyRefererHost=www.ishumei.com" target="_blank" rel="noopener">https://www.fengkongcloud.com/product/text.html?keyUrl=https%3A%2F%2Fwww.fengkongcloud.com%2F%23%23%23&amp;keyRefererHost=www.ishumei.com</a></p>
<p>融云-安全审核：<a href="https://www.rongcloud.cn/product/antispam" target="_blank" rel="noopener">https://www.rongcloud.cn/product/antispam</a></p>
<p>##相关资料：</p>
<p>1.怎么看网易推出易盾反垃圾云服务？</p>
<p>来自 <a href="https://www.zhihu.com/question/41776232" target="_blank" rel="noopener">https://www.zhihu.com/question/41776232</a> </p>
<p>2.内容反垃圾有哪些形式？ 哪家技术比较成熟？</p>
<p>来自 <a href="https://www.zhihu.com/question/46443019" target="_blank" rel="noopener">https://www.zhihu.com/question/46443019</a> </p>
<p>3.十年•杭研程序猿 | 反垃圾运营的匠心之路</p>
<p>来自 <a href="https://sq.163yun.com/blog/article/154767025060954112" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/154767025060954112</a> </p>
]]></content>
  </entry>
  <entry>
    <title>分布式任务框架调研</title>
    <url>/2019/12/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前项目中一直用的quartz定时调度框架，随着需求慢慢增多，发现quartz越来越不给力，所以需要换一个定时调度的框架。</p>
<a id="more"></a>

<p>##主流定时调度框架介绍</p>
<ol>
<li><p>Quartz：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能</p>
</li>
<li><p>TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用timer而非线程池执行任务调度。众所周知，timer在处理异常状况时是有缺陷的。而且TBSchedule作业类型较为单一，只能是获取/处理数据一种模式。还有就是文档缺失比较严重</p>
</li>
<li><p>elastic-job：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，并且可以支持云开发。缺点是需要部署zookeeper，且上手难度较大</p>
</li>
<li><p>Saturn：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。缺点是技术文档较少</p>
</li>
<li><p>xxl-job: 是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。</p>
</li>
</ol>
<p>经过初步筛选，<code>elastic-job</code>和<code>xxl-job</code>功能比较强劲，技术支持人员和文档都比较多，使用也比较广泛。</p>
<h2 id="主流方案对比"><a href="#主流方案对比" class="headerlink" title="主流方案对比"></a>主流方案对比</h2><p>从比对表中可以看出，quartz对于分布式的支持不够好，elastic-job学习成本较高，而xxl-job功能比较全，上手难度也较低，文档也比较完善，因此选用xxl-job比较合适。</p>
<p><img src="/2019/12/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%B0%83%E7%A0%94/1577801707(1).jpg" alt="img"></p>
<h2 id="xxl-job架构设计"><a href="#xxl-job架构设计" class="headerlink" title="xxl-job架构设计"></a>xxl-job架构设计</h2><p>从架构图中也可以看出来，xxl-job比较适合调度中心分布式部署，执行器分散于各个不同应用中的设计思路。</p>
<p><img src="/2019/12/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%B0%83%E7%A0%94/1577801729(1).jpg" alt="img"></p>
<h2 id="xxl-job源码地址，及使用文档"><a href="#xxl-job源码地址，及使用文档" class="headerlink" title="xxl-job源码地址，及使用文档"></a>xxl-job源码地址，及使用文档</h2><p>源码地址：</p>
<p><a href="http://www.xuxueli.com/xxl-job/#/?id=《分布式任务调度平台xxl-job》" target="_blank" rel="noopener">http://www.xuxueli.com/xxl-job/#/?id=%e3%80%8a%e5%88%86%e5%b8%83%e5%bc%8f%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6%e5%b9%b3%e5%8f%b0xxl-job%e3%80%8b</a></p>
<p>使用文档：</p>
<p><a href="http://www.xuxueli.com/xxl-job/#/?id=《分布式任务调度平台xxl-job》" target="_blank" rel="noopener">http://www.xuxueli.com/xxl-job/#/?id=%e3%80%8a%e5%88%86%e5%b8%83%e5%bc%8f%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6%e5%b9%b3%e5%8f%b0xxl-job%e3%80%8b</a></p>
<p>##xxl-job集成思路</p>
<p>根据xxl-job的架构设计，可以将其调度系统与执行系统分开，调度系统分布式部署，并且自带有对应的管理后台，而执行器可以分布于不同的业务系统中，从调度系统领取任务。</p>
<p>任务的创建可以通过各业务系统请求调度中心创建，也可以通过管理后台配置。任务的执行可以通过分片策略来指定不同的执行器。</p>
]]></content>
  </entry>
  <entry>
    <title>eureka服务优雅上下线</title>
    <url>/2019/12/31/eureka%E6%9C%8D%E5%8A%A1%E4%BC%98%E9%9B%85%E4%B8%8A%E4%B8%8B%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在线上环境，总共有8个服务，每个服务有两个实例，在发布线上环境时，因为会有服务调用到正在重启的服务，难免会出现服务器错误的情况，针对此问题，调研了在注册中心为eureka时如何优雅停机。</p>
<a id="more"></a>

<p>其实在早先已经调研过这方面的需求，使用的是调用spring-boot-starter-actuator依赖中的<code>/service-registry</code>端点。</p>
<ol>
<li>在想下线应用的<code>application.yml</code> 中添加配置，从而暴露<code>/service-registry</code> 端点：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">service-registry</span></span><br></pre></td></tr></table></figure>

<p>发送POST请求到<code>/actuator/service-registry</code> 端点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X "POST" "http://localhost:8000/actuator/service-registry?status=OUT_OF_SERVICE" \</span><br><span class="line">   -H "Content-Type: application/vnd.spring-boot.actuator.v2+json;charset=UTF-8"</span><br></pre></td></tr></table></figure>

<p>实行后的效果类似如下图：</p>
<p><img src="http://www.itmuch.com/images/unregistry-service-in-eureka.png" alt="下线后的效果图"></p>
<p>由图可知，使用<code>/service-registry</code> 端点可实现类似<code>/pause</code> 端点的效果。</p>
<ol start="2">
<li>将eureka的刷新时间置为5s，使得别的服务能及时感知当前服务下线，刷新本地缓存</li>
</ol>
<p>参考资料自</p>
<p><a href="http://www.itmuch.com/spring-cloud-sum/how-to-unregister-service-in-eureka/" target="_blank" rel="noopener">http://www.itmuch.com/spring-cloud-sum/how-to-unregister-service-in-eureka/</a></p>
<p><a href="https://www.cnblogs.com/trust-freedom/p/10744683.html" target="_blank" rel="noopener">https://www.cnblogs.com/trust-freedom/p/10744683.html</a></p>
<ol start="3">
<li><p>将执行下线操作放在停止应用的前一步，并暂停10秒钟，确保有足够的时间处理已经进来的请求。在服务在重启时，发送命令：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X "POST" "http://localhost:8000/actuator/service-registry?status=CANCEL_OVERRIDE" \</span><br><span class="line">   -H "Content-Type: application/vnd.spring-boot.actuator.v2+json;charset=UTF-8"</span><br></pre></td></tr></table></figure>

<p>清除服务的覆盖状态，避免被<code>OUT_OF_SERVICE</code>覆盖。等待服务重启，并连接至eureka注册中心恢复可用。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.服务在启动的时候，不知为什么会在没有完全启动前注册到eureka，别的服务能调用到，但是其实还是没有启动完全的。导致有一段很短的时间服务器错误。</p>
<p>2.由于项目用的是xxl-job定时任务框架，此框架没有使用eureka做为注册中心，导致它根本不知道哪些服务不可用。</p>
<p>##解决方案</p>
<p>将自动注册到eureka注册中心改为手动控制。有点怪怪的。但是找不到好的解决办法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当应用完全启动完成，等待处理请求时，将服务置为上线</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@EventListener</span>(ApplicationReadyEvent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"> <span class="title">public</span> <span class="title">void</span> <span class="title">onApplicationReady</span>(<span class="title">ApplicationReadyEvent</span> <span class="title">event</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (event.getApplicationContext() == context) &#123;</span><br><span class="line">         log.info(<span class="string">"on ApplicationReadyEvent，更新 eureka client 状态为 UP"</span>);</span><br><span class="line">         InstanceInfo info = registration.getApplicationInfoManager().getInfo();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 由于初始的状态被置为了Starting 所以在默认的启动中，不会去注册服务....</span></span><br><span class="line">         <span class="comment">// 里面的代码可以看到，如果上一个和下一个相同，就不会调用notify()了...</span></span><br><span class="line">         <span class="comment">// 同时，也不可以直接调用 registration.getEurekaClient().setStatus() 方法，在没有注册服务的情况下无法更新状态</span></span><br><span class="line">         <span class="comment">// 默认走一次原本的初始化注册流程 内部会设置info对象的状态，并将信息注册到eureka</span></span><br><span class="line">         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 有一定几率出现上一次启动没有移除服务，服务还处于OUT_OF_SERVICE状态(kill -9)，因为register行为是无法改变OUT_OF_SERVICE状态的</span></span><br><span class="line">         <span class="comment">// 所以这里需要触发status update to UP</span></span><br><span class="line">         Application application = registration.getEurekaClient().getApplication(info.getAppName());</span><br><span class="line">         <span class="comment">// 如果eureka service 存在当前应用的实例 且实例为OUT状态，则直接置为上线</span></span><br><span class="line">         <span class="keyword">if</span> (Objects.nonNull(application)) &#123;</span><br><span class="line">             InstanceInfo remoteInfo = application.getByInstanceId(info.getId());</span><br><span class="line">             <span class="keyword">if</span> (Objects.nonNull(remoteInfo)</span><br><span class="line">                     &amp;&amp; Objects.equals(remoteInfo.getStatus(), InstanceInfo.InstanceStatus.OUT_OF_SERVICE)) &#123;</span><br><span class="line">                 <span class="comment">// 服务上线</span></span><br><span class="line">                 registration.getEurekaClient().setStatus(InstanceInfo.InstanceStatus.UP, info);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>eureka</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>feignClient一定要传requestParam的value</title>
    <url>/2019/12/31/feignClient%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BC%A0requestParam%E7%9A%84value/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这个问题是源于，在开发过程中，有同事在使用feignClient时对参数加上了@requestParam，但是没有加value属性，导致发布时出错。离奇的点是在本地启动是没有问题的。在上网查了一下，通篇全都在说加上value就好了，都没有说明原因（内心os：这TM谁不知道啊）。在用google搜索时第一篇stackOverFlow上的问题说明了缘由，所以说程序员还是得用google。</p>
<a id="more"></a>

<p>feignClient在没有设置@requestParam的value情况下启动报错，显示错误：Caused by: java.lang.IllegalStateException: RequestParam.value() was empty on parameter 0 。为什么平时在controller中写接口时，不指定requestParam的value是可以的，而在feignClient中就不行呢？</p>
<p>##原因</p>
<p>Spring MVC和feignClient其实用的都是同一套ParameterNameDiscoverer，它通过以下两个步骤来获取参数名称：</p>
<ol>
<li><p>使用StandardReflectionParameterNameDiscoverer，它通过反射机制来寻找变量名，只有在编译时加入了-parameters参数才会生效。</p>
</li>
<li><p>如果失败了，它会使用LocalVariableTableParameterNameDiscoverer通过带有ASM库的java类中的调试信息来寻找变量名称。</p>
</li>
</ol>
<p>SpringMvc和feignClient的不同之处就在这里。feignClient在接口上上使用注释在方法上的像@requestParam这样的参数，但是我们在SpringMvc是在类上使用注释的。不幸的是，javac编译器会因为接口而忽略调试信息上的参数名称。换句话说，如果你使用-parameters参数来编译你的代码，那么SpringMvc和Feign都能成功获取到参数名称，但是如果你没有用-parameters,那么只有SpringMvc能正常获取到。总而言之，这不是一个bug，这只是使用Feign的一个局限性吧（我觉得）</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li><p>加上value</p>
</li>
<li><p>在编译时加入了-parameters参数</p>
</li>
</ol>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://www.jianshu.com/p/f569c5705e8a" target="_blank" rel="noopener">https://www.jianshu.com/p/f569c5705e8a</a></p>
<p><a href="https://stackoverflow.com/questions/44313482/feign-client-with-spring-boot-requestparam-value-was-empty-on-parameter-0" target="_blank" rel="noopener">https://stackoverflow.com/questions/44313482/feign-client-with-spring-boot-requestparam-value-was-empty-on-parameter-0</a></p>
<p><a href="https://stackoverflow.com/questions/18155032/localvariabletableparameternamediscoverer-does-not-work" target="_blank" rel="noopener">https://stackoverflow.com/questions/18155032/localvariabletableparameternamediscoverer-does-not-work</a></p>
]]></content>
      <tags>
        <tag>feignClient</tag>
      </tags>
  </entry>
  <entry>
    <title>内容推荐方案调研</title>
    <url>/2019/12/31/%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于目前的需求比较重视内容推荐，之前的推荐是直接根据表中的数据直接进行查询得知，非常的粗暴且不准确（其实是一个买来的代码…），所以需要对这部分内容进行优化从而提高推荐内容的精准度，从而提高用户留存率。</p>
<a id="more"></a>

<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>###对于用户进行简单的建模（用户的地理位置，年龄，性别）</p>
<p>暂无年龄和性别，地理位置可以获取</p>
<p>###热度算法</p>
<p>存在问题：目前每篇文章在入库时，优先级都是相等的，而正常情况下，文章的优先级应该是有所区别的，比如：百度热搜上游“房租暴涨”，那么有相关文字的文章应该初始热度较高。</p>
<p>思路：动态维护一个热词库(网上的热词)，如果能匹配热词库，那么就提高这篇文章的初始热度值，总体热度随时间呈几何衰减(根据时间衰减因子)。</p>
<p>参考牛顿冷却定律，时间衰减因子应该是一个类似于指数函数：</p>
<p>T(Time) = e ^ (k*(T1 – T0)) </p>
<p>其中T0是新闻发布时间，T1是当前时间。</p>
<p>如当前系统中EXP(-TIMESTAMPDIFF(SECOND,t.add_time,NOW())/240) 换算成以上公式为 T(Time) = 1/(e ^ (240*(T1 – T0)))</p>
<p>###上下文因素</p>
<p>时间(一天的某些时间段..)、地点、季节、天气。。</p>
<p>###改进基于内容的推荐</p>
<p>改进方面：</p>
<p>1.算法改进</p>
<p>2.收藏数、评论数、转发数等加入权重</p>
<p>4.对文章的提取不是很完美（在文章分词时，最好把每个词的词频与逆文本频率也记录其中，参考：tf-idf模型）</p>
<p>###基于协同过滤的推荐</p>
<p>文章的基数量太大（不适用对物品的协同过滤），比较适用对用户的协同过滤，取得相似用户，将其内容推荐给相似用户，需要加入时间衰减因子。</p>
<p>算法：</p>
<p>1.皮尔逊相关系数 </p>
<p>2.余弦相似度 </p>
<p>3.相似度矩阵算法</p>
<p>###基于内容的推荐与协同过滤融合</p>
<p>参考文献：</p>
<p>《基于内容的推荐于协同过滤融合的新闻推荐方法》</p>
<p>《实时新闻推荐系统的设计与实现》</p>
<h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p>协同过滤-相似度算法：</p>
<p><a href="https://zhuanlan.zhihu.com/p/33164335" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33164335</a></p>
<p>基于内容的推荐算法：</p>
<p><a href="https://blog.csdn.net/nicajonh/article/details/79657317" target="_blank" rel="noopener">https://blog.csdn.net/nicajonh/article/details/79657317</a></p>
<p><a href="https://blog.csdn.net/qq_32690999/article/details/77434381" target="_blank" rel="noopener">https://blog.csdn.net/qq_32690999/article/details/77434381</a></p>
<p>新闻推荐算法概述：</p>
<p>第 1 部分: 推荐引擎初探：<a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/</a></p>
<p>第 2 部分: 深入推荐引擎相关算法 - 协同过滤：<a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.html?ca=drs-</a></p>
<p>第 3 部分: 深入推荐引擎相关算法 - 聚类： <a href="https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy3/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy3/index.html?ca=drs-</a></p>
<p>热度算法和个性化推荐： </p>
<p><a href="https://www.jianshu.com/p/f8b6ac988045" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b6ac988045</a></p>
<p>参考文献：</p>
<p>《基于新闻时效性的协同过滤推荐算法》 - 提出一种时间老化模型，配合协同过滤</p>
<p>《基于用户行为的个性化新闻推荐系统研究》 - 一套比较完整的新闻推荐算法</p>
<p>《基于主题模型与用户兴趣的个性化新闻推荐算法研究》 - 对用户兴趣模型的改进</p>
<p>《实时新闻推荐系统的设计与实现》 - 一套比较完整的新闻推荐算法</p>
<p>《新闻推荐算法 3A问题及优化策略》</p>
<p>《移动环境下上下文感知的协同过滤推荐模型研究》- 基于上下文(时间、地理、温度、天气)感知的协同过滤算法</p>
<p>《基于内容的推荐与协同过滤融合的新闻推荐方法》- 融合两种算法提升其准确度</p>
<p>《基于时间段的动态用户兴趣度矩阵的新闻推荐研究》</p>
<p>《新闻推荐系统中用户冷启动问题的研究》- 当项目刚启动时，并没有很多用户，用决策树更好的构建用户的初始兴趣模型</p>
]]></content>
  </entry>
  <entry>
    <title>LBS方案调研</title>
    <url>/2019/12/31/LBS%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本次需求需要做附近的人推荐，可能涉及到LBS，所以基于此做以下调研。</p>
<p>涉及到的方案：</p>
<p>Redis mongoDb elasticSearch Mysql</p>
<p>由于网上多数人支持PostGIS所以加上这个</p>
 <a id="more"></a>

<h2 id="方案优劣对比"><a href="#方案优劣对比" class="headerlink" title="方案优劣对比"></a>方案优劣对比</h2><h3 id="Elasticsearch-or-solr"><a href="#Elasticsearch-or-solr" class="headerlink" title="Elasticsearch or solr"></a>Elasticsearch or solr</h3><p>概述：天然支持，性能很优，功能也比较多</p>
<p>版本支持：Available 6.6</p>
<p>功能列举（根据ES,不一定全）：</p>
<p>其中es有两个type↓</p>
<p>geo-point：基于点坐标的一些操作 </p>
<p>找出落在指定矩形框中的点。</p>
<p>找出与指定位置在给定距离内的点。</p>
<p>找出落在多边形中的点。</p>
<p>geo-shape：基于点，线，面的一些复杂操作</p>
<p>不但包含基于点的一些操作，还有对于线和面的操作，例如查询：</p>
<p>intersects: 查询的形状与索引形状有重叠(默认)</p>
<p>disjoint: 查询的形状与索引的ixngzhuang完全不重叠</p>
<p>within: 索引的形状被包含在查询中</p>
<p>优点：功能全，速度快</p>
<p>缺点：英文文档是致命伤。。有些没太理解，更新索引效率低，不适合实时更新场景（例如像外卖骑手位置实时显示这种场景就不太合适）</p>
<h3 id="PostGIS扩展名的PostgreSQL"><a href="#PostGIS扩展名的PostgreSQL" class="headerlink" title="PostGIS扩展名的PostgreSQL"></a>PostGIS扩展名的PostgreSQL</h3><p>概述：功能比es更强大，更多网友推荐的选择</p>
<p>优点：功能全，速度快</p>
<p>缺点：复杂索引时写入较慢</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>版本支持：Available since 3.2.0.</p>
<p>优点：效率高，简单</p>
<p>缺点：功能比较基础，较少，不支持多条件筛选，能满足简单场景，比如：查找一个给定范围内有哪些店铺就不好做</p>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>版本支持：Available since 5.0+</p>
<p>Mysql 内置函数方案，适合于已有业务，新增加LBS功能，增加经纬度字段方可，避免数据迁移</p>
<p>5.6版本的innoDb不支持R-tree，只支持平面距离，如果需要建索引需要将表设为MyISAM引擎</p>
<p>5.6空间索引特性：</p>
<p><a href="https://www.percona.com/blog/2013/10/21/using-the-new-mysql-spatial-functions-5-6-for-geo-enabled-applications/" target="_blank" rel="noopener">https://www.percona.com/blog/2013/10/21/using-the-new-mysql-spatial-functions-5-6-for-geo-enabled-applications/</a></p>
<p>5.7版本之后会把R-tree进入innoDb，根据球面距离计算，查询速度较快</p>
<p>5.7空间索引特性：</p>
<p><a href="https://www.percona.com/blog/2016/02/03/new-gis-features-in-mysql-5-7/?spm=a2c4e.10696291.0.0.368619a4PpB0uW" target="_blank" rel="noopener">https://www.percona.com/blog/2016/02/03/new-gis-features-in-mysql-5-7/?spm=a2c4e.10696291.0.0.368619a4PpB0uW</a></p>
<p>优点：功能较多，<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-function-reference.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/spatial-function-reference.html</a></p>
<p>缺点：没有redis这么简单</p>
<p>###MongoDb</p>
<p>Mongodb 内置函数方案，适合中小型应用，快速实现LBS功能，性能好，美团用的就是mongo db</p>
<p>优点：相对于es来说有实时性优势</p>
<p>缺点：资源占用大，数据量达到百万级请流量在10w左右查询速度明显下降。而PostGIS随着数据量的增加查询速率呈线性增长（不及PostGIS）</p>
<h2 id="考虑的点"><a href="#考虑的点" class="headerlink" title="考虑的点"></a>考虑的点</h2><p>读写比较频繁，位置的变动与查询很频繁</p>
<h2 id="LBS方案对比表"><a href="#LBS方案对比表" class="headerlink" title="LBS方案对比表"></a>LBS方案对比表</h2><p>ps：各类指标，10分为最高分，也就是最优的意思。</p>
<table>
<thead>
<tr>
<th></th>
<th>Elasticsearch</th>
<th>PostGIS</th>
<th>Redis</th>
<th>Mysql 5.7</th>
<th>MongoDb</th>
<th>理由</th>
<th>预留</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>9</td>
<td>9</td>
<td>10</td>
<td>7</td>
<td>8</td>
<td>ES：性能好，但是实时性不太好  mongodb：性能好，随着数据量越大，性能下降明显  PostGIS：性能好，随着数量越大，性能呈线性下降  Redis：性能及好，内存计算就是不一样  Mysql：mysql不支持动态更新索引加上是R树，性能确实比其他的差</td>
<td></td>
</tr>
<tr>
<td>功能</td>
<td>9</td>
<td>10</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>PostGIS：满分，基本就是按照OGC的标准来实现的  ES：一般  Mongodb：与ES差不多  Mysql：只是实现了部分OGC标准  Redis：功能比较简单，不支持分页哦  详情见功能对比表附录1</td>
<td></td>
</tr>
<tr>
<td>操作难易度</td>
<td>8</td>
<td>6</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td>Redis最简单，这里考虑到安装以及学习的成本，所以PostGIS与MongoDb排的比较低</td>
<td></td>
</tr>
<tr>
<td>业界使用量</td>
<td>8</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>10</td>
<td>MongoDb：业内用的比较多吧  PostGIS：和MongoDb差不多，没有统计的渠道，听网上的人说的  Redis、ES、Mysql：这三者使用量不确定，但是Mysql肯定是最低的~</td>
<td></td>
</tr>
<tr>
<td>网友推荐度</td>
<td>9</td>
<td>10</td>
<td>8</td>
<td>7</td>
<td>10</td>
<td>网友大多是支持PostGIS和MongoDb的方案</td>
<td></td>
</tr>
<tr>
<td>总分</td>
<td>43</td>
<td>44</td>
<td>43</td>
<td>38</td>
<td>44</td>
<td>吐槽：别的不说，mysql肯定是垫底了~</td>
<td></td>
</tr>
</tbody></table>
<p>附录1：功能对比</p>
<p><img src="data:image/png;base64,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" alt="MYSQL  PostGlS  MongoDd  事 务  不 支  不 支  SpatialIndex  索 引 类 型  R T 巳  RTree/GIST  Geohasn  Geohasn  不 支  Replication  故 違 转 移  不 支  不 支  不 支  不 支  Sharding  标 准 支  数 据 量  中 小 型  中 小 型  中 小 型  筒 望 空 间 幞 作  杂 空 间 幞 作  杂 空 间 幞 作  筒 望 空 间 幞 作 "></p>
<h1 id><a href="#" class="headerlink" title></a></h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，mongoDb是首选，其次是PostGIS，接着是es,mysql,redis，个人观点：由于需要照顾现有数据，可能mysql更实用些，量大了再说！</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>es与PostGIS性能对比</p>
<p><a href="https://blog.csdn.net/luosai19910103/article/details/53729783" target="_blank" rel="noopener">https://blog.csdn.net/luosai19910103/article/details/53729783</a></p>
<p>Mysql、mongodb、redis方案对比</p>
<p><a href="https://www.jianshu.com/u/513202559d5c" target="_blank" rel="noopener">https://www.jianshu.com/u/513202559d5c</a></p>
<p>mongodb、mysql5.7、redis、Lucene对比</p>
<p><a href="https://www.iteye.com/blog/casestudy-2298333" target="_blank" rel="noopener">https://www.iteye.com/blog/casestudy-2298333</a></p>
<p>MySQL · 引擎特性 · 初识 MySQL GIS 及 InnoDB R-TREE</p>
<p><a href="https://yq.aliyun.com/articles/50625" target="_blank" rel="noopener">https://yq.aliyun.com/articles/50625</a></p>
<p>MySQL 5.7 GIS特性与性能测试</p>
<p><a href="http://i.dataguru.cn/mportal.php?mod=view&amp;aid=10791" target="_blank" rel="noopener">http://i.dataguru.cn/mportal.php?mod=view&amp;aid=10791</a></p>
<p>MySQL、PostgreSQL、Redis、MongoDB、ElasticSearch方案对比以及空间索引Spatial Index相关基本概念</p>
<p><a href="https://cloud.tencent.com/developer/news/199266" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/199266</a></p>
<p>LBS类数据服务对比分析（一）、（二）</p>
<p><a href="https://sq.163yun.com/blog/article/167710741576384512" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/167710741576384512</a></p>
<p><a href="https://sq.163yun.com/blog/article/167711439152054272" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/167711439152054272</a></p>
]]></content>
  </entry>
  <entry>
    <title>论职业素养</title>
    <url>/2019/11/15/%E8%AE%BA%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/</url>
    <content><![CDATA[<h2 id="为什么要写这篇？"><a href="#为什么要写这篇？" class="headerlink" title="为什么要写这篇？"></a>为什么要写这篇？</h2><p>为什么要写关乎于职业素养这种东西呢？因为我在开发中深感疲惫，人生已经如此艰难，为什么做个开发还要承受这么大的压力呢。总结了一下，可能会有以下几点:</p>
<ol>
<li>产品人员需求朝令夕改，不同步至文档</li>
<li>产品人员对需求描述不详细，不确定</li>
<li>开发人员需求评审不认真</li>
<li>开发人员技术评审不认真</li>
<li>开发人员太依赖于服务端（我感觉都是服务端的爹，天天都要催）</li>
<li>开发人员间信息不同步</li>
<li>开发人员没有主观能动性，遇事能拖就拖</li>
<li>开发人员没有时间观念</li>
<li>开发人员对提测，上线等重要里程碑式阶段不重视</li>
<li>开发人员排期不合理，导致每次里程碑式阶段都延期or加班</li>
</ol>
<p>随便一想就有这么多，种种原因不得不让我思索是不是开发人员的技术有问题，在和同事的讨论中，认为平常的开发真的不需要水平很高，如此，产生了对&lt;职业素养&gt;一词的思索。</p>
<a id="more"></a>

<h2 id="何为职业素养？"><a href="#何为职业素养？" class="headerlink" title="何为职业素养？"></a>何为职业素养？</h2><p>我个人职业素养的核心在于 做好&lt;份内之事&gt;。</p>
<h2 id="何为份内之事"><a href="#何为份内之事" class="headerlink" title="何为份内之事?"></a>何为份内之事?</h2><p>有的人可能会说”我做好自己份内之事就行了”。那么到底什么是份内之事呢？以下论点只限于一个开发工程师，我们来从上之下捋一下作为一个工程师的”份内之事”。</p>
<h3 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h3><p>按计划，产品经理应当视需求内容提前相应的天数，以邮件形式通知开发人员有新需求。开发人员在接到邮件后，应当梳理现在手头上的工作，将阅读需求放在你的待办事项上，阅读需求也不是草草而看，在阅读时，应当思考以下几点：</p>
<ol>
<li>此需求是否合理</li>
<li>此需求的优先级</li>
<li>此需求的大致相关实现</li>
<li>列出在阅读需求文档时心中的疑惑</li>
</ol>
<p>阅读完需求文档，你应该有相应的输出：</p>
<ol>
<li>大致的实现思路（一般以xmind形式）</li>
<li>需求中遇到的问题（一般以文本形式即可）</li>
</ol>
<p>将《需求问题》反馈至产品经理，产品经理做出相应的解答并发邮件告知。如反馈不到位，可当面进行沟通并做记录，直至双方对需求都有大致的共同认知。</p>
<p>在参加需求评审的过程中，因为需求评审是多方的一个会议，应当积极的参与讨论。在需求文档中将所有的需求都了然于胸。</p>
<h3 id="技术评审"><a href="#技术评审" class="headerlink" title="技术评审"></a>技术评审</h3><p>在确定完需求之后，开发人员应该对之前在需求文档中编写的大致实现做出细致的描写，以及轻微的改动，并与其他开发人员进行沟通，达成一致。将整个迭代任务的实现思路，详细的描绘至xmind脑图，如果有难以判断的任务可相应的询问上级开发征求意见，以每天8h的工作量估算排期，将排期尽量细化，考虑周全。做足一切准备之后进行开发。</p>
<h3 id="接口评审"><a href="#接口评审" class="headerlink" title="接口评审"></a>接口评审</h3><p>由于做好了准备，所以接口定义并不难，在接口定义时需要考虑向后兼容，并提供模拟数据，写好注释,可以交由组长检查或者找同事相互校队。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码时，要保持良好的编码习惯，秉持高内聚、低耦合的观念，不要在一个类中写长篇大论，具体编码规约可参考【阿里巴巴编码规范】，遇到重复代码时考虑设计模式。写好注释，不然后来的人不一定看得懂。</p>
<p>在编码时如果经常要改动之前定义的接口，说明自己没有思考到位，在通知客户端接口变更的同时也要告诫自己在前期多思考。</p>
<p>编码期间不要忘了测试用例的编写，测试用例能让后来的人更能了解这串代码的作用，以及需要注意的点。</p>
<h3 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h3><p>编码完成之后，需要跟着测试用例将自己的功能实现进行反复的验证，做到最基本的测试，比如边界测试等，不能让测试人员进行测试时，频繁的报&lt;服务器错误&gt;。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>个人认为测试期间是开发人员比较空的时间，在测试期间，遇到bug应当积极改正，如果同事比较忙，可协助更改一些简单的bug。在测试期间需要对跟踪测试环境的日志，遇到错误日志应当积极改正。</p>
<h3 id="预发-amp-上线"><a href="#预发-amp-上线" class="headerlink" title="预发&amp;上线"></a>预发&amp;上线</h3><p>上线期间，保持高度的严谨，保证在上线的期间，处于待命状态，遇到问题尽快的定位并解决。</p>
<h3 id="上线后"><a href="#上线后" class="headerlink" title="上线后"></a>上线后</h3><p>在项目完成上线后，切不可怠慢，需要持续跟踪监视数据库中的数据是否正确，是否有不应该为空的字段为空。</p>
<p>并且要持续跟踪日志，看有无相关报错。在此期间可以进行code review，熟悉相关代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人觉得，如果开发人员每个人都能做到遇事积极解决，发挥主观能动性，其实做开发也不是一件很累的事情。有的人可能会抱怨，产品的需求变化多端搞得自己很累，其实产品的需求变化是不可避免，我们开发人员唯一要做的就是当产品提出需求变化时，怎样能使得开发更加轻松。</p>
]]></content>
  </entry>
  <entry>
    <title>Solr or Elasticsearch</title>
    <url>/2019/11/14/Solr-or-Elasticsearch/</url>
    <content><![CDATA[<p>Elasticsearch是一个实时的分布式搜索和分析引擎。它可以帮助你用前所未有的速度去处理大规模数据。</p>
<p>它可以用于全文搜索，结构化搜索以及分析，当然你也可以将这三者进行组合。</p>
<a id="more"></a>

<p>Elasticsearch是一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎，可以说Lucene是当今最先进，最高效的全功能开源搜索引擎框架。</p>
<p>但是Lucene只是一个框架，要充分利用它的功能，需要使用JAVA，并且在程序中集成Lucene。需要很多的学习了解，才能明白它是如何运行的，Lucene确实非常复杂。</p>
<p>Elasticsearch使用Lucene作为内部引擎，但是在使用它做全文搜索时，只需要使用统一做好的API即可，而不需要了解其背后复杂的Lucene的运行原理。</p>
<p>当然Elasticsearch并不仅仅是Lucene这么简单，它不但包括了全文搜索功能，还可以进行以下工作:</p>
<ul>
<li>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</li>
<li>实时分析的分布式搜索引擎。</li>
<li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</li>
</ul>
<p>这么多的功能被集成到一台服务器上，你可以轻松地通过客户端或者任何你喜欢的程序语言与ES的RESTful API进行交流。</p>
<p>Elasticsearch的上手是非常简单的。它附带了很多非常合理的默认值，这让初学者很好地避免一上手就要面对复杂的理论，</p>
<p>它安装好了就可以使用了，用很小的学习成本就可以变得很有生产力。</p>
<p>随着越学越深入，还可以利用Elasticsearch更多高级的功能，整个引擎可以很灵活地进行配置。可以根据自身需求来定制属于自己的Elasticsearch。</p>
<p>使用案例：</p>
<ul>
<li>维基百科使用Elasticsearch来进行全文搜做并高亮显示关键词，以及提供search-as-you-type、did-you-mean等搜索建议功能。</li>
<li>英国卫报使用Elasticsearch来处理访客日志，以便能将公众对不同文章的反应实时地反馈给各位编辑。</li>
<li>StackOverflow将全文搜索与地理位置和相关信息进行结合，以提供more-like-this相关问题的展现。</li>
<li>GitHub使用Elasticsearch来检索超过1300亿行代码。</li>
<li>每天，Goldman      Sachs使用它来处理5TB数据的索引，还有很多投行使用它来分析股票市场的变动。</li>
</ul>
<p>但是Elasticsearch并不只是面向大型企业的，它还帮助了很多类似DataDog以及Klout的创业公司进行了功能的扩展。</p>
<p>Elasticsearch的优缺点<a href="http://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/10213009/solr-vs-elasticsearch">*</a><a href="http://link.zhihu.com/?target=http%3A//huangx.in/22/translation-solr-vs-elasticsearch">*</a>:</p>
<p>优点</p>
<ol>
<li>Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push      replication”。</li>
<li>Elasticsearch      完全支持 Apache Lucene 的接近实时的搜索。</li>
<li>处理多租户（<a href="http://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Multitenancy">multitenancy</a>）不需要特殊配置，而Solr则需要更多的高级设置。</li>
<li>Elasticsearch      采用 Gateway 的概念，使得完备份更加简单。</li>
<li>各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。</li>
</ol>
<p>缺点</p>
<ol>
<li>只有一名developer（当前Elasticsearch      GitHub组织已经不只如此，已经有了相当活跃的维护者）</li>
<li>还不够自动（不适合当前新的Index      Warmup API）</li>
</ol>
<p>Solr简介<a href="http://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Solr">*</a></p>
<p>Solr（读作“solar”）是Apache Lucene项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理。Solr是高度可扩展的，并提供了分布式搜索和索引复制。Solr是最流行的企业级搜索引擎，Solr4 还增加了NoSQL支持。</p>
<p>Solr是用Java编写、运行在Servlet容器（如 Apache Tomcat 或Jetty）的一个独立的全文搜索服务器。 Solr采用了 Lucene Java 搜索库为核心的全文索引和搜索，并具有类似REST的HTTP/XML和JSON的API。Solr强大的外部配置功能使得无需进行Java编码，便可对其进行调整以适应多种类型的应用程序。Solr有一个插件架构，以支持更多的高级定制。</p>
<p>因为2010年 Apache Lucene 和 Apache Solr 项目合并，两个项目是由同一个Apache软件基金会developement团队制作实现的。提到技术或产品时，Lucene/Solr或Solr/Lucene是一样的。</p>
<p>Solr的优缺点</p>
<p>优点</p>
<ol>
<li>Solr有一个更大、更成熟的用户、developer和贡献者社区。</li>
<li>支持添加多种格式的索引，如：HTML、PDF、微软      Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。</li>
<li>Solr比较成熟、稳定。</li>
<li>不考虑建索引的同时进行搜索，速度更快。</li>
</ol>
<p>缺点</p>
<ol>
<li>建立索引时，搜索效率下降，实时索引搜索效率不高。</li>
</ol>
<p>Elasticsearch与Solr的比较<a href="http://link.zhihu.com/?target=http%3A//blog.socialcast.com/realtime-search-solr-vs-elasticsearch/">*</a></p>
<p>当单纯的对已有数据进行搜索时，Solr更快。</p>
<p>Search Fesh Index While Idle</p>
<p>当实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势。</p>
<p>search_fresh_index_while_indexing</p>
<p>随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化。</p>
<p>search_fresh_index_while_indexing</p>
<p>综上所述，Solr的架构不适合实时搜索的应用。</p>
<p>实际生产环境测试<a href="http://link.zhihu.com/?target=http%3A//blog.socialcast.com/realtime-search-solr-vs-elasticsearch/">*</a></p>
<p>下图为将搜索引擎从Solr转到Elasticsearch以后的平均查询速度有了50倍的提升。</p>
<p>average_execution_time</p>
<p>Elasticsearch 与 Solr 的比较总结</p>
<ul>
<li>二者安装都很简单；</li>
<li>Solr      利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</li>
<li>Solr      支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</li>
<li>Solr      官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</li>
<li>Solr      在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。</li>
</ul>
<p>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</p>
<p>其他基于Lucene的开源搜索引擎解决方案<a href="http://link.zhihu.com/?target=http%3A//mail-archives.apache.org/mod_mbox/hbase-user/201006.mbox/%253C149150.78881.qm%40web50304.mail.re2.yahoo.com%253E">*</a></p>
<ol>
<li>直接使用 <a href="http://link.zhihu.com/?target=http%3A//lucene.apache.org/">Lucene</a></li>
</ol>
<p>说明：Lucene 是一个 JAVA 搜索类库，它本身并不是一个完整的解决方案，需要额外的工作。</p>
<p>优点：成熟的解决方案，有很多的成功案例。apache 顶级项目，正在持续快速的进步。庞大而活跃的社区，大量的developers。它只是一个类库，有足够的定制和优化空间：经过简单定制，就可以满足绝大部分常见的需求；经过优化，可以支持 10亿+ 量级的搜索。</p>
<p>缺点：需要额外的工作。所有的扩展，分布式，可靠性等都需要自己实现；非实时，从建索引到可以搜索中间有一个时间延迟，而当前的“近实时”(Lucene Near Real Time search)搜索方案的可扩展性有待进一步完善</p>
<ul>
<li><a href="http://link.zhihu.com/?target=http%3A//katta.sourceforge.net/">Katta</a></li>
</ul>
<p>说明：基于 Lucene 的，支持分布式，可扩展，具有容错功能，准实时的搜索方案。</p>
<p>优点：开箱即用，可以与 Hadoop 配合实现分布式。具备扩展和容错机制。</p>
<p>缺点：只是搜索方案，建索引部分还是需要自己实现。在搜索功能上，只实现了最基本的需求。成功案例较少，项目的成熟度稍微差一些。因为需要支持分布式，对于一些复杂的查询需求，定制的难度会比较大。</p>
<ul>
<li><a href="http://link.zhihu.com/?target=http%3A//svn.apache.org/repos/asf/hadoop/mapreduce/trunk/src/contrib/index/README">Hadoop      contrib/index</a></li>
</ul>
<p>说明：Map/Reduce 模式的，分布式建索引方案，可以跟 Katta 配合使用。</p>
<p>优点：分布式建索引，具备可扩展性。</p>
<p>缺点：只是建索引方案，不包括搜索实现。工作在批处理模式，对实时搜索的支持不佳。</p>
<ul>
<li><a href="http://link.zhihu.com/?target=http%3A//sna-projects.com/">LinkedIn      的开源方案</a></li>
</ul>
<p>说明：基于 Lucene 的一系列解决方案，包括 准实时搜索 zoie ，facet 搜索实现 bobo ，机器学习算法 decomposer ，摘要存储库 krati ，数据库模式包装 sensei 等等</p>
<p>优点：经过验证的解决方案，支持分布式，可扩展，丰富的功能实现</p>
<p>缺点：与 linkedin 公司的联系太紧密，可定制性比较差</p>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//github.com/tjake/Lucandra">Lucandra</a></li>
</ul>
<p>说明：基于 Lucene，索引存在 cassandra 数据库中</p>
<p>优点：参考 cassandra 的优点</p>
<p>缺点：参考 cassandra 的缺点。另外，这只是一个 demo，没有经过大量验证</p>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//github.com/akkumar/hbasene">HBasene</a></li>
</ul>
<p>说明：基于 Lucene，索引存在 HBase 数据库中</p>
<p>优点：参考 HBase 的优点</p>
<p>缺点：参考 HBase 的缺点。另外，在实现中，lucene terms 是存成行，但每个 term 对应的 posting lists 是以列的方式存储的。随着单个 term 的 posting lists 的增大，查询时的速度受到的影响会非常大。</p>
]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>策略与简单工厂</title>
    <url>/2019/11/14/%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p>应用场景：</p>
<p>简单工厂：重点在对象的创建</p>
<p>策略：重点在算法的封装</p>
<a id="more"></a>

<p>简单工厂：</p>
<p><img src="file:///C:/Users/38794/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="A  Factory  Factory  + CreatProduct()  A  product  productA  A  pro  producte  A  productC "></p>
<p>客户端通过某个指令就可触发工厂对于对象的创建，对工厂内部创建对象的过程高度闭合。但是客户端需要清晰的知道产品种类才能创建出来。</p>
<p>策略&lt;原始&gt;：</p>
<p><img src="file:///C:/Users/38794/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image002.png" alt="A  Content  Content  + Contentlnterface()  A  A  Strategy  A  StrategyA  + Alfoeirhmlnterface()  _5tra  + Alfoeirhminterface()  SErategyB  + Alfoeirhmlnterface()  A  SErategyC  + Alfoeirhmlnterface() "></p>
<p>context中定义了strategy的抽象策略。依靠传进来的具体策略进行策略的执行。由客户端将策略传过来，所以客户端需要知晓所有的策略。</p>
<p>通过比较客户端的代码发现： </p>
<p>简单工厂模式：将对象的选择创建交给了简单工厂类，客户端只需要输入相应的条件就可以，不用负责对象的创建，但是需要客户端自己调用算法类的方法。但是一旦需要增加新的运算类，比如开根运算，就要去修改简单工厂类。 </p>
<p>策略模式：对象的选择创建仍需要自己来做，但是将调用方法的职责交给了Context类。一旦需要增加新的策略需要修改客户端。</p>
<p>因此，简单工厂模式的缺点就是当有新的需求增加时，需要频繁的修改工厂类。只用策略模式，当有新的需求增加时需要修改的是客户端，客户端仍然承担着创建对象的职责，并没有减轻客户端的压力。而将这两种模式结合起来使用，则需要修改 Context 类，总之不是完美的。</p>
<p>策略&lt;简单工厂改进版&gt;：</p>
<p>用来简单工厂来改进之后，也可以通过指令就可以触发策略以及context对象的创建。同样，客户端还是需要知道策略种类才能创建出来。</p>
<p>策略模式中的确有简单工厂的影子。比如具体的策略其实是由简单工厂所创建。但是策略模式的着重点在于将策略从中解耦，抽离出来，以便策略的转换</p>
<p>无论是产品的创建，还是策略的创建。往小了说，其实都是黑盒，因为客户端都不知道里面是怎么实现的。往大了说，那就是白盒，因为客户端必须知道产品的种类抑或是策略的种类才能使程序正常进行下去。网上有一部分人说策略是白盒，工厂是黑盒，我觉得很莫名其妙，我理解他们觉得策略是白盒是因为客户端需要传个策略对象，所以必须知道所有的策略才能创建。而觉得工厂是黑盒是因为对象的创建是完全封闭的。但是这两个判断白盒黑盒的条件个人认为不太对等，策略的创建那他妈也是黑盒啊。</p>
<p>一个是创建型，另一个是行为型，然而两种不同类型的模式，在某些地方也有一丝的相似之处，同时在某种场景下结合使用，能起到特别好的效果。</p>
<p>题外话：网上有人认为简单工厂严格上不算作设计方式，可以当作一种编写良好代码的习惯。</p>
<p>个人理解：我觉得策略模式是针对于某种特定场景，比如：抽奖，活动，算法等场景，而研发出的一种设计模式，其中策略的创建借鉴了简单工厂的思想。将每一个算法封装起来后，使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>总结简单工厂模式和策略模式</p>
<p>1.从类型上说：简单工厂模式属于创建型模式，而策略模式属于行为型模式。 </p>
<p>2.接下来，看一个小例子： </p>
<p>斧子有很多种，有一个工厂专门负责生产各种需求的斧子。</p>
<p>工厂模式： </p>
<p>1）根据你给出的目的来生产不同用途的斧子，例如要砍人，那么工厂生产砍人斧子，要伐木就生产伐木斧子。 </p>
<p>2）即根据你给出一些属性来生产不同行为的一类对象返回给你。 </p>
<p>3）关注对象创建</p>
<p>策略模式： </p>
<p>1）用工厂生产的斧子来做对应的事情，例如用砍人的斧子来砍人，用伐木的斧子来伐木。 </p>
<p>2）即根据你给出对应的对象来执行对应的方法。 </p>
<p>3）关注行为的选择</p>
<p>3.简单工厂模式：根据客户选择的条件，来帮客户创建一个对象。 </p>
<p>策略模式：客户给它一个创建好的对象，它来帮客户做相应的事。</p>
<p>策略模式和简单工厂模式看起来很相似，都是通过多态来实现不同子类的选取，这样的思想应该是从程序的总体来看得出的。</p>
<p>假设从使用这两种模式的角度来看的话，我们会发如今<a href="http://www.tianboo.net/" target="_blank" rel="noopener">简单工厂模式</a>中我们仅仅须要传递对应的条件就能得到想要的一个对象（告诉别人我要干嘛、别人去做），然后通过这个对象实现算法的操作。</p>
<p>而<a href="http://www.tianboo.net/" target="_blank" rel="noopener">策略模式</a>，使用时必须首先创建一个想使用的类对象（自己去做）。然后将该对象最为參数传递进去，通过该对象调用不同的算法。在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取对应对象的工作交给模式的使用者，它本身不去做选取工作。</p>
<p>结合上面的代码和以下的释义不难看出。事实上两个的区别非常微妙,工厂(factory)是直接创建详细的对象并用该对象去运行对应的动作，而策略(strategy)将这个操作给了Context类。没有创建详细的对象，实现的代码的进一步封装，client代码并不须要知道详细的实现过程。</p>
<p>当然用的最多的还是两者的结合使用。</p>
<p>重点：</p>
<p>设计模式主要是实践设计原则的（单一职责，开闭原则，依赖倒置原则，迪米特法则）</p>
<p>所有的设计原则都是围绕着一个观点那就是封装变化</p>
<p>如果把变化封装的足够好，我们就可以再变化到来的时候做最小的应对，也就是最小程度的改代码</p>
<p>模式就是一种经验，一种成熟的做法</p>
<p>抽象工厂模式用于创建对象时的变化</p>
<p>策略模式用于算法实现时的变化</p>
<p>他们本质上都是变化</p>
<p>封装变化最好的方法，就是依赖抽象，利用多态，面向接口编程</p>
<p>有了里氏代换原则，才使得开放-封闭原则成为了可能</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
