<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2019/11/15/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>策略与简单工厂</title>
    <url>/2019/11/15/%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p>应用场景：</p>
<p>简单工厂：重点在对象的创建</p>
<p>策略：重点在算法的封装</p>
<p>简单工厂：</p>
<p><img src="file:///C:/Users/38794/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="A  Factory  Factory  + CreatProduct()  A  product  productA  A  pro  producte  A  productC "></p>
<p>客户端通过某个指令就可触发工厂对于对象的创建，对工厂内部创建对象的过程高度闭合。但是客户端需要清晰的知道产品种类才能创建出来。</p>
<p>策略&lt;原始&gt;：</p>
<p><img src="file:///C:/Users/38794/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image002.png" alt="A  Content  Content  + Contentlnterface()  A  A  Strategy  A  StrategyA  + Alfoeirhmlnterface()  _5tra  + Alfoeirhminterface()  SErategyB  + Alfoeirhmlnterface()  A  SErategyC  + Alfoeirhmlnterface() "></p>
<p>context中定义了strategy的抽象策略。依靠传进来的具体策略进行策略的执行。由客户端将策略传过来，所以客户端需要知晓所有的策略。</p>
<p>通过比较客户端的代码发现： </p>
<p>简单工厂模式：将对象的选择创建交给了简单工厂类，客户端只需要输入相应的条件就可以，不用负责对象的创建，但是需要客户端自己调用算法类的方法。但是一旦需要增加新的运算类，比如开根运算，就要去修改简单工厂类。 </p>
<p>策略模式：对象的选择创建仍需要自己来做，但是将调用方法的职责交给了Context类。一旦需要增加新的策略需要修改客户端。</p>
<p>因此，简单工厂模式的缺点就是当有新的需求增加时，需要频繁的修改工厂类。只用策略模式，当有新的需求增加时需要修改的是客户端，客户端仍然承担着创建对象的职责，并没有减轻客户端的压力。而将这两种模式结合起来使用，则需要修改 Context 类，总之不是完美的。</p>
<p>策略&lt;简单工厂改进版&gt;：</p>
<p>用来简单工厂来改进之后，也可以通过指令就可以触发策略以及context对象的创建。同样，客户端还是需要知道策略种类才能创建出来。</p>
<p>策略模式中的确有简单工厂的影子。比如具体的策略其实是由简单工厂所创建。但是策略模式的着重点在于将策略从中解耦，抽离出来，以便策略的转换</p>
<p>无论是产品的创建，还是策略的创建。往小了说，其实都是黑盒，因为客户端都不知道里面是怎么实现的。往大了说，那就是白盒，因为客户端必须知道产品的种类抑或是策略的种类才能使程序正常进行下去。网上有一部分人说策略是白盒，工厂是黑盒，我觉得很莫名其妙，我理解他们觉得策略是白盒是因为客户端需要传个策略对象，所以必须知道所有的策略才能创建。而觉得工厂是黑盒是因为对象的创建是完全封闭的。但是这两个判断白盒黑盒的条件个人认为不太对等，策略的创建那他妈也是黑盒啊。</p>
<p>一个是创建型，另一个是行为型，然而两种不同类型的模式，在某些地方也有一丝的相似之处，同时在某种场景下结合使用，能起到特别好的效果。</p>
<p>题外话：网上有人认为简单工厂严格上不算作设计方式，可以当作一种编写良好代码的习惯。</p>
<p>个人理解：我觉得策略模式是针对于某种特定场景，比如：抽奖，活动，算法等场景，而研发出的一种设计模式，其中策略的创建借鉴了简单工厂的思想。将每一个算法封装起来后，使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>总结简单工厂模式和策略模式</p>
<p>1.从类型上说：简单工厂模式属于创建型模式，而策略模式属于行为型模式。 </p>
<p>2.接下来，看一个小例子： </p>
<p>斧子有很多种，有一个工厂专门负责生产各种需求的斧子。</p>
<p>工厂模式： </p>
<p>1）根据你给出的目的来生产不同用途的斧子，例如要砍人，那么工厂生产砍人斧子，要伐木就生产伐木斧子。 </p>
<p>2）即根据你给出一些属性来生产不同行为的一类对象返回给你。 </p>
<p>3）关注对象创建</p>
<p>策略模式： </p>
<p>1）用工厂生产的斧子来做对应的事情，例如用砍人的斧子来砍人，用伐木的斧子来伐木。 </p>
<p>2）即根据你给出对应的对象来执行对应的方法。 </p>
<p>3）关注行为的选择</p>
<p>3.简单工厂模式：根据客户选择的条件，来帮客户创建一个对象。 </p>
<p>策略模式：客户给它一个创建好的对象，它来帮客户做相应的事。</p>
<p>策略模式和简单工厂模式看起来很相似，都是通过多态来实现不同子类的选取，这样的思想应该是从程序的总体来看得出的。</p>
<p>假设从使用这两种模式的角度来看的话，我们会发如今<a href="http://www.tianboo.net/" target="_blank" rel="noopener">简单工厂模式</a>中我们仅仅须要传递对应的条件就能得到想要的一个对象（告诉别人我要干嘛、别人去做），然后通过这个对象实现算法的操作。</p>
<p>而<a href="http://www.tianboo.net/" target="_blank" rel="noopener">策略模式</a>，使用时必须首先创建一个想使用的类对象（自己去做）。然后将该对象最为參数传递进去，通过该对象调用不同的算法。在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取对应对象的工作交给模式的使用者，它本身不去做选取工作。</p>
<p>结合上面的代码和以下的释义不难看出。事实上两个的区别非常微妙,工厂(factory)是直接创建详细的对象并用该对象去运行对应的动作，而策略(strategy)将这个操作给了Context类。没有创建详细的对象，实现的代码的进一步封装，client代码并不须要知道详细的实现过程。</p>
<p>当然用的最多的还是两者的结合使用。</p>
<p>重点：</p>
<p>设计模式主要是实践设计原则的（单一职责，开闭原则，依赖倒置原则，迪米特法则）</p>
<p>所有的设计原则都是围绕着一个观点那就是封装变化</p>
<p>如果把变化封装的足够好，我们就可以再变化到来的时候做最小的应对，也就是最小程度的改代码</p>
<p>模式就是一种经验，一种成熟的做法</p>
<p>抽象工厂模式用于创建对象时的变化</p>
<p>策略模式用于算法实现时的变化</p>
<p>他们本质上都是变化</p>
<p>封装变化最好的方法，就是依赖抽象，利用多态，面向接口编程</p>
<p>有了里氏代换原则，才使得开放-封闭原则成为了可能</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
